<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Cotadrez</title>
    <link rel="icon" type="image/svg+xml"
        href="https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main/Negro/Castillo.svg">
    <style>
        :root {
            --c-red: #e74c3c;
            --c-black: #7f8c8d;
            /* Un gris m√°s claro para el borde negro para que se vea sobre el fondo oscuro */
            --c-board-l: #f0d9b5;
            --c-board-d: #b58863;
            --c-water: #3498db;
            --c-bg: #1a252f;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--c-bg);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- CABECERA --- */
        header {
            text-align: center;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 3em;
            margin: 10;
            letter-spacing: 5px;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            font-weight: 800;
        }

        .status-bar {
            font-size: 1.2em;
            color: var(--c-gold);
            margin-top: 2px;
            font-weight: 500;
            min-height: 1.5em;
            /* Para que no salte si est√° vac√≠o */
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
            height: 80vh;
            /* Ajuste para centrar verticalmente */
        }

        /* --- PANELES LATERALES (Inventario + Mazmorra) --- */
        .panel {
            width: 240px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Para que la mazmorra no se salga de los bordes redondeados */
        }

        /* Secci√≥n Superior: Reserva (Inventario) */
        .inventory-section {
            flex: 1;
            /* Ocupa el espacio restante */
            padding: 5px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }


        /* Resaltado del Anillo de Fortaleza */
        .highlight-ring {
            box-shadow: inset 0 0 0 3px #2ecc71 !important;
            /* Borde verde interior */
            /* background-color: rgba(46, 204, 113, 0.15) !important; */
            /* Fondo sutil */
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }

            50% {
                box-shadow: inset 0 0 0 1px #2ecc71;
            }

            100% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }
        }

        /* Feedback de disparo (Arma y V√≠ctimas) - VERSI√ìN INTENSA */
        .shot-highlight {
            /* Borde interior muy marcado y fondo te√±ido */
            box-shadow: inset 0 0 40px rgb(29, 4, 1) !important;
            /* background-color: rgba(231, 76, 60, 0) !important; */
            animation: pulse-shot 1.5s infinite;
            /* Pulso m√°s r√°pido (latido) */
            z-index: 5 !important;
            /* Asegura que se pinte sobre casillas de agua u otras */
        }

        @keyframes pulse-shot {
            0% {
                box-shadow: inset 0 0 40px rgba(27, 4, 2, 0.6);
                /* background-color: rgba(231, 76, 60, 0); */
            }

            50% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* Brillo m√°ximo */
                /* background-color: rgba(231, 76, 60, 0.1); */
            }

            100% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* box-shadow: inset 0 0 40px rgba(231, 76, 60, 0.6); */
                /* background-color: rgba(231, 76, 60, 0); */
            }
        }

        /* Secci√≥n Inferior: Mazmorra */
        .dungeon-section {
            height: 180px;
            /* Tama√±o fijo para la mazmorra */
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
            /* Efecto de profundidad */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dungeon-label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dungeon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            overflow-y: auto;
        }

        /* Estilo para las piezas dentro de la mazmorra */
        .dungeon-list img {
            width: 40px;
            height: 40px;
            margin: 2px;
            filter: grayscale(10%) opacity(0.7);
            /* Efecto "prisionero" */
            transition: all 0.3s ease;
        }

        .dungeon-list img:hover {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.2);
            cursor: help;
        }

        /* Fichas rescatables: Borde brillante o cursor de mano */
        .rescue-target {
            cursor: pointer !important;
            /* box-shadow: 0 0 5px 2px var(--c-gold); */
            /* Brillo dorado de esperanza */
            filter: grayscale(0%) opacity(1) !important;
            /* Se ven vivas */
        }

        /* Items del Inventario (Sin recuadro, icono grande) */
        .inv-item {
            width: 70px;
            height: 70px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            /* Indicamos que se puede agarrar */
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            /* La imagen ocupa todo el hueco */
            filter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.5));
            /* Sombra para que destaque sobre el fondo */
            transition: transform 0.1s;
        }

        .inv-item:active img {
            transform: scale(0.9);
            /* Peque√±o efecto al hacer clic */
        }

        /* El contador de unidades (Badge) */
        .inv-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--c-gold);
            /* Color dorado para destacar */
            color: #1a252f;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        /* --- TABLERO --- */
        #board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 15px solid #34495e;
            border-radius: 4px;
            background-color: #2c3e50;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        /* --- CASILLAS --- */
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            /* <--- Nivel base de apilamiento */
            overflow: visible;
            /* <--- Permite que las piezas sobresalgan sin cortarse */
        }

        .light {
            background-color: var(--c-board-l);
        }

        .dark {
            background-color: var(--c-board-d);
        }

        .water {
            background-color: var(--c-water) !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            /* Agua con m√°s profundidad */
        }

        /* PIEZAS CUANDO EST√ÅN EN EL TABLERO */
        .piece {
            width: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            height: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            z-index: 100;
            /* <--- IMPORTANTE: Muy alto para estar siempre encima de las casillas */
            position: relative;
            /* Necesario para que el z-index funcione bien */
            cursor: grab;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.6));
            /* Sombra m√°s pronunciada para dar altura */
            pointer-events: auto;
            /* Asegura que reciba los eventos del rat√≥n */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* GHOSTING (Feedback Visual) */
        .ghost-valid {
            background-color: rgba(46, 204, 113, 0.6) !important;
            /* Verde */
            box-shadow: inset 0 0 0 2px #27ae60;
        }

        .ghost-invalid {
            background-color: rgba(231, 76, 60, 0.6) !important;
            /* Rojo */
            box-shadow: inset 0 0 0 2px #c0392b;
        }
    </style>
</head>

<body>

    <header>
        <h1 class="game-title">COTADREZ</h1>
        <div id="status-bar" class="status-bar">Elige tu ej√©rcito y sit√∫a en el tablero tu fortaleza</div>
    </header>

    <div class="main-container">
        <div class="panel" id="panel-rojo" style="border-color: var(--c-red);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-rojo"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-rojo"></div>
            </div>
        </div>

        <div id="board"></div>

        <div class="panel" id="panel-negro" style="border-color: var(--c-black);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-negro"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-negro"></div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN Y ESTADO ---
        const CONFIG = {
            repo: "https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main",
            // Definici√≥n de cantidades y nombres de archivo
            pieces: {
                'fortaleza': { qty: 1, file: 'Castillo.svg' },
                'montana': { qty: 3, file: 'Montana.svg' },
                'rey': { qty: 1, file: 'Rey.svg' },
                'chusma': { qty: 3, file: 'Chusma.svg' },
                'lanceros': { qty: 3, file: 'Lanza.svg' },
                'arqueros': { qty: 3, file: 'Arco.svg' },
                'c_ligera': { qty: 3, file: 'CaballeriaL.svg' },
                'c_pesada': { qty: 2, file: 'CaballeriaP.svg' },
                'elefante': { qty: 2, file: 'Elefante.svg' },
                'escorpion': { qty: 1, file: 'Escorpion.svg' },
                'trabuquete': { qty: 1, file: 'Catapulta.svg' },
                'dragon': { qty: 1, file: 'Dragon.svg' }
            }
        };

        let reserves = { rojo: {}, negro: {} };
        // Matriz para las PIEZAS (Tropas) - Nombre nuevo para evitar errores
        let logicBoard = Array(10).fill().map(() => Array(10).fill(null));

        // Matriz para el TERRENO (Agua) - Esta ya la ten√≠as, d√©jala igual
        let terrain = Array(10).fill().map(() => Array(10).fill(null));

        let draggingMeta = null; // Guardar√° qu√© estamos moviendo

        let fortressPos = { rojo: null, negro: null };

        let chusmaMovedCoords = null; // Guardar√° {r, c} de la chusma que acaba de mover

        let shotHighlights = []; // Guardar√° las coordenadas {r,c} del √∫ltimo disparo para mantenerlas visibles

        let besiegedArmy = null; // Guardar√° 'rojo' o 'negro' durante la resoluci√≥n del asedio

        // Almacena los prisioneros capturados POR cada jugador
        let dungeons = { rojo: [], negro: [] };

        // Estado del juego: 'init', 'deploy-p1', 'deploy-p2', 'playing'
        let gameState = 'init';
        let p1Color = null;
        let p2Color = null;
        let p1Territory = null; // 'north' (filas 0-4) o 'south' (filas 5-9)
        let turnColor = null; // 'rojo' o 'negro'

        // Funci√≥n auxiliar para mostrar mensajes temporales
        function showNotification(msg, isError = false) {
            const bar = document.getElementById('status-bar');
            bar.innerText = msg;
            bar.style.color = isError ? '#e74c3c' : '#f1c40f'; // Rojo si es error, Dorado si es info

            // Efecto visual: parpadeo r√°pido
            bar.style.opacity = 0;
            setTimeout(() => bar.style.opacity = 1, 100);

            // Volver al mensaje por defecto tras 3 segundos
            if (isError) {
                setTimeout(() => {
                    bar.innerText = getStatusText();
                    bar.style.color = '#f1c40f';
                }, 3000);
            }
        }


        // --- 2. INICIALIZACI√ìN ---
        function init() {
            console.log("Inicializando sistema...");

            // 1. Llenar las reservas con las cantidades iniciales
            for (const [type, data] of Object.entries(CONFIG.pieces)) {
                reserves.rojo[type] = data.qty;
                reserves.negro[type] = data.qty;
            }

            // 2. Inicializar gr√°ficos
            initWater();
            renderBoard();
            updateInventories();
            updateDungeons();
            document.getElementById('status-bar').innerText = getStatusText();
        }
        function initWater() {
            const waterCoords = [[3, 1], [1, 3]]; // b4, d2
            waterCoords.forEach(([r, c]) => {
                terrain[r][c] = 'water'; terrain[r][9 - c] = 'water';
                terrain[9 - r][c] = 'water'; terrain[9 - r][9 - c] = 'water';
            });
        }

        // --- 3. RENDERIZADO B√ÅSICO ---

        function renderBoard() {
            const b = document.getElementById('board');
            b.innerHTML = '';

            // --- COLOR DEL BORDE SEG√öN TURNO ---
            let borderColor = '#34495e'; // Color neutro por defecto (Azul gris√°ceo oscuro)

            // Definimos el color oscuro manual para que destaque sobre el neutro
            const darkBorder = '#111111'; // <--- CORRECCI√ìN: Gris casi negro

            if (gameState === 'deploy-p1') {
                borderColor = (p1Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'deploy-p2') {
                borderColor = (p2Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'playing' || gameState === 'siege-resolution') {
                borderColor = (turnColor === 'rojo') ? 'var(--c-red)' : darkBorder;
            }

            b.style.borderColor = borderColor;
            // ------------------------------------------

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    // --- NUEVO: PINTAR RASTRO DE DISPARO ---
                    // Si esta casilla est√° en la lista de disparos recientes, la iluminamos
                    if (shotHighlights.some(h => h.r === r && h.c === c)) {
                        tile.classList.add('shot-highlight');
                    }
                    // ---------------------------------------

                    tile.ondragover = (e) => handleDragOver(e, r, c);
                    tile.ondrop = (e) => handleDrop(e, r, c);

                    if (terrain[r][c] === 'water') {
                        tile.classList.add('water');
                    }

                    // Pintar pieza
                    const piece = logicBoard[r][c];
                    let isVisible = true;

                    // Niebla de Guerra
                    if (piece && gameState === 'deploy-p2' && piece.army === p1Color) {
                        isVisible = false;
                    }

                    if (piece && isVisible) {
                        const img = document.createElement('img');
                        img.src = getImgUrl(piece.army, piece.type);
                        img.className = 'piece';

                        // --- GESTI√ìN DE ARRASTRE Y CLICKS ---
                        let canDrag = true;

                        // Bloqueos est√°ndar
                        if (piece.type === 'fortaleza') canDrag = false;
                        if (gameState.startsWith('playing') && piece.type === 'montana') canDrag = false; // startWith para pillar ambos estados
                        if (gameState.includes('deploy')) {
                            const myColor = (gameState === 'deploy-p1') ? p1Color : p2Color;
                            if (piece.army !== myColor) canDrag = false;
                        }

                        // L√ìGICA ESPECIAL: MEDIO TURNO DE CHUSMA
                        if (gameState === 'playing-chusma-bonus') {
                            // Si es la chusma que acabamos de mover -> NO DRAG, S√ç CLICK
                            if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                                canDrag = false;
                                img.style.cursor = "pointer"; // Dedo para hacer click
                                img.title = "Click para CEDER EL TURNO";
                                img.onclick = () => finishChusmaBonusTurn();
                                // Efecto visual para destacar que est√° esperando
                                img.style.filter = "drop-shadow(0 0 5px var(--c-gold)) brightness(1.2)";
                            }
                            // El resto de piezas no-chusma se bloquean en handleDragStart, 
                            // pero visualmente podemos quitarles el drag aqu√≠ si quieres pulirlo m√°s.
                        }

                        // Asignar draggable
                        img.draggable = canDrag;
                        if (canDrag) {
                            img.ondragstart = (e) => handleDragStart(e, 'board', piece.army, piece.type, r, c);
                            img.style.cursor = "grab";
                        } else if (!img.onclick) {
                            // Si no es arrastrable ni tiene onclick especial (como la chusma o fortaleza)
                            img.style.cursor = "default";
                        }

                        // --- GESTI√ìN DE CLICS DE FORTALEZAS (Mantenemos tu c√≥digo anterior aqu√≠) ---
                        if (piece.type === 'fortaleza') {
                            // ... (Tu c√≥digo de finishTurnP1 / P2 / Asedio sigue igual) ...
                            if (gameState === 'deploy-p1' && piece.army === p1Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP1();
                            } else if (gameState === 'deploy-p2' && piece.army === p2Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP2();
                            } else if (gameState.startsWith('playing') && piece.army !== turnColor) {
                                // ... (L√≥gica de asedio si la tienes implementada) ...
                            }
                        }

                        tile.appendChild(img);
                    }

                    b.appendChild(tile);
                }
            }
        }

        // Devuelve 'north' (filas 0-4) o 'south' (filas 5-9)
        function getTerritory(r) {
            return r < 5 ? 'north' : 'south';
        }



        // Verifica si una casilla est√° en el "Anillo de Salida" (per√≠metro adyacente)

        function isInExitZone(r, c, fOrigin) {
            if (!fOrigin) return false;

            // La fortaleza ocupa (fr, fc) hasta (fr+1, fc+1)
            // El anillo va desde (fr-1, fc-1) hasta (fr+2, fc+2)
            const minR = fOrigin.r - 1;
            const maxR = fOrigin.r + 2;
            const minC = fOrigin.c - 1;
            const maxC = fOrigin.c + 2;

            // 1. Debe estar dentro del rect√°ngulo exterior
            if (r >= minR && r <= maxR && c >= minC && c <= maxC) {
                // 2. Pero NO debe ser la propia fortaleza (el hueco central)
                if (r >= fOrigin.r && r <= fOrigin.r + 1 && c >= fOrigin.c && c <= fOrigin.c + 1) {
                    return false; // Es la propia estructura
                }
                return true; // Es el anillo
            }
            return false;
        }

        // Arrancar
        init();

        // Construye la URL de la imagen seg√∫n el bando y el tipo
        function getImgUrl(army, type) {
            const folder = army === 'rojo' ? 'Rojo' : 'Negro';
            const filename = CONFIG.pieces[type].file;
            return `${CONFIG.repo}/${folder}/${filename}`;
        }

        // Dibuja las piezas en los paneles laterales
        function updateInventories() {
            ['rojo', 'negro'].forEach(army => {
                const list = document.getElementById(`inv-${army}`);
                list.innerHTML = '';

                for (const [type, data] of Object.entries(CONFIG.pieces)) {
                    const count = reserves[army][type];

                    if (count > 0) {
                        const item = document.createElement('div');
                        item.className = 'inv-item';

                        // --- CAMBIO AQU√ç: A√±adimos ondragend ---
                        const img = document.createElement('img');
                        img.src = getImgUrl(army, type);
                        img.draggable = true;

                        img.ondragstart = (e) => handleDragStart(e, 'reserve', army, type);
                        // NUEVO: Limpiar al soltar (aunque sea fuera)
                        img.ondragend = () => clearRingHighlights();
                        // ----------------------------------------

                        item.appendChild(img);

                        if (count > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'inv-badge';
                            badge.innerText = count;
                            item.appendChild(badge);
                        }
                        list.appendChild(item);
                    }
                }
            });
        }

        // --- 4. L√ìGICA DE ARRASTRAR Y SOLTAR ---

        function handleDragStart(e, source, army, type, r = null, c = null) {

            // --- L√ìGICA DE JUEGO Y MEDIO TURNO ---
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus') {

                if (gameState === 'game-over') { e.preventDefault(); return; }
                if (army !== turnColor) { e.preventDefault(); return; }

                // RESTRICCIONES DEL MEDIO TURNO (BONUS CHUSMA)
                if (gameState === 'playing-chusma-bonus') {
                    // 1. Solo se puede mover otra CHUSMA
                    if (type !== 'chusma') {
                        e.preventDefault(); return;
                    }
                    // 2. Solo piezas del TABLERO (Reserva bloqueada)
                    if (source !== 'board') {
                        e.preventDefault(); return;
                    }
                    // 3. NO se puede mover la misma unidad dos veces
                    if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                        e.preventDefault(); return;
                    }
                }
            }
            // 1. Guardamos metadatos (A√ëADIDO: coordenadas de origen)
            draggingMeta = {
                type: type,
                army: army,
                source: source,
                originR: r, // <--- NUEVO
                originC: c  // <--- NUEVO
            };

            // 2. Datos est√°ndar para el Drop
            const data = { source, army, type, originR: r, originC: c };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';

            // --- NUEVO: RESALTAR ANILLO SI VIENE DE RESERVA ---
            // (La l√≥gica est√° DENTRO de la funci√≥n, antes de la llave de cierre)
            if (source === 'reserve' && type !== 'montana') {
                highlightFortressRing(army);
            }
        }

        // 2. Permitir soltar (El navegador bloquea por defecto, hay que prevenirlo)
        // Funci√≥n auxiliar para limpiar fantasmas previos
        function clearGhosts() {
            document.querySelectorAll('.ghost-valid, .ghost-invalid').forEach(el => {
                el.classList.remove('ghost-valid', 'ghost-invalid');
            });
        }

        // Nueva funci√≥n DragOver con l√≥gica de visualizaci√≥n

        function handleDragOver(e, r, c) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!draggingMeta) return;
            clearGhosts();

            // --- NUEVO: L√ìGICA ESPEC√çFICA PARA FASE DE JUEGO ---
            if (gameState === 'playing') {
                let isValid = true;
                const target = logicBoard[r][c];
                const type = draggingMeta.type;
                const army = draggingMeta.army;
                const source = draggingMeta.source; // <--- Usamos el dato nuevo

                // 1. RESTRICCIONES DE TERRENO GENERALES
                if (terrain[r][c] === 'water') isValid = false;
                if (target && target.type === 'fortaleza') isValid = false;
                if (target && target.type === 'montana') isValid = false;

                // 2. LOGICA DIFERENCIADA: ¬øREFUERZO O MOVIMIENTO?
                if (source === 'reserve') {
                    // --- REFUERZO ---
                    // A. Debe ser en el anillo de mi fortaleza
                    const fOrigin = fortressPos[army];
                    if (!isInExitZone(r, c, fOrigin)) isValid = false;

                    // B. La casilla debe estar VAC√çA (no puedes reforzar encima de nadie)
                    if (target !== null) isValid = false;

                } else {
                    // --- MOVIMIENTO NORMAL (TABLERO -> TABLERO) ---

                    // 1. Validar Geometr√≠a (Usa la nueva funci√≥n)
                    // Usamos las coordenadas guardadas en draggingMeta
                    if (!isValidMove(type, draggingMeta.originR, draggingMeta.originC, r, c)) {
                        isValid = false;
                    }

                    // 2. Validar Ocupaci√≥n (Solo si la geometr√≠a es v√°lida)
                    if (isValid && target) {
                        if (target.army === army) {
                            if (type !== 'lanceros') isValid = false;
                        }
                        // Enemigo = Captura (V√°lido)
                    }
                }
                // Pintar
                const className = isValid ? 'ghost-valid' : 'ghost-invalid';
                const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                if (tile) tile.classList.add(className);

                return;
            }

            // FASE DE DESPLIEGUE DE TROPAS
            // 1. DEFINICI√ìN DE VARIABLES
            let isValid = true;
            const army = draggingMeta.army;
            const type = draggingMeta.type;
            const isFortress = (type === 'fortaleza');
            const isMountain = (type === 'montana');

            // Buscar posici√≥n de fortaleza
            const fOrigin = fortressPos[army];
            const hasFortress = fOrigin !== null;

            // 2. DEFINIR LAS CELDAS AFECTADAS (Variable 'cells')
            let cells = [];
            if (isFortress) {
                // Verificar l√≠mites del mapa para 2x2
                if (r + 1 > 9 || c + 1 > 9) {
                    // Si se sale, marcamos la casilla actual como error visual y paramos
                    const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                    if (tile) tile.classList.add('ghost-invalid');
                    return;
                }
                cells.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
            } else {
                // Unidad normal: 1x1
                cells.push({ r: r, c: c });
            }

            // --- VALIDACI√ìN DE REGLAS ---

            // A. REGLA: FORTALEZA PRIMERO
            // Si no hay fortaleza puesta y no estoy arrastrando una... ERROR
            if (!isFortress && !hasFortress) {
                isValid = false;
            }

            // B. REGLA: TERRITORIOS (ANTI-SONAR)
            if (p1Territory) {
                const rowTerritory = getTerritory(r);
                // Si soy J1 -> Mi zona. Si soy J2 -> La contraria.
                const myZone = (army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');

                if (rowTerritory !== myZone) {
                    isValid = false;
                }
            }

            // C. REGLA: ANILLO DE SALIDA (Solo si ya hay fortaleza y no es la propia fortaleza)
            if (!isFortress && !isMountain && hasFortress) {
                // Si isValid ya es false (por territorio), no importa, pero si es true verificamos el anillo
                if (isValid && !isInExitZone(r, c, fOrigin)) {
                    isValid = false;
                }
            }

            // D. REGLA: ZONA PROHIBIDA DE FORTALEZA (Bordes y Centro)
            if (isFortress) {
                const invalidRows = [0, 4, 5, 9];
                const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1)) isValid = false;
                if (invalidCols.includes(c) || invalidCols.includes(c + 1)) isValid = false;
            }

            // E. REGLA: AGUA Y OCUPACI√ìN
            for (let cell of cells) {
                // Agua (salvo fortaleza)
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) isValid = false;
                // Ocupado
                if (logicBoard[cell.r][cell.c] !== null) isValid = false;
            }

            // 3. PINTAR EL RESULTADO
            const className = isValid ? 'ghost-valid' : 'ghost-invalid';
            cells.forEach(cell => {
                const tile = document.querySelector(`.tile[data-r="${cell.r}"][data-c="${cell.c}"]`);
                if (tile) tile.classList.add(className);
            });
        }
        // 3. Al soltar en una casilla

        function handleDrop(e, r, c) {
            e.preventDefault();
            clearRingHighlights();
            clearGhosts();

            const rawData = e.dataTransfer.getData('text/plain');
            if (!rawData) return;
            const data = JSON.parse(rawData);
            draggingMeta = null;

            // ============================================================
            //  FASE ESPECIAL: RESOLUCI√ìN DE ASEDIO (SACRIFICIO)
            // ============================================================
            if (gameState === 'siege-resolution') {
                if (data.army !== besiegedArmy) return;
                if (data.source !== 'reserve') {
                    showNotification("‚ö†Ô∏è Debes sacar una pieza de la RESERVA para romper el asedio.", true); return;
                }

                const fOrigin = fortressPos[data.army];
                if (!isInExitZone(r, c, fOrigin)) {
                    showNotification("üö´ Solo puedes desplegar junto a tu Fortaleza.", true); return;
                }
                if (logicBoard[r][c] !== null || terrain[r][c] === 'water') {
                    showNotification("üö´ Casilla inv√°lida u ocupada.", true); return;
                }

                // Regla de supervivencia del Rey
                const myReserve = reserves[data.army];
                const kingInReserve = myReserve['rey'] > 0;
                if (kingInReserve && data.type !== 'rey') {
                    showNotification("üëë ¬°El Rey est√° en peligro! Debes salvar al REY obligatoriamente.", true);
                    return;
                }

                // A. Salvar la pieza elegida
                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    logicBoard[r][c] = { army: data.army, type: data.type };
                }

                // B. Captura masiva del resto
                const attackerArmy = (besiegedArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[data.army])) {
                    if (count > 0) {
                        for (let i = 0; i < count; i++) {
                            dungeons[attackerArmy].push({ type: type, army: besiegedArmy });
                            capturedCount++;
                        }
                        reserves[data.army][type] = 0;
                    }
                }

                showNotification(`üî• Asedio roto. ${capturedCount} unidades capturadas.`);
                gameState = 'playing';
                besiegedArmy = null;
                turnColor = attackerArmy;

                renderBoard();
                updateInventories();
                updateDungeons();
                return;
            }

            // ============================================================
            //  FASE 1: MODO JUEGO (NORMAL Y BONUS)
            // ============================================================
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus') {

                // --- A. REFUERZOS ---
                if (data.source === 'reserve') {
                    const fOrigin = fortressPos[data.army];
                    if (!isInExitZone(r, c, fOrigin)) {
                        showNotification("‚õî Los refuerzos solo pueden entrar junto a tu Fortaleza."); return;
                    }
                    if (terrain[r][c] === 'water') { showNotification("‚õî No puedes desplegar en el agua."); return; }
                    if (logicBoard[r][c] !== null) { showNotification("‚õî La zona de despliegue est√° ocupada."); return; }

                    if (reserves[data.army][data.type] > 0) {
                        reserves[data.army][data.type]--;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        showNotification(`üÜï Refuerzos: ${data.type.toUpperCase()} entra en batalla.`);
                    } else {
                        return;
                    }
                }

                // --- B. MOVIMIENTO Y COMBATE (TABLERO A TABLERO) ---
                else if (data.source === 'board') {
                    // Limpiamos rastros anteriores al iniciar una nueva acci√≥n
                    shotHighlights = [];

                    const target = logicBoard[r][c];

                    // 1. Validaciones de terreno globales
                    if (terrain[r][c] === 'water' && data.type !== 'trabuquete' && data.type !== 'escorpion') {
                        // Nota: Armas pueden disparar SOBRE agua, pero validamos destino despu√©s
                        showNotification("‚õî No puedes moverte al agua."); return;
                    }
                    // Validamos agua para movimiento (destino vac√≠o) de armas
                    if (target === null && terrain[r][c] === 'water') { showNotification("‚õî No puedes moverte al agua."); return; }

                    if (target && target.type === 'montana') { showNotification("‚õî No puedes atravesar monta√±as."); return; }
                    if (target && target.type === 'fortaleza') { showNotification("‚õî No puedes ocupar una fortaleza."); return; }

                    // 2. Validaci√≥n Geom√©trica
                    if (!isValidMove(data.type, data.originR, data.originC, r, c)) {
                        showNotification("‚õî Movimiento o Disparo ilegal"); return;
                    }

                    let wasCapture = false;

                    if (target) {
                        // --- INTERACCI√ìN CON OTRAS PIEZAS ---
                        if (target.army === data.army) {
                            // Aliado -> Solo Lanceros
                            if (data.type === 'lanceros') {
                                logicBoard[data.originR][data.originC] = target;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("üîÑ ¬°Maniobra de Lancero!");
                            } else {
                                showNotification("‚õî Casilla ocupada por aliado."); return;
                            }
                        } else {
                            // --- ENEMIGO (CAPTURA / DISPARO) ---
                            wasCapture = true;

                            // A. L√ìGICA DE DISPARO (Trabuquete y Escorpi√≥n)
                            // Si son estas armas y atacan, NO SE MUEVEN.
                            if (data.type === 'trabuquete' || data.type === 'escorpion') {

                                // 1. Registrar coordenadas para el efecto visual (Origen + Destino)
                                shotHighlights.push({ r: data.originR, c: data.originC }); // Arma
                                shotHighlights.push({ r: r, c: c }); // V√≠ctima

                                // 2. Caso Especial ESCORPI√ìN (Doble Kill)
                                if (data.type === 'escorpion') {
                                    // Recorremos el camino para ver si perforamos a alguien
                                    const sR = Math.sign(r - data.originR);
                                    const sC = Math.sign(c - data.originC);
                                    let cR = data.originR + sR, cC = data.originC + sC;

                                    while (cR !== r || cC !== c) {
                                        const obs = logicBoard[cR][cC];
                                        if (obs && obs.army !== data.army) {
                                            // ¬°Enemigo intermedio perforado!
                                            dungeons[data.army].push({ type: obs.type, army: obs.army });
                                            logicBoard[cR][cC] = null; // Eliminar del tablero
                                            shotHighlights.push({ r: cR, c: cC }); // Resaltar tambi√©n a este
                                        }
                                        cR += sR; cC += sC;
                                    }
                                }

                                // 3. Capturar Objetivo Principal
                                if (target.type === 'rey') {
                                    gameState = 'game-over';
                                    // Visualmente eliminamos al rey pero dejamos el arma en su sitio
                                    logicBoard[r][c] = null;
                                    renderBoard();

                                    const winner = data.army === 'rojo' ? 'ROJO' : 'NEGRO';
                                    const bar = document.getElementById('status-bar');
                                    bar.innerText = `üëë ¬°JAQUE MATE! EL TRABUQUETE/ESCORPI√ìN HA ELIMINADO AL REY. VICTORIA ${winner}`;
                                    bar.style.color = '#2ecc71';
                                    return;
                                }

                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[r][c] = null; // La casilla destino queda vac√≠a (muerto)
                                // NO movemos el arma (logicBoard[origin] no se toca)

                                showNotification("üî• ¬°DISPARO DE ASEDIO! Objetivo eliminado.");

                            } else {
                                // --- CAPTURA CUERPO A CUERPO (Est√°ndar) ---
                                // Jaque Mate normal
                                if (target.type === 'rey') {
                                    gameState = 'game-over';
                                    logicBoard[data.originR][data.originC] = null;
                                    logicBoard[r][c] = { army: data.army, type: data.type };
                                    renderBoard();
                                    const winner = data.army === 'rojo' ? 'ROJO' : 'NEGRO';
                                    const bar = document.getElementById('status-bar');
                                    bar.innerText = `üëë ¬°JAQUE MATE! VICTORIA DEL EJ√âRCITO ${winner}`;
                                    bar.style.color = '#2ecc71';
                                    return;
                                }

                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[data.originR][data.originC] = null;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("‚öîÔ∏è ¬°CAPTURA! Prisionero a la mazmorra.");
                            }
                        }
                    } else {
                        // --- MOVIMIENTO A CASILLA VAC√çA ---
                        logicBoard[data.originR][data.originC] = null;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        wasCapture = false;
                    }

                    // --- C. BONUS CHUSMA (Sigue igual) ---
                    if (gameState === 'playing' && data.type === 'chusma' && !wasCapture) {
                        gameState = 'playing-chusma-bonus';
                        chusmaMovedCoords = { r: r, c: c };
                        showNotification("‚ö° ¬°Marcha ligera! Mueve otra Chusma o haz click en esta para terminar.");
                        renderBoard(); updateInventories(); updateDungeons();
                        return;
                    }
                }

                // Cambio de turno est√°ndar
                turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
                gameState = 'playing';
                chusmaMovedCoords = null;
                showNotification(`Turno de ${turnColor.toUpperCase()}`);
                renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // ============================================================
            //  FASE 2: MODO DESPLIEGUE (SETUP)
            // ============================================================
            // ... (Tu c√≥digo de despliegue original sigue aqu√≠, no hace falta tocarlo si ya funciona)
            // Simplemente copia y pega tu bloque original de despliegue aqu√≠ debajo si lo borraste.
            // Para ahorrar espacio, asumo que mantienes el bloque 'else if (gameState.includes("deploy"))' o similar
            // Si en tu c√≥digo estaba todo junto en handleDrop, aseg√∫rate de mantener la parte de abajo.

            // Como tu handleDrop original ten√≠a la parte de despliegue al final sin 'else', 
            // aseg√∫rate de que este bloque de abajo est√© presente:

            const isFortress = (data.type === 'fortaleza');
            const isMountain = (data.type === 'montana');
            const fOrigin = fortressPos[data.army];
            const hasFortress = fOrigin !== null;

            // ... (Resto de tu l√≥gica de despliegue tal cual la ten√≠as en Cotadrez3.2.html l√≠neas 733 en adelante) ...

            // IMPORTANTE: Dado que he cortado aqu√≠ para no hacer el mensaje eterno, 
            // ASEG√öRATE de copiar la parte de DESPLIEGUE que ten√≠as en tu archivo original 
            // justo despu√©s del bloque 'if (gameState === 'playing' ... ) { ... }' que acabamos de cerrar.
            // O usa la versi√≥n completa que te paso a continuaci√≥n para evitar l√≠os.

            // -- BLOQUE DE DESPLIEGUE RESUMIDO PARA QUE COPIES Y PEGUES TODO SI QUIERES --
            // Validaciones
            if (!isFortress && !hasFortress) { showNotification("üö´ Primero debes construir la FORTALEZA", true); return; }

            if (p1Territory) {
                const currentZone = getTerritory(r);
                const myZone = (data.army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                if (currentZone !== myZone) { showNotification("üö´ Zona Prohibida.", true); return; }
            }

            if (!isFortress && !isMountain && hasFortress) {
                if (!isInExitZone(r, c, fOrigin)) { showNotification("üõ°Ô∏è Despliega junto a la Fortaleza", true); return; }
            }

            let cellsToCheck = [];
            if (isFortress) {
                if (r + 1 > 9 || c + 1 > 9) { showNotification("¬°No cabe aqu√≠!", true); return; }
                cellsToCheck.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                const invalidRows = [0, 4, 5, 9]; const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1) || invalidCols.includes(c) || invalidCols.includes(c + 1)) {
                    showNotification("üè∞ Posici√≥n inv√°lida", true); return;
                }
            } else {
                cellsToCheck.push({ r: r, c: c });
            }

            for (let cell of cellsToCheck) {
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) { showNotification("üåä ¬°Al agua no!", true); return; }
                if (logicBoard[cell.r][cell.c] !== null) { showNotification("‚õî Casilla ocupada", true); return; }
            }

            if (data.source === 'reserve') {
                if (gameState === 'init') {
                    if (!isFortress) { showNotification("‚ö†Ô∏è Primero la FORTALEZA.", true); return; }
                    p1Color = data.army;
                    p2Color = (p1Color === 'rojo') ? 'negro' : 'rojo';
                    p1Territory = getTerritory(r);
                    gameState = 'deploy-p1';
                }
                if (gameState === 'deploy-p1' && data.army !== p1Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 1", true); return; }
                if (gameState === 'deploy-p2' && data.army !== p2Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 2", true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });

                    if (isFortress) {
                        fortressPos[data.army] = { r: r, c: c };
                        if (gameState === 'deploy-p1') showNotification(`J1: ${p1Color.toUpperCase()} controla el ${p1Territory.toUpperCase()}.`);
                        else showNotification("üè∞ Fortaleza establecida.");
                    } else {
                        showNotification(`Desplegado: ${data.type.toUpperCase()}`);
                    }
                }
            } else if (data.source === 'board') {
                logicBoard[data.originR][data.originC] = null;
                cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });
                if (isFortress) fortressPos[data.army] = { r: r, c: c };
                showNotification("Unidad reubicada");
            }

            renderBoard();
            updateInventories();
        }


        function updateDungeons() {
            ['rojo', 'negro'].forEach(jailerArmy => {
                const container = document.getElementById(`grave-${jailerArmy}`);
                if (!container) return;
                container.innerHTML = '';

                // Conjunto para recordar qu√© tipos de piezas ya hemos pintado en esta vuelta
                const drawnTypes = new Set();

                dungeons[jailerArmy].forEach((captive, index) => {
                    // Si ya hemos dibujado una pieza de este tipo, la saltamos (agrupaci√≥n visual)
                    if (drawnTypes.has(captive.type)) return;

                    // Si es nueva, la registramos y la dibujamos
                    drawnTypes.add(captive.type);

                    const img = document.createElement('img');
                    img.src = getImgUrl(captive.army, captive.type);
                    img.title = `Prisionero: ${captive.type.toUpperCase()}`;

                    // L√ìGICA DE RESCATE (Solo aplicable a la pieza visible)
                    if (gameState === 'playing' && captive.army === turnColor && jailerArmy !== turnColor) {
                        img.classList.add('rescue-target');
                        // Al hacer click, rescatamos ESTA instancia concreta (index)
                        img.onclick = () => attemptRescue(jailerArmy, index, captive);
                        img.title = "CLICK PARA RESCATAR (Requiere tropas en la fortaleza enemiga)";
                    }

                    container.appendChild(img);
                });
            });
        }

        function finishTurnP1() {
            // Acci√≥n directa, sin preguntas
            gameState = 'deploy-p2';

            // Feedback visual en la barra de notificaciones
            showNotification(`‚úÖ Despliegue J1 Finalizado. Turno del JUGADOR 2 (${p2Color.toUpperCase()}).`);

            // Repintar (se aplicar√° la niebla autom√°ticamente)
            renderBoard();
            updateInventories();
        }


        function finishTurnP2() {
            // Acci√≥n directa
            gameState = 'playing';
            turnColor = p1Color;

            // Feedback visual
            showNotification(`¬°COMIENZA LA PARTIDA! Turno de ${turnColor.toUpperCase()}`);

            // Repintar (se quita la niebla)
            renderBoard();
            updateInventories();
        }

        function attemptRescue(jailerArmy, captiveIndex, captive) {
            // 1. Identificar al enemigo y su fortaleza
            const myArmy = turnColor;
            const enemyFortPos = fortressPos[jailerArmy]; // La fortaleza del carcelero

            if (!enemyFortPos) return; // Seguridad

            // 2. Buscar "El Equipo de Rescate"
            // (Mis piezas que est√°n en el anillo de salida de la fortaleza enemiga)
            let rescueTeam = [];

            // Recorremos el tablero buscando mis piezas en zona hostil
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === myArmy) {
                        if (isInExitZone(r, c, enemyFortPos)) {
                            rescueTeam.push({ r, c, type: piece.type });
                        }
                    }
                }
            }

            // 3. REGLA: ¬øHay equipo de rescate?
            if (rescueTeam.length < 2) {
                showNotification("‚õî Necesitas m√°s tropas rodeando la Fortaleza Enemiga para rescatar.", true);
                return;
            }

            // 4. EJECUTAR EL RESCATE (Todo vuelve a la reserva)

            // A. Recuperar al prisionero
            dungeons[jailerArmy].splice(captiveIndex, 1); // Sacar de mazmorra
            reserves[myArmy][captive.type]++; // Volver a reserva

            // B. Retirar al equipo de rescate (El coste de la operaci√≥n)
            rescueTeam.forEach(soldier => {
                logicBoard[soldier.r][soldier.c] = null; // Sacar del tablero
                reserves[myArmy][soldier.type]++; // Volver a reserva
            });

            // 5. FINALIZAR
            const msg = `üöÅ ¬°RESCATE √âPICO! ${captive.type.toUpperCase()} y ${rescueTeam.length} comandos han regresado a casa.`;

            setTimeout(showNotification(msg), 2000);

            gameState = 'siege-resolution';
            besiegedArmy = jailerArmy; // El enemigo pasa a estar asediado

            // 2. Le damos el turno para que tome su decisi√≥n forzosa
            turnColor = besiegedArmy;

            // 3. Feedback
            showNotification(`‚ö†Ô∏è ¬°ASEDIO! ${besiegedArmy.toUpperCase()} debe salvar una pieza. El resto morir√°.`);

            renderBoard();
            updateInventories();
            updateDungeons();
        }

        function getStatusText() {
            if (gameState === 'game-over') return document.getElementById('status-bar').innerText;

            if (gameState === 'siege-resolution') {
                return `üî• ¬°ASEDIO! ${turnColor.toUpperCase()} debe desplegar una pieza (Rey prioritario).`;
            }

            // --- CORRECCI√ìN: Este estado debe ir ANTES del return por defecto ---
            if (gameState === 'playing-chusma-bonus') {
                return `‚ö° BONIFICACI√ìN CHUSMA: Mueve otra unidad de Chusma o finaliza el turno.`;
            }
            // -------------------------------------------------------------------

            if (gameState === 'init') return "Elige tu destino: Arrastra una Fortaleza para empezar.";
            if (gameState === 'deploy-p1') return `Fase Despliegue: JUGADOR 1 (${p1Color.toUpperCase()})`;
            if (gameState === 'deploy-p2') return `Fase Despliegue: JUGADOR 2 (${p2Color.toUpperCase()})`;
            if (gameState === 'playing') return `¬°Batalla en curso! Turno de ${turnColor.toUpperCase()}`;

            return "Cotadrez";
        }
        // Pinta el anillo de salida de la fortaleza del ej√©rcito indicado
        function highlightFortressRing(army) {
            const fPos = fortressPos[army];
            if (!fPos) return;

            // Recorremos todo el tablero (ineficiente pero seguro y r√°pido en 10x10)
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    // Si es zona de salida, est√° vac√≠a y no es agua
                    if (isInExitZone(r, c, fPos)) {
                        if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                            if (tile) tile.classList.add('highlight-ring');
                        }
                    }
                }
            }
        }

        // Limpia el resaltado del anillo
        function clearRingHighlights() {
            document.querySelectorAll('.highlight-ring').forEach(el => {
                el.classList.remove('highlight-ring');
            });
        }

        // Valida SOLO la geometr√≠a del movimiento (Tablero -> Tablero)

        // Valida SOLO la geometr√≠a y el camino del movimiento
        function isValidMove(type, r1, c1, r2, c2) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // --- 1. REY ---
            if (type === 'rey') return (dR <= 1 && dC <= 1) && (dR + dC > 0);

            // --- 2. LANCEROS / CHUSMA ---
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            // --- 3. DRAG√ìN ---
            if (type === 'dragon') {
                if (!((dR === dC) || (r1 === r2 || c1 === c2))) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const obs = logicBoard[cR][cC];
                    if (obs && obs.type !== 'montana') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 4. ARQUEROS ---
            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    if (logicBoard[r2][c2] === null) return false; // Solo salta para matar
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    return (logicBoard[midR][midC] === null && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // --- 5. ELEFANTE ---
            if (type === 'elefante') {
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    if (logicBoard[cR][cC] !== null || terrain[cR][cC] === 'water') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 6. CABALLER√çA LIGERA ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };
                // Ruta A (Corto+Giro)
                const shorts = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [sr, sc] of shorts) {
                    const cr = r1 + sr, cc = c1 + sc;
                    if (Math.abs(r2 - cr) === 2 && Math.abs(c2 - cc) === 2) {
                        if (!isBlocked(cr, cc) && !isBlocked((cr + r2) / 2, (cc + c2) / 2)) return true;
                    }
                }
                // Ruta B (Largo+Giro)
                const longs = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [lr, lc] of longs) {
                    const cr = r1 + lr, cc = c1 + lc;
                    if (Math.abs(r2 - cr) === 1 && Math.abs(c2 - cc) === 1) {
                        if (!isBlocked((r1 + cr) / 2, (c1 + cc) / 2) && !isBlocked(cr, cc)) return true;
                    }
                }
                return false;
            }

            // --- 7. CABALLER√çA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const myArmy = logicBoard[r1][c1] ? logicBoard[r1][c1].army : null;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== myArmy) return true;
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- 8. TRABUQUETE ---
            if (type === 'trabuquete') {
                // A. MOVIMIENTO (Destino vac√≠o): Solo Diagonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR === 1 && dC === 1);
                }
                // B. DISPARO (Destino ocupado): Solo Ortogonal
                if (r1 !== r2 && c1 !== c2) return false;

                // Raycast: Ignora unidades, bloquea monta√±a/fortaleza
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 9. ESCORPI√ìN ---
            if (type === 'escorpion') {
                // A. MOVIMIENTO (Destino vac√≠o): Solo Ortogonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR + dC === 1);
                }
                // B. DISPARO (Destino ocupado): Solo Diagonal
                if (dR !== dC) return false;

                // Raycast complejo (Perforaci√≥n)
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Bloqueos absolutos
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;

                    // Conteo de enemigos en la trayectoria
                    if (o && o.army !== logicBoard[r1][c1].army) {
                        enemiesInPath++;
                        lastEnemyPos = { r: cR, c: cC };
                    }
                    // No podemos atravesar aliados
                    if (o && o.army === logicBoard[r1][c1].army) return false;

                    cR += sR; cC += sC;
                }

                // L√≥gica de Perforaci√≥n
                if (enemiesInPath === 0) return true; // Disparo directo limpio
                if (enemiesInPath === 1) {
                    // Hay uno en medio, ver si cumple condici√≥n de "distancia 1 o 2"
                    // Distancia se mide en huecos vac√≠os entre unidades.
                    // Si est√°n pegados (gap 0), distanciaManhattan es 2.
                    // Si gap es 1, dist es 3. Si gap es 2, dist es 4.
                    const dist = Math.abs(r2 - lastEnemyPos.r); // Diferencia de filas entre objetivo e intermedio
                    // dist = 1 (pegados), dist = 2 (1 hueco), dist = 3 (2 huecos)
                    if (dist >= 1 && dist <= 3) return true; // Aceptamos 0, 1 y 2 huecos de separaci√≥n
                }

                return false; // M√°s de 1 enemigo o distancia incorrecta
            }

            return true;
        }

        function finishChusmaBonusTurn() {
            // Cambiar turno y volver a la normalidad
            turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
            gameState = 'playing';
            chusmaMovedCoords = null;

            showNotification(`Turno de ${turnColor.toUpperCase()}`);
            renderBoard();
            updateInventories();
        }

    </script>
</body>

</html>
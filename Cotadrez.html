<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Cotadrez</title>
    <link rel="icon" type="image/svg+xml"
        href="https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main/Negro/Castillo.svg">
    <style>
        :root {
            --c-red: #e74c3c;
            --c-black: #7f8c8d;
            /* Un gris m√°s claro para el borde negro para que se vea sobre el fondo oscuro */
            --c-board-l: #f0d9b5;
            --c-board-d: #b58863;
            --c-water: #3498db;
            --c-bg: #1a252f;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--c-bg);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- CABECERA --- */
        header {
            text-align: center;
            margin-bottom: 15px;
        }

        .game-title {
            font-size: 3em;
            margin: 10;
            letter-spacing: 5px;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            font-weight: 800;
        }

        .status-bar {
            font-size: 1.2em;
            color: var(--c-gold);
            margin-top: 2px;
            font-weight: 500;
            min-height: 1.5em;
            /* Para que no salte si est√° vac√≠o */
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
            height: 80vh;
            /* Ajuste para centrar verticalmente */
        }

        /* --- PANELES LATERALES (Inventario + Mazmorra) --- */
        .panel {
            width: 240px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Para que la mazmorra no se salga de los bordes redondeados */
        }

        /* Secci√≥n Superior: Reserva (Inventario) */
        .inventory-section {
            flex: 1;
            /* Ocupa el espacio restante */
            padding: 5px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }


        /* Resaltado del Anillo de Fortaleza */
        .highlight-ring {
            box-shadow: inset 0 0 0 3px #2ecc71 !important;
            /* Borde verde interior */
            /* background-color: rgba(46, 204, 113, 0.15) !important; */
            /* Fondo sutil */
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }

            50% {
                box-shadow: inset 0 0 0 1px #2ecc71;
            }

            100% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }
        }

        /* Secci√≥n Inferior: Mazmorra */
        .dungeon-section {
            height: 180px;
            /* Tama√±o fijo para la mazmorra */
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
            /* Efecto de profundidad */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dungeon-label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dungeon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            overflow-y: auto;
        }

        /* Estilo para las piezas dentro de la mazmorra */
        .dungeon-list img {
            width: 40px;
            height: 40px;
            margin: 2px;
            filter: grayscale(10%) opacity(0.7);
            /* Efecto "prisionero" */
            transition: all 0.3s ease;
        }

        .dungeon-list img:hover {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.2);
            cursor: help;
        }

        /* Fichas rescatables: Borde brillante o cursor de mano */
        .rescue-target {
            cursor: pointer !important;
            /* box-shadow: 0 0 5px 2px var(--c-gold); */
            /* Brillo dorado de esperanza */
            filter: grayscale(0%) opacity(1) !important;
            /* Se ven vivas */
        }

        /* Items del Inventario (Sin recuadro, icono grande) */
        .inv-item {
            width: 70px;
            height: 70px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            /* Indicamos que se puede agarrar */
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            /* La imagen ocupa todo el hueco */
            filter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.5));
            /* Sombra para que destaque sobre el fondo */
            transition: transform 0.1s;
        }

        .inv-item:active img {
            transform: scale(0.9);
            /* Peque√±o efecto al hacer clic */
        }

        /* El contador de unidades (Badge) */
        .inv-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--c-gold);
            /* Color dorado para destacar */
            color: #1a252f;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        /* --- TABLERO --- */
        #board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 15px solid #34495e;
            border-radius: 4px;
            background-color: #2c3e50;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        /* --- CASILLAS --- */
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            /* <--- Nivel base de apilamiento */
            overflow: visible;
            /* <--- Permite que las piezas sobresalgan sin cortarse */
        }

        .light {
            background-color: var(--c-board-l);
        }

        .dark {
            background-color: var(--c-board-d);
        }

        .water {
            background-color: var(--c-water) !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            /* Agua con m√°s profundidad */
        }

        /* PIEZAS CUANDO EST√ÅN EN EL TABLERO */
        .piece {
            width: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            height: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            z-index: 100;
            /* <--- IMPORTANTE: Muy alto para estar siempre encima de las casillas */
            position: relative;
            /* Necesario para que el z-index funcione bien */
            cursor: grab;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.6));
            /* Sombra m√°s pronunciada para dar altura */
            pointer-events: auto;
            /* Asegura que reciba los eventos del rat√≥n */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* GHOSTING (Feedback Visual) */
        .ghost-valid {
            background-color: rgba(46, 204, 113, 0.6) !important;
            /* Verde */
            box-shadow: inset 0 0 0 2px #27ae60;
        }

        .ghost-invalid {
            background-color: rgba(231, 76, 60, 0.6) !important;
            /* Rojo */
            box-shadow: inset 0 0 0 2px #c0392b;
        }
    </style>
</head>

<body>

    <header>
        <h1 class="game-title">COTADREZ</h1>
        <div id="status-bar" class="status-bar">Elige tu ej√©rcito y sit√∫a en el tablero tu fortaleza</div>
    </header>

    <div class="main-container">
        <div class="panel" id="panel-rojo" style="border-color: var(--c-red);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-rojo"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-rojo"></div>
            </div>
        </div>

        <div id="board"></div>

        <div class="panel" id="panel-negro" style="border-color: var(--c-black);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-negro"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-negro"></div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN Y ESTADO ---
        const CONFIG = {
            repo: "https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main",
            // Definici√≥n de cantidades y nombres de archivo
            pieces: {
                'fortaleza': { qty: 1, file: 'Castillo.svg' },
                'montana': { qty: 3, file: 'Montana.svg' },
                'rey': { qty: 1, file: 'Rey.svg' },
                'chusma': { qty: 3, file: 'Chusma.svg' },
                'lanceros': { qty: 3, file: 'Lanza.svg' },
                'arqueros': { qty: 3, file: 'Arco.svg' },
                'c_ligera': { qty: 3, file: 'CaballeriaL.svg' },
                'c_pesada': { qty: 2, file: 'CaballeriaP.svg' },
                'elefante': { qty: 2, file: 'Elefante.svg' },
                'escorpion': { qty: 1, file: 'Escorpion.svg' },
                'trabuquete': { qty: 1, file: 'Catapulta.svg' },
                'dragon': { qty: 1, file: 'Dragon.svg' }
            }
        };

        let reserves = { rojo: {}, negro: {} };
        // Matriz para las PIEZAS (Tropas) - Nombre nuevo para evitar errores
        let logicBoard = Array(10).fill().map(() => Array(10).fill(null));

        // Matriz para el TERRENO (Agua) - Esta ya la ten√≠as, d√©jala igual
        let terrain = Array(10).fill().map(() => Array(10).fill(null));

        let draggingMeta = null; // Guardar√° qu√© estamos moviendo

        let fortressPos = { rojo: null, negro: null };

        let besiegedArmy = null; // Guardar√° 'rojo' o 'negro' durante la resoluci√≥n del asedio

        // Almacena los prisioneros capturados POR cada jugador
        let dungeons = { rojo: [], negro: [] };

        // Estado del juego: 'init', 'deploy-p1', 'deploy-p2', 'playing'
        let gameState = 'init';
        let p1Color = null;
        let p2Color = null;
        let p1Territory = null; // 'north' (filas 0-4) o 'south' (filas 5-9)
        let turnColor = null; // 'rojo' o 'negro'

        // Funci√≥n auxiliar para mostrar mensajes temporales
        function showNotification(msg, isError = false) {
            const bar = document.getElementById('status-bar');
            bar.innerText = msg;
            bar.style.color = isError ? '#e74c3c' : '#f1c40f'; // Rojo si es error, Dorado si es info

            // Efecto visual: parpadeo r√°pido
            bar.style.opacity = 0;
            setTimeout(() => bar.style.opacity = 1, 100);

            // Volver al mensaje por defecto tras 3 segundos
            if (isError) {
                setTimeout(() => {
                    bar.innerText = getStatusText();
                    bar.style.color = '#f1c40f';
                }, 3000);
            }
        }


        // --- 2. INICIALIZACI√ìN ---
        function init() {
            console.log("Inicializando sistema...");

            // 1. Llenar las reservas con las cantidades iniciales
            for (const [type, data] of Object.entries(CONFIG.pieces)) {
                reserves.rojo[type] = data.qty;
                reserves.negro[type] = data.qty;
            }

            // 2. Inicializar gr√°ficos
            initWater();
            renderBoard();
            updateInventories();
            updateDungeons();
            document.getElementById('status-bar').innerText = getStatusText();
        }
        function initWater() {
            const waterCoords = [[3, 1], [1, 3]]; // b4, d2
            waterCoords.forEach(([r, c]) => {
                terrain[r][c] = 'water'; terrain[r][9 - c] = 'water';
                terrain[9 - r][c] = 'water'; terrain[9 - r][9 - c] = 'water';
            });
        }

        // --- 3. RENDERIZADO B√ÅSICO ---

        function renderBoard() {
            const b = document.getElementById('board');
            b.innerHTML = '';

            // --- COLOR DEL BORDE SEG√öN TURNO ---
            let borderColor = '#34495e'; // Color neutro por defecto (Azul gris√°ceo oscuro)

            // Definimos el color oscuro manual para que destaque sobre el neutro
            const darkBorder = '#111111'; // <--- CORRECCI√ìN: Gris casi negro

            if (gameState === 'deploy-p1') {
                borderColor = (p1Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'deploy-p2') {
                borderColor = (p2Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'playing' || gameState === 'siege-resolution') {
                borderColor = (turnColor === 'rojo') ? 'var(--c-red)' : darkBorder;
            }

            b.style.borderColor = borderColor;
            // ------------------------------------------

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    tile.ondragover = (e) => handleDragOver(e, r, c);
                    tile.ondrop = (e) => handleDrop(e, r, c);

                    if (terrain[r][c] === 'water') {
                        tile.classList.add('water');
                    }

                    // Pintar pieza
                    const piece = logicBoard[r][c];
                    let isVisible = true;

                    // Niebla de Guerra
                    if (piece && gameState === 'deploy-p2' && piece.army === p1Color) {
                        isVisible = false;
                    }

                    if (piece && isVisible) {
                        const img = document.createElement('img');
                        img.src = getImgUrl(piece.army, piece.type);
                        img.className = 'piece';

                        // 1. GESTI√ìN DE ARRASTRE (Primero definimos si se mueve)
                        let canDrag = true;
                        if (piece.type === 'fortaleza') canDrag = false;
                        if (gameState === 'playing' && piece.type === 'montana') canDrag = false;
                        if (gameState.includes('deploy')) {
                            const myColor = (gameState === 'deploy-p1') ? p1Color : p2Color;
                            if (piece.army !== myColor) canDrag = false;
                        }

                        img.draggable = canDrag;

                        // Si se puede arrastrar, asignamos el evento
                        if (canDrag) {
                            img.ondragstart = (e) => handleDragStart(e, 'board', piece.army, piece.type, r, c);
                            img.style.cursor = "grab"; // Cursor de mano abierta
                        } else {
                            img.style.cursor = "default"; // Cursor normal por defecto
                        }

                        // 2. GESTI√ìN DE CLICS (Prioridad sobre el arrastre)
                        // Si es una fortaleza y es el turno correcto, la hacemos pulsable
                        if (piece.type === 'fortaleza') {
                            if (gameState === 'deploy-p1' && piece.army === p1Color) {
                                img.style.cursor = "pointer"; // FORZAMOS cursor de dedo
                                img.onclick = () => finishTurnP1();
                            }
                            else if (gameState === 'deploy-p2' && piece.army === p2Color) {
                                img.style.cursor = "pointer"; // FORZAMOS cursor de dedo
                                img.onclick = () => finishTurnP2();
                            }
                        }

                        tile.appendChild(img);
                    }
                    b.appendChild(tile);
                }
            }
        }

        // Devuelve 'north' (filas 0-4) o 'south' (filas 5-9)
        function getTerritory(r) {
            return r < 5 ? 'north' : 'south';
        }



        // Verifica si una casilla est√° en el "Anillo de Salida" (per√≠metro adyacente)

        function isInExitZone(r, c, fOrigin) {
            if (!fOrigin) return false;

            // La fortaleza ocupa (fr, fc) hasta (fr+1, fc+1)
            // El anillo va desde (fr-1, fc-1) hasta (fr+2, fc+2)
            const minR = fOrigin.r - 1;
            const maxR = fOrigin.r + 2;
            const minC = fOrigin.c - 1;
            const maxC = fOrigin.c + 2;

            // 1. Debe estar dentro del rect√°ngulo exterior
            if (r >= minR && r <= maxR && c >= minC && c <= maxC) {
                // 2. Pero NO debe ser la propia fortaleza (el hueco central)
                if (r >= fOrigin.r && r <= fOrigin.r + 1 && c >= fOrigin.c && c <= fOrigin.c + 1) {
                    return false; // Es la propia estructura
                }
                return true; // Es el anillo
            }
            return false;
        }

        // Arrancar
        init();

        // Construye la URL de la imagen seg√∫n el bando y el tipo
        function getImgUrl(army, type) {
            const folder = army === 'rojo' ? 'Rojo' : 'Negro';
            const filename = CONFIG.pieces[type].file;
            return `${CONFIG.repo}/${folder}/${filename}`;
        }

        // Dibuja las piezas en los paneles laterales
        function updateInventories() {
            ['rojo', 'negro'].forEach(army => {
                const list = document.getElementById(`inv-${army}`);
                list.innerHTML = '';

                for (const [type, data] of Object.entries(CONFIG.pieces)) {
                    const count = reserves[army][type];

                    if (count > 0) {
                        const item = document.createElement('div');
                        item.className = 'inv-item';

                        // --- CAMBIO AQU√ç: A√±adimos ondragend ---
                        const img = document.createElement('img');
                        img.src = getImgUrl(army, type);
                        img.draggable = true;

                        img.ondragstart = (e) => handleDragStart(e, 'reserve', army, type);
                        // NUEVO: Limpiar al soltar (aunque sea fuera)
                        img.ondragend = () => clearRingHighlights();
                        // ----------------------------------------

                        item.appendChild(img);

                        if (count > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'inv-badge';
                            badge.innerText = count;
                            item.appendChild(badge);
                        }
                        list.appendChild(item);
                    }
                }
            });
        }

        // --- 4. L√ìGICA DE ARRASTRAR Y SOLTAR ---

function handleDragStart(e, source, army, type, r = null, c = null) {

            if (gameState === 'playing') {
                // Si el juego ha terminado, nadie mueve nada
                if (gameState === 'game-over') { e.preventDefault(); return; }

                if (army !== turnColor) {
                    e.preventDefault(); // Impide arrastrar si no es tu turno
                    return;
                }
            }

            // 1. Guardamos metadatos (A√ëADIDO: coordenadas de origen)
            draggingMeta = {
                type: type,
                army: army,
                source: source,
                originR: r, // <--- NUEVO
                originC: c  // <--- NUEVO
            };

            // 2. Datos est√°ndar para el Drop
            const data = { source, army, type, originR: r, originC: c };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';

            // --- NUEVO: RESALTAR ANILLO SI VIENE DE RESERVA ---
            // (La l√≥gica est√° DENTRO de la funci√≥n, antes de la llave de cierre)
            if (source === 'reserve' && type !== 'montana') {
                highlightFortressRing(army);
            }
        }
        
        // 2. Permitir soltar (El navegador bloquea por defecto, hay que prevenirlo)
        // Funci√≥n auxiliar para limpiar fantasmas previos
        function clearGhosts() {
            document.querySelectorAll('.ghost-valid, .ghost-invalid').forEach(el => {
                el.classList.remove('ghost-valid', 'ghost-invalid');
            });
        }

        // Nueva funci√≥n DragOver con l√≥gica de visualizaci√≥n

        function handleDragOver(e, r, c) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!draggingMeta) return;
            clearGhosts();

            // --- NUEVO: L√ìGICA ESPEC√çFICA PARA FASE DE JUEGO ---
            if (gameState === 'playing') {
                let isValid = true;
                const target = logicBoard[r][c];
                const type = draggingMeta.type;
                const army = draggingMeta.army;
                const source = draggingMeta.source; // <--- Usamos el dato nuevo

                // 1. RESTRICCIONES DE TERRENO GENERALES
                if (terrain[r][c] === 'water') isValid = false;
                if (target && target.type === 'fortaleza') isValid = false;
                if (target && target.type === 'montana') isValid = false;

                // 2. LOGICA DIFERENCIADA: ¬øREFUERZO O MOVIMIENTO?
                if (source === 'reserve') {
                    // --- REFUERZO ---
                    // A. Debe ser en el anillo de mi fortaleza
                    const fOrigin = fortressPos[army];
                    if (!isInExitZone(r, c, fOrigin)) isValid = false;

                    // B. La casilla debe estar VAC√çA (no puedes reforzar encima de nadie)
                    if (target !== null) isValid = false;

                } else {
                    // --- MOVIMIENTO NORMAL (TABLERO -> TABLERO) ---

                    // 1. Validar Geometr√≠a (Usa la nueva funci√≥n)
                    // Usamos las coordenadas guardadas en draggingMeta
                    if (!isValidMove(type, draggingMeta.originR, draggingMeta.originC, r, c)) {
                        isValid = false;
                    }

                    // 2. Validar Ocupaci√≥n (Solo si la geometr√≠a es v√°lida)
                    if (isValid && target) {
                        if (target.army === army) {
                            if (type !== 'lancero') isValid = false;
                        }
                        // Enemigo = Captura (V√°lido)
                    }
                }
                // Pintar
                const className = isValid ? 'ghost-valid' : 'ghost-invalid';
                const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                if (tile) tile.classList.add(className);

                return;
            }

            // FASE DE DESPLIEGUE DE TROPAS
            // 1. DEFINICI√ìN DE VARIABLES
            let isValid = true;
            const army = draggingMeta.army;
            const type = draggingMeta.type;
            const isFortress = (type === 'fortaleza');
            const isMountain = (type === 'montana');

            // Buscar posici√≥n de fortaleza
            const fOrigin = fortressPos[army];
            const hasFortress = fOrigin !== null;

            // 2. DEFINIR LAS CELDAS AFECTADAS (Variable 'cells')
            let cells = [];
            if (isFortress) {
                // Verificar l√≠mites del mapa para 2x2
                if (r + 1 > 9 || c + 1 > 9) {
                    // Si se sale, marcamos la casilla actual como error visual y paramos
                    const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                    if (tile) tile.classList.add('ghost-invalid');
                    return;
                }
                cells.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
            } else {
                // Unidad normal: 1x1
                cells.push({ r: r, c: c });
            }

            // --- VALIDACI√ìN DE REGLAS ---

            // A. REGLA: FORTALEZA PRIMERO
            // Si no hay fortaleza puesta y no estoy arrastrando una... ERROR
            if (!isFortress && !hasFortress) {
                isValid = false;
            }

            // B. REGLA: TERRITORIOS (ANTI-SONAR)
            if (p1Territory) {
                const rowTerritory = getTerritory(r);
                // Si soy J1 -> Mi zona. Si soy J2 -> La contraria.
                const myZone = (army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');

                if (rowTerritory !== myZone) {
                    isValid = false;
                }
            }

            // C. REGLA: ANILLO DE SALIDA (Solo si ya hay fortaleza y no es la propia fortaleza)
            if (!isFortress && !isMountain && hasFortress) {
                // Si isValid ya es false (por territorio), no importa, pero si es true verificamos el anillo
                if (isValid && !isInExitZone(r, c, fOrigin)) {
                    isValid = false;
                }
            }

            // D. REGLA: ZONA PROHIBIDA DE FORTALEZA (Bordes y Centro)
            if (isFortress) {
                const invalidRows = [0, 4, 5, 9];
                const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1)) isValid = false;
                if (invalidCols.includes(c) || invalidCols.includes(c + 1)) isValid = false;
            }

            // E. REGLA: AGUA Y OCUPACI√ìN
            for (let cell of cells) {
                // Agua (salvo fortaleza)
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) isValid = false;
                // Ocupado
                if (logicBoard[cell.r][cell.c] !== null) isValid = false;
            }

            // 3. PINTAR EL RESULTADO
            const className = isValid ? 'ghost-valid' : 'ghost-invalid';
            cells.forEach(cell => {
                const tile = document.querySelector(`.tile[data-r="${cell.r}"][data-c="${cell.c}"]`);
                if (tile) tile.classList.add(className);
            });
        }
        // 3. Al soltar en una casilla

        function handleDrop(e, r, c) {
            e.preventDefault();
            clearRingHighlights();
            clearGhosts();

            const rawData = e.dataTransfer.getData('text/plain');
            if (!rawData) return;
            const data = JSON.parse(rawData);
            draggingMeta = null;

            // ============================================================
            //  FASE ESPECIAL: RESOLUCI√ìN DE ASEDIO (SACRIFICIO)
            // ============================================================
            if (gameState === 'siege-resolution') {
                // 1. Validaciones de Seguridad
                if (data.army !== besiegedArmy) return; // Solo puede mover el asediado
                if (data.source !== 'reserve') {
                    showNotification("‚ö†Ô∏è Debes sacar una pieza de la RESERVA para romper el asedio.", true); return;
                }

                // 2. Validar Zona de Salida (Anillo de Fortaleza)
                const fOrigin = fortressPos[data.army];
                if (!isInExitZone(r, c, fOrigin)) {
                    showNotification("üö´ Solo puedes desplegar junto a tu Fortaleza.", true); return;
                }
                if (logicBoard[r][c] !== null || terrain[r][c] === 'water') {
                    showNotification("üö´ Casilla inv√°lida u ocupada.", true); return;
                }

                // 3. REGLA DE ORO: ¬øQU√â PIEZA PUEDO SALVAR?
                // "El Rey si est√° dentro, u otra si el Rey est√° fuera"
                const myReserve = reserves[data.army];
                const kingInReserve = myReserve['rey'] > 0;

                if (kingInReserve && data.type !== 'rey') {
                    showNotification("üëë ¬°El Rey est√° en peligro! Debes salvar al REY obligatoriamente.", true);
                    return;
                }

                // --- EJECUCI√ìN DEL SACRIFICIO ---

                // A. Salvar la pieza elegida (Al tablero)
                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    logicBoard[r][c] = { army: data.army, type: data.type };
                }

                // B. CAPTURA MASIVA DEL RESTO (A la mazmorra del atacante)
                const attackerArmy = (besiegedArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[data.army])) {
                    if (count > 0) {
                        // Movemos todas las unidades restantes a la mazmorra enemiga
                        for (let i = 0; i < count; i++) {
                            dungeons[attackerArmy].push({ type: type, army: besiegedArmy });
                            capturedCount++;
                        }
                        // Vaciamos la reserva
                        reserves[data.army][type] = 0;
                    }
                }

                // C. FINALIZAR ASEDIO Y VOLVER A LA NORMALIDAD
                showNotification(`üî• Asedio roto. ${capturedCount} unidades han sido capturadas en la huida.`);

                gameState = 'playing';
                besiegedArmy = null;

                // Cambio de turno (ahora le toca al atacante otra vez, o al defensor seg√∫n prefieras)
                // Lo l√≥gico tras un despliegue es cambiar turno:
                turnColor = attackerArmy;

                renderBoard();
                updateInventories();
                updateDungeons();
                return; // Importante: Salir para no ejecutar l√≥gica normal
            }


            // ============================================================
            //  FASE 1: MODO JUEGO (SANDBOX / BATALLA)
            // ============================================================
            if (gameState === 'playing') {

                // --- A. GESTI√ìN DE REFUERZOS (DEL INVENTARIO AL TABLERO) ---
                if (data.source === 'reserve') {
                    const fOrigin = fortressPos[data.army];

                    // 1. Validar que es zona de salida (Anillo)
                    if (!isInExitZone(r, c, fOrigin)) {
                        showNotification("‚õî Los refuerzos solo pueden entrar junto a tu Fortaleza."); return;
                    }

                    // 2. Validar que est√° vac√≠a y no es agua/monta√±a
                    if (terrain[r][c] === 'water') { showNotification("‚õî No puedes desplegar en el agua."); return; }
                    if (logicBoard[r][c] !== null) { showNotification("‚õî La zona de despliegue est√° ocupada."); return; }

                    // 3. Ejecutar Refuerzo
                    if (reserves[data.army][data.type] > 0) {
                        reserves[data.army][data.type]--;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        showNotification(`üÜï Refuerzos: ${data.type.toUpperCase()} entra en batalla.`);
                    } else {
                        return; // No quedan tropas (seguridad)
                    }
                }

                // --- B. GESTI√ìN DE MOVIMIENTO (TABLERO A TABLERO) ---
                else {
                    const target = logicBoard[r][c];

                    // Validaciones de terreno globales
                    if (terrain[r][c] === 'water') { showNotification("‚õî No puedes moverte al agua."); return; }
                    if (target && target.type === 'montana') { showNotification("‚õî No puedes atravesar monta√±as."); return; }
                    if (target && target.type === 'fortaleza') { showNotification("‚õî No puedes ocupar una fortaleza."); return; }

                    // --- NUEVA VALIDACI√ìN CENTRALIZADA ---
                    if (!isValidMove(data.type, data.originR, data.originC, r, c)) {
                        showNotification("‚õî Movimiento ilegal"); // Mensaje gen√©rico
                        return;
                    }
                    if (target) {
                        if (target.army === data.army) {
                            // --- ALIADO (LANCERO) ---
                            if (data.type === 'lancero') {
                                logicBoard[data.originR][data.originC] = target;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("üîÑ ¬°Maniobra de Lancero!");
                            } else {
                                showNotification("‚õî Casilla ocupada por aliado."); return;
                            }
                        } else {
                            // --- ENEMIGO (CAPTURA) ---

                            // *** REGLA DE VICTORIA: CAPTURA DEL REY ***
                            if (target.type === 'rey') {
                                // 1. Detenemos el estado del juego
                                gameState = 'game-over';

                                // 2. Ejecutamos visualmente la captura (el Rey desaparece)
                                logicBoard[data.originR][data.originC] = null;
                                logicBoard[r][c] = { army: data.army, type: data.type };

                                // 3. Actualizamos todo
                                renderBoard(); // Al repintar, el drag se bloquear√° solo porque gameState es 'game-over'
                                updateInventories();
                                updateDungeons();

                                // 4. NOTIFICACI√ìN DE VICTORIA (Sin Alertas)
                                const winner = data.army === 'rojo' ? 'ROJO' : 'NEGRO';
                                const bar = document.getElementById('status-bar');
                                bar.innerText = `üëë ¬°JAQUE MATE! VICTORIA DEL EJ√âRCITO ${winner}`;
                                bar.style.color = '#2ecc71'; // Verde esmeralda para la victoria
                                bar.style.fontWeight = 'bold';

                                return; // Salimos definitivamente
                            }

                            // Captura normal
                            dungeons[data.army].push({ type: target.type, army: target.army });
                            logicBoard[data.originR][data.originC] = null;
                            logicBoard[r][c] = { army: data.army, type: data.type };
                            showNotification("‚öîÔ∏è ¬°CAPTURA! Prisionero a la mazmorra.");
                        }
                    } else {
                        // --- VAC√çO ---
                        logicBoard[data.originR][data.originC] = null;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                    }
                }

                // C. CAMBIO DE TURNO (Com√∫n para refuerzos y movimientos)
                turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
                showNotification(`Turno de ${turnColor.toUpperCase()}`);

                renderBoard();
                updateInventories();
                updateDungeons();
                return;
            }


            // ============================================================
            //  FASE 2: MODO DESPLIEGUE (SETUP) - (C√≥digo sin cambios l√≥gicos)
            // ============================================================

            const isFortress = (data.type === 'fortaleza');
            const isMountain = (data.type === 'montana');
            const fOrigin = fortressPos[data.army];
            const hasFortress = fOrigin !== null;

            // Validaciones
            if (!isFortress && !hasFortress) { showNotification("üö´ Primero debes construir la FORTALEZA", true); return; }

            if (p1Territory) {
                const currentZone = getTerritory(r);
                const myZone = (data.army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                if (currentZone !== myZone) { showNotification("üö´ Zona Prohibida.", true); return; }
            }

            if (!isFortress && !isMountain && hasFortress) {
                if (!isInExitZone(r, c, fOrigin)) { showNotification("üõ°Ô∏è Despliega junto a la Fortaleza", true); return; }
            }

            // Definir celdas
            let cellsToCheck = [];
            if (isFortress) {
                if (r + 1 > 9 || c + 1 > 9) { showNotification("¬°No cabe aqu√≠!", true); return; }
                cellsToCheck.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                const invalidRows = [0, 4, 5, 9]; const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1) || invalidCols.includes(c) || invalidCols.includes(c + 1)) {
                    showNotification("üè∞ Posici√≥n inv√°lida", true); return;
                }
            } else {
                cellsToCheck.push({ r: r, c: c });
            }

            for (let cell of cellsToCheck) {
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) { showNotification("üåä ¬°Al agua no!", true); return; }
                if (logicBoard[cell.r][cell.c] !== null) { showNotification("‚õî Casilla ocupada", true); return; }
            }

            // Ejecuci√≥n
            if (data.source === 'reserve') {
                if (gameState === 'init') {
                    if (!isFortress) { showNotification("‚ö†Ô∏è Primero la FORTALEZA.", true); return; }
                    p1Color = data.army;
                    p2Color = (p1Color === 'rojo') ? 'negro' : 'rojo';
                    p1Territory = getTerritory(r);
                    gameState = 'deploy-p1';
                }
                if (gameState === 'deploy-p1' && data.army !== p1Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 1", true); return; }
                if (gameState === 'deploy-p2' && data.army !== p2Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 2", true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });

                    if (isFortress) {
                        fortressPos[data.army] = { r: r, c: c };
                        if (gameState === 'deploy-p1') showNotification(`J1: ${p1Color.toUpperCase()} controla el ${p1Territory.toUpperCase()}.`);
                        else showNotification("üè∞ Fortaleza establecida.");
                    } else {
                        showNotification(`Desplegado: ${data.type.toUpperCase()}`);
                    }
                }
            } else if (data.source === 'board') {
                // En despliegue, mover fortaleza es "Modo Dios" (asumimos limpieza simple 1x1 para evitar bugs visuales complejos ahora)
                logicBoard[data.originR][data.originC] = null;
                cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });
                if (isFortress) fortressPos[data.army] = { r: r, c: c };
                showNotification("Unidad reubicada");
            }

            renderBoard();
            updateInventories();
            // No llamamos a updateDungeons aqu√≠ porque en despliegue no hay capturas
        }

        function updateDungeons() {
            ['rojo', 'negro'].forEach(jailerArmy => {
                const container = document.getElementById(`grave-${jailerArmy}`);
                if (!container) return;
                container.innerHTML = '';

                // Conjunto para recordar qu√© tipos de piezas ya hemos pintado en esta vuelta
                const drawnTypes = new Set();

                dungeons[jailerArmy].forEach((captive, index) => {
                    // Si ya hemos dibujado una pieza de este tipo, la saltamos (agrupaci√≥n visual)
                    if (drawnTypes.has(captive.type)) return;

                    // Si es nueva, la registramos y la dibujamos
                    drawnTypes.add(captive.type);

                    const img = document.createElement('img');
                    img.src = getImgUrl(captive.army, captive.type);
                    img.title = `Prisionero: ${captive.type.toUpperCase()}`;

                    // L√ìGICA DE RESCATE (Solo aplicable a la pieza visible)
                    if (gameState === 'playing' && captive.army === turnColor && jailerArmy !== turnColor) {
                        img.classList.add('rescue-target');
                        // Al hacer click, rescatamos ESTA instancia concreta (index)
                        img.onclick = () => attemptRescue(jailerArmy, index, captive);
                        img.title = "CLICK PARA RESCATAR (Requiere tropas en la fortaleza enemiga)";
                    }

                    container.appendChild(img);
                });
            });
        }

        function finishTurnP1() {
            // Acci√≥n directa, sin preguntas
            gameState = 'deploy-p2';

            // Feedback visual en la barra de notificaciones
            showNotification(`‚úÖ Despliegue J1 Finalizado. Turno del JUGADOR 2 (${p2Color.toUpperCase()}).`);

            // Repintar (se aplicar√° la niebla autom√°ticamente)
            renderBoard();
            updateInventories();
        }


        function finishTurnP2() {
            // Acci√≥n directa
            gameState = 'playing';
            turnColor = p1Color;

            // Feedback visual
            showNotification(`¬°COMIENZA LA PARTIDA! Turno de ${turnColor.toUpperCase()}`);

            // Repintar (se quita la niebla)
            renderBoard();
            updateInventories();
        }

        function attemptRescue(jailerArmy, captiveIndex, captive) {
            // 1. Identificar al enemigo y su fortaleza
            const myArmy = turnColor;
            const enemyFortPos = fortressPos[jailerArmy]; // La fortaleza del carcelero

            if (!enemyFortPos) return; // Seguridad

            // 2. Buscar "El Equipo de Rescate"
            // (Mis piezas que est√°n en el anillo de salida de la fortaleza enemiga)
            let rescueTeam = [];

            // Recorremos el tablero buscando mis piezas en zona hostil
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === myArmy) {
                        if (isInExitZone(r, c, enemyFortPos)) {
                            rescueTeam.push({ r, c, type: piece.type });
                        }
                    }
                }
            }

            // 3. REGLA: ¬øHay equipo de rescate?
            if (rescueTeam.length < 2) {
                showNotification("‚õî Necesitas m√°s tropas rodeando la Fortaleza Enemiga para rescatar.", true);
                return;
            }

            // 4. EJECUTAR EL RESCATE (Todo vuelve a la reserva)

            // A. Recuperar al prisionero
            dungeons[jailerArmy].splice(captiveIndex, 1); // Sacar de mazmorra
            reserves[myArmy][captive.type]++; // Volver a reserva

            // B. Retirar al equipo de rescate (El coste de la operaci√≥n)
            rescueTeam.forEach(soldier => {
                logicBoard[soldier.r][soldier.c] = null; // Sacar del tablero
                reserves[myArmy][soldier.type]++; // Volver a reserva
            });

            // 5. FINALIZAR
            const msg = `üöÅ ¬°RESCATE √âPICO! ${captive.type.toUpperCase()} y ${rescueTeam.length} comandos han regresado a casa.`;

            setTimeout(showNotification(msg), 2000);

            gameState = 'siege-resolution';
            besiegedArmy = jailerArmy; // El enemigo pasa a estar asediado

            // 2. Le damos el turno para que tome su decisi√≥n forzosa
            turnColor = besiegedArmy;

            // 3. Feedback
            showNotification(`‚ö†Ô∏è ¬°ASEDIO! ${besiegedArmy.toUpperCase()} debe salvar una pieza. El resto morir√°.`);

            renderBoard();
            updateInventories();
            updateDungeons();
        }

        function getStatusText() {
            if (gameState === 'game-over') return document.getElementById('status-bar').innerText;

            // --- NUEVO ESTADO ---
            if (gameState === 'siege-resolution') {
                return `üî• ¬°ASEDIO! ${turnColor.toUpperCase()} debe desplegar una pieza (Rey prioritario).`;
            }
            // --------------------

            if (gameState === 'init') return "Elige tu destino: Arrastra una Fortaleza para empezar.";
            if (gameState === 'deploy-p1') return `Fase Despliegue: JUGADOR 1 (${p1Color.toUpperCase()})`;
            if (gameState === 'deploy-p2') return `Fase Despliegue: JUGADOR 2 (${p2Color.toUpperCase()})`;
            if (gameState === 'playing') return `¬°Batalla en curso! Turno de ${turnColor.toUpperCase()}`;
            return "Cotadrez";
        }

        // Pinta el anillo de salida de la fortaleza del ej√©rcito indicado
        function highlightFortressRing(army) {
            const fPos = fortressPos[army];
            if (!fPos) return;

            // Recorremos todo el tablero (ineficiente pero seguro y r√°pido en 10x10)
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    // Si es zona de salida, est√° vac√≠a y no es agua
                    if (isInExitZone(r, c, fPos)) {
                        if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                            if (tile) tile.classList.add('highlight-ring');
                        }
                    }
                }
            }
        }

        // Limpia el resaltado del anillo
        function clearRingHighlights() {
            document.querySelectorAll('.highlight-ring').forEach(el => {
                el.classList.remove('highlight-ring');
            });
        }

        // Valida SOLO la geometr√≠a del movimiento (Tablero -> Tablero)
        function isValidMove(type, r1, c1, r2, c2) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // --- REGLAS POR TIPO ---

            if (type === 'rey') {
                // Rey: M√°ximo 1 casilla en cualquier direcci√≥n
                return (dR <= 1 && dC <= 1) && (dR + dC > 0);
            }

            // ... Aqu√≠ a√±adiremos else if (type === 'caballo') ...

            // Por defecto (resto de piezas): Movimiento libre (Sandbox)
            return true;
        }

    </script>
</body>

</html>
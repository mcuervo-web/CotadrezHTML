<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Cotadrez</title>
    <link rel="icon" type="image/svg+xml"
        href="https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main/Negro/Castillo.svg">
    <style>
        :root {
            --c-red: #e74c3c;
            --c-black: #7f8c8d;
            /* Un gris mÃ¡s claro para el borde negro para que se vea sobre el fondo oscuro */
            --c-board-l: #f0d9b5;
            --c-board-d: #b58863;
            --c-water: #3498db;
            --c-bg: #1a252f;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--c-bg);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- CABECERA --- */
        header {
            text-align: center;
            margin-bottom: 5px;
        }

        .game-title {
            font-size: 3em;
            margin: 0;
            letter-spacing: 5px;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            font-weight: 800;
        }

        .status-bar {
            font-size: 1.2em;
            color: var(--c-gold);
            margin-top: 10px;
            margin-bottom: 0;
            font-weight: 500;
            min-height: 1.5em;
            /* Para que no salte si estÃ¡ vacÃ­o */
        }

        /* --- ESTADO CRÃTICO (JAQUE / ASEDIO) --- */
        .status-critical {
            color: #ff2e2e !important;
            /* Rojo brillante */
            font-weight: 800 !important;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            /* Resplandor rojo */
            animation: pulse-text 0.8s infinite alternate;
        }

        /* --- FORTALEZA ASEDIADA (PARPADEO) --- */
        .siege-pulse {
            filter: drop-shadow(0 0 10px var(--c-red)) brightness(1.2);
            animation: pulse-fortress 1s infinite alternate;
            cursor: pointer !important;
            /* Mano para indicar que es clickable */
        }

        @keyframes pulse-fortress {
            from {
                filter: drop-shadow(0 0 5px var(--c-red));
                transform: scale(1);
            }

            to {
                filter: drop-shadow(0 0 15px var(--c-red));
                transform: scale(1.1);
            }
        }

        @keyframes pulse-text {
            from {
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                transform: scale(1);
            }

            to {
                text-shadow: 0 0 20px rgba(255, 0, 0, 1);
                transform: scale(1.02);
            }
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
            height: auto;
            margin-top: 5px;
        }

        /* --- PANELES LATERALES (Inventario + Mazmorra) --- */
        .panel {
            width: 240px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Para que la mazmorra no se salga de los bordes redondeados */
        }

        /* SecciÃ³n Superior: Reserva (Inventario) */
        .inventory-section {
            flex: 1;
            /* Ocupa el espacio restante */
            padding: 5px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }


        /* Resaltado del Anillo de Fortaleza */
        .highlight-ring {
            box-shadow: inset 0 0 0 3px #2ecc71 !important;
            /* Borde verde interior */
            /* background-color: rgba(46, 204, 113, 0.15) !important; */
            /* Fondo sutil */
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }

            50% {
                box-shadow: inset 0 0 0 1px #2ecc71;
            }

            100% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }
        }

        /* Feedback de disparo (Arma y VÃ­ctimas) - VERSIÃ“N INTENSA */
        .shot-highlight {
            /* Borde interior muy marcado y fondo teÃ±ido */
            box-shadow: inset 0 0 40px rgb(29, 4, 1) !important;
            /* background-color: rgba(231, 76, 60, 0) !important; */
            animation: pulse-shot 1.5s infinite;
            /* Pulso mÃ¡s rÃ¡pido (latido) */
            z-index: 5 !important;
            /* Asegura que se pinte sobre casillas de agua u otras */
        }

        @keyframes pulse-shot {
            0% {
                box-shadow: inset 0 0 40px rgba(27, 4, 2, 0.6);
                /* background-color: rgba(231, 76, 60, 0); */
            }

            50% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* Brillo mÃ¡ximo */
                /* background-color: rgba(231, 76, 60, 0.1); */
            }

            100% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* box-shadow: inset 0 0 40px rgba(231, 76, 60, 0.6); */
                /* background-color: rgba(231, 76, 60, 0); */
            }
        }

        /* Feedback de disparo - ORIGEN (Dorado) */
        .shot-source {
            box-shadow: inset 0 0 40px rgba(241, 196, 15, 0.8) !important;
            /* Gold intenso */
            animation: pulse-shot-gold 1.5s infinite;
            z-index: 5 !important;
        }

        @keyframes pulse-shot-gold {
            0% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }

            50% {
                box-shadow: inset 0 0 50px rgba(241, 196, 15, 1);
            }

            100% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }
        }

        /* SecciÃ³n Inferior: Mazmorra */
        .dungeon-section {
            height: 180px;
            /* TamaÃ±o fijo para la mazmorra */
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
            /* Efecto de profundidad */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dungeon-label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dungeon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            overflow-y: auto;
        }

        /* Estilo para las piezas dentro de la mazmorra */
        .dungeon-list img {
            width: 40px;
            height: 40px;
            margin: 2px;
            filter: grayscale(10%) opacity(0.7);
            /* Efecto "prisionero" */
            transition: all 0.3s ease;
        }

        .dungeon-list img:hover {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.2);
            cursor: help;
        }

        /* Fichas rescatables: Borde brillante o cursor de mano */
        .rescue-target {
            cursor: pointer !important;
            /* box-shadow: 0 0 5px 2px var(--c-gold); */
            /* Brillo dorado de esperanza */
            filter: grayscale(0%) opacity(1) !important;
            /* Se ven vivas */
        }

        /* Items del Inventario (Sin recuadro, icono grande) */
        .inv-item {
            width: 70px;
            height: 70px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            /* Indicamos que se puede agarrar */
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            /* La imagen ocupa todo el hueco */
            filter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.5));
            /* Sombra para que destaque sobre el fondo */
            transition: transform 0.1s;
        }

        .inv-item:active img {
            transform: scale(0.9);
            /* PequeÃ±o efecto al hacer clic */
        }

        /* El contador de unidades (Badge) */
        .inv-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--c-gold);
            /* Color dorado para destacar */
            color: #1a252f;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        /* --- TABLERO (AÃ±adimos position: relative) --- */
        #board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 15px solid #34495e;
            border-radius: 4px;
            background-color: #2c3e50;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            position: relative;
            /* <--- IMPORTANTE: Para posicionar el Easter Egg */
        }

        /* --- EASTER EGG (BotÃ³n Invisible) --- */
        .debug-egg {
            position: absolute;
            bottom: -15px;
            /* Se sale del contenido para cubrir el borde */
            right: -15px;
            /* Se sale del contenido para cubrir el borde */
            width: 40px;
            /* TamaÃ±o suficiente para acertar con el ratÃ³n */
            height: 40px;
            z-index: 1000;
            /* Por encima de todo */
            cursor: default;
            /* Cursor normal para no levantar sospechas */
            /* background-color: rgba(255,0,0,0.5); <--- Descomenta para ver dÃ³nde estÃ¡ mientras pruebas */
        }

        /* --- CASILLAS --- */
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            /* <--- Nivel base de apilamiento */
            overflow: visible;
            /* <--- Permite que las piezas sobresalgan sin cortarse */
        }

        .light {
            background-color: var(--c-board-l);
        }

        .dark {
            background-color: var(--c-board-d);
        }

        .water {
            background-color: var(--c-water) !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            /* Agua con mÃ¡s profundidad */
        }

        /* PIEZAS CUANDO ESTÃN EN EL TABLERO */
        .piece {
            width: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            height: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            z-index: 100;
            /* <--- IMPORTANTE: Muy alto para estar siempre encima de las casillas */
            position: relative;
            /* Necesario para que el z-index funcione bien */
            cursor: grab;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.6));
            /* Sombra mÃ¡s pronunciada para dar altura */
            pointer-events: auto;
            /* Asegura que reciba los eventos del ratÃ³n */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* GHOSTING (Feedback Visual) */
        .ghost-valid {
            background-color: rgba(46, 204, 113, 0.6) !important;
            /* Verde */
            box-shadow: inset 0 0 0 2px #27ae60;
        }

        .ghost-invalid {
            background-color: rgba(231, 76, 60, 0.6) !important;
            /* Rojo */
            box-shadow: inset 0 0 0 2px #c0392b;
        }

        /* --- VENTANA MODAL Y REGLAS --- */
        .modal {
            display: none;
            /* Oculto por defecto */
            position: fixed;
            z-index: 2000;
            /* Por encima de todo */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.85);
            /* Fondo oscuro */
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #2c3e50;
            margin: 5% auto;
            padding: 20px;
            border: 2px solid var(--c-gold);
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            color: #ecf0f1;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-size: 0.95em;
            line-height: 1.6;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .close-btn {
            color: #bdc3c7;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: var(--c-red);
        }

        /* BotÃ³n de idioma (dentro del modal) */
        .btn-lang {
            background: transparent;
            border: 1px solid #7f8c8d;
            color: #bdc3c7;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-right: 20px;
            transition: all 0.3s;
        }

        .btn-lang:hover {
            border-color: var(--c-gold);
            color: var(--c-gold);
            background-color: rgba(241, 196, 15, 0.1);
        }

        /* BotÃ³n principal (Footer) */
        footer {
            margin-top: 15px;
            margin-bottom: 10px;
            text-align: center;
        }

        .btn-rules {
            background: none;
            border: 1px solid var(--c-gold);
            color: var(--c-gold);
            padding: 5px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-rules:hover {
            background-color: var(--c-gold);
            color: #1a252f;
            box-shadow: 0 0 10px var(--c-gold);
        }

        /* Formato de texto */
        .rules-container h3 {
            color: var(--c-gold);
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-top: 20px;
        }

        .rules-container h4 {
            color: #3498db;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .rules-container ul,
        .rules-container ol {
            padding-left: 20px;
        }

        .rules-container li {
            margin-bottom: 5px;
        }

        /* InglÃ©s por defecto */
        #rules-en {
            display: block;
        }

        #rules-es {
            display: none;
        }

        /* Estilo para el Selector de Idioma */
        .btn-lang {
            background-color: #2c3e50;
            /* Fondo oscuro a juego */
            border: 1px solid #7f8c8d;
            color: #bdc3c7;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-right: 20px;
            transition: all 0.3s;
            outline: none;
            /* Quitar borde azul al seleccionar */
        }

        .btn-lang:hover,
        .btn-lang:focus {
            border-color: var(--c-gold);
            color: var(--c-gold);
            box-shadow: 0 0 5px rgba(241, 196, 15, 0.2);
        }

        /* Opciones internas (Solo se ve al desplegar) */
        .btn-lang option {
            background-color: #2c3e50;
            color: white;
        }
    </style>
</head>

<body>

    <header>
        <h1 class="game-title">COTADREZ</h1>
        <div id="status-bar" class="status-bar">Choose your destiny: Drag a Fortress to start. Hover for Visual Aid.
        </div>
    </header>

    <div class="main-container">
        <div class="panel" id="panel-rojo" style="border-color: var(--c-red);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-rojo"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Dungeon</div>
                <div class="dungeon-list" id="grave-rojo"></div>
            </div>
        </div>

        <div id="board"></div>

        <div class="panel" id="panel-negro" style="border-color: var(--c-black);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-negro"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Dungeon</div>
                <div class="dungeon-list" id="grave-negro"></div>
            </div>
        </div>
    </div>

    <footer>
        <button class="btn-rules" onclick="toggleRules()">ğŸ“œ Rules / Reglamento</button>
    </footer>


    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="rules-title" style="margin:0; color: var(--c-gold);">ğŸ“œ COTADREZ RULES</h2>
                <div style="display: flex; align-items: center;">
                    <select id="langSelector" class="btn-lang" onchange="changeLanguage(this.value)">
                        <option value="en">English</option>
                        <option value="es">EspaÃ±ol</option>
                        <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    </select>
                    <span class="close-btn" onclick="toggleRules()">&times;</span>
                </div>
            </div>

            <div id="rules-es" class="rules-container">
                <h3>ğŸ¯ OBJETIVO</h3>
                <p>El objetivo es simple y brutal: <strong>Capturar al ğŸ‘‘ Rey enemigo</strong>. Puedes lograrlo mediante
                    un
                    <strong>Jaque Mate</strong> tradicional en el tablero o asediando su ğŸ° Fortaleza hasta obligarle a
                    salir y aniquilarlo.
                </p>
                <h3>0. SISTEMA DE AYUDA</h3>
                <ol>
                    <li>MÃ¡ntÃ©n el ratÃ³n sobre cada una de las unidades durante <strong>1 segundo</strong> para que se
                        active las Ayuda Visual. Son una serie de iconos que aparecen en la linea de Notificaciones
                        (bajo el tÃ­tulo) te recuerdan cÃ³mo mover. QuÃ© obstÃ¡culos debes tener en cuenta. Y cuales son
                        las caracterÃ­sticas especiales de esa unidad.</li>
                    <li> Si lo mantienes durante <strong>3 segundos</strong> se activarÃ¡ una ayuda visual en el tablero,
                        mostrÃ¡ndote a que casillas puedes ir y cuales de encuentran bloqueadas.</li>
                </ol>

                <h3>1. FASE DE DESPLIEGUE (Niebla de Guerra)</h3>
                <ol>
                    <li><strong>ğŸ° La Fortaleza:</strong> Debes ğŸ—ï¸ construirla al principio: define tu ğŸš© Territorio
                        (Norte o Sur)
                        y tus colores (Rojo y Oro o Negro y Plata). Ninguna unidad puede â›” atravesarla. Es la
                        Ãºnica unidad que puede situarse sobre casillas ocupadas por ğŸŒŠ Agua. Si no has desplegado las
                        tropas puedes
                        devolverla a la Reserva pulsando sobre ella y colocarla en otro lugar. Durante la partida no se
                        puede mover (â¡ï¸:â›”)</li>
                    <li><strong>ğŸª– Las Tropas (ğŸ¤ Aliadas o ğŸ§¨ Enemigas):</strong> Arrastra tus unidades desde la
                        Reserva al <strong>Anillo de
                            Salida</strong> (las 12 casillas que rodean tu ğŸ° Fortaleza). Si en esta fase quieres
                        devolver alguna unidad a la
                        Reserva arrÃ¡strala fuera del Anillo de Salida. Las piezas que no tengan hueco en el Anillo de
                        Salida se quedan temporalmente en la Reserva.</li>
                    <li><strong>ğŸ”ï¸ Las MontaÃ±as:</strong> Se pueden ğŸ—ï¸ colocar en cualquier lugar de tu ğŸš© Territorio.
                        Solo los ğŸ‰ dragones pueden volar por encima de ellas. Durante la partida no se pueden mover
                        (â¡ï¸:â›”).</li>
                    <li><strong>Final del turno:</strong> Para indicar que has terminado el despliegue de tu ejÃ©rcito,
                        haz click en tu Fortaleza.
                        Ten en cuenta que no te dejarÃ¡ terminar el turno hasta que hayas colocado todas las ğŸ”ï¸ MontaÃ±as
                        y al menos una unidad.</li>
                    <li><strong>Â¡A la Batalla!:</strong> El Jugador 2 despliega "a ciegas". Al finalizar el turno
                        de despliegue del Jugador 1, se oculta su ejÃ©cito para que el Jugador 2 no tenga ventaja.</li>
                </ol>

                <h3>2. MOVIMIENTO Y COMBATE</h3>
                <p>Los movimientos se realizan por turnos, el marco del tablero indica el color del ejercito que tiene
                    el turno. En un turno, se puede mover, disparar, o sacar unidades de la Reserva.
                </p>
                <p>Las piezas capturadas van a la <strong>Mazmorra</strong> del enemigo. Â¡PodrÃ¡s rescatarlas luego!
                    Asediando la ğŸ° Fortaleza enemiga (VER 3. MECÃNICA DEL ASEDIO).
                </p>

                <h4>ğŸ›¡ï¸ Unidades BÃ¡sicas</h4>
                <ul>
                    <li><strong>ğŸ‘‘ Rey:</strong> Se mueve 1 casilla en cualquier direcciÃ³n (â¬†ï¸:1âœ–ï¸â•). Es la pieza
                        <strong>"CLAVE":</strong> si la capturan se termina la partida.
                        No puede mover a una casillas bajo âš ï¸ Amenaza o bloqueada (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸).
                    </li>
                    <li><strong>ğŸšï¸ Chusma:</strong> Se mueve 1 casilla ortogonal (â¬†ï¸:1â•). No puede mover a casillas
                        bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Marcha Forzada (âš¡:+1ğŸšï¸)":</strong> Mueve 2
                        unidades de chusma distintas en el mismo turno. Puedes renunciar a la "Marcha Forzada" haciendo
                        click sobre la unidad que acabas de mover.</li>
                    <li><strong>ğŸ”± Lancero:</strong> Mueve 1 casilla ortogonal (â¬†ï¸:1â•). No puede mover a casillas
                        bloqueadas (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Relevo (âš¡:ğŸ¤ğŸ”„)":</strong> Intercambia
                        su posiciÃ³n con un ğŸ¤ Aliado si movemos a la casilla ocupada por este.</li>
                    <li><strong>ğŸ¹ Arquero:</strong> Mueve 1 casilla diagonal (â¬†ï¸:1âœ–ï¸). No puede mover a casillas
                        bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Largo Alcance (âš¡:ğŸ§¨+1)":</strong> Puede mover 2
                        casillas
                        para capturar a una unidad ğŸ§¨ Enemiga.</li>
                </ul>

                <h4>ğŸ CaballerÃ­a y Bestias</h4>
                <ul>
                    <li><strong>ğŸ´ Cab. Ligera:</strong> Mueve en "L" diagonal (â¬†ï¸:2+1âœ”ï¸). <strong>NO:</strong> puede
                        atravesar casillas bloqueadas (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>EXTRA: "Salto (âš¡:ğŸ‘»ğŸª–)":</strong> Atraviesa tropas ğŸ¤ aliadas y ğŸ§¨ enemigas.
                    </li>
                    <li><strong>ğŸ›¡ï¸ Cab. Pesada:</strong> Mueve en "L" ortogonal (â¬†ï¸:2+1L).<strong>NO:</strong> puede
                        atravesar casillas bloqueadas (â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>EXTRA: "Paso Preferente (âš¡:ğŸ‘»ğŸ¤)":</strong> Atraviesa tropas ğŸ¤ aliadas.
                    </li>
                    <li><strong>ğŸ˜ Elefante:</strong> Mueve ortogonal (â¬†ï¸:â•). No puede atravesar casillas bloqueadas
                        (â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Piel Dura (âš¡:ğŸ”’+ğŸ§¨ğŸ§¨oğŸ‰):"</strong> Inmune a
                        ataques individuales (necesita 2+ enemigos o un ğŸ‰ DragÃ³n para capturarlo).</li>
                    <li><strong>ğŸ‰ DragÃ³n:</strong> Mueve en cualquier direcciÃ³n (â¬†ï¸:â•âœ–ï¸). No puede atravesar casillas
                        bloqueadas (â›”:ğŸª–ğŸ°).<strong>EXTRA: "Vuelo (âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ):"</strong>
                        Puede volar sobre las ğŸ”ï¸ MontaÃ±as y el ğŸŒŠ Agua y capturar ğŸ˜ elefantes sin apoyo.</li>
                </ul>

                <h4>âš™ï¸ Armas de Asedio</h4>
                <ul>
                    <li>Las <strong>Armas de Asedio</strong> pueden â¬†ï¸ mover (a una casilla ğŸ”² vacÃ­a: solo capturan
                        disparando) o ğŸ¯ disparar, pero no pueden hacer las dos cosas en el mismo turno.</li>
                    <li><strong>â˜„ï¸ Trabuquete:</strong> Mueve Diagonal 1 casilla (debe estar ğŸ”² vacÃ­a: solo captura
                        disparando) (â¬†ï¸:1âœ–ï¸ğŸ”²). Dispara Ortogonal (ğŸ¯:â•)
                        No puede atravesar casillas bloqueadas (â›”:ğŸ°ğŸ”ï¸).<strong>EXTRA: "Tiro ParabÃ³lico
                            (âš¡:ğŸ‘»ğŸª–ğŸŒŠ):"</strong> Puede disparar atravesado el ğŸŒŠ Agua y las
                        casillas ocupadas por ğŸ§¨ enemigos o ğŸ¤ aliados.</li>
                    <li><strong>ğŸ¦‚ EscorpiÃ³n:</strong> Mueve Ortogonal 1 casilla (debe estar ğŸ”² vacÃ­a: solo captura
                        disparando) (â¬†ï¸:1â•ğŸ”²). Dispara Diagonal (ğŸ¯:âœ–ï¸)
                        No puede atravesar casillas bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸).<strong>EXTRA: "Brocheta
                            (âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨):"</strong> Puede disparar atravesado el ğŸŒŠ Agua y las
                        casillas ocupadas por ğŸ§¨ enemigos si hay una segunda unidad ğŸ§¨ enemiga a menos de 2 casillas de
                        distancia y la casilla intermedia, si la hay, esta
                        ğŸ”² vacÃ­a u ocupada por ğŸŒŠ agua: en ese caso puede capturar ambas (arrastra hasta la segunda
                        unidad enemiga).</li>
                </ul>

                <h3>3. MECÃNICA DEL ASEDIO</h3>
                <p><strong>PASO 1: AMENAZA</strong><br>Coloca <strong>2+ unidades</strong> ğŸ¤ Aliadas en el Anillo de
                    Salida de la ğŸ° Fortaleza
                    ğŸ§¨ Enemiga.</p>
                <p><strong>PASO 2: DEFENSA</strong><br>El defensor tiene <strong>1 turno</strong> para romper el cerco.
                </p>
                <p><strong>PASO 3: EJECUCIÃ“N</strong><br>Si falla, el atacante pulsa la ğŸ° Fortaleza para EJECUTAR el
                    ASEDIO.</p>
                <p><strong>PASO 4: CONSECUENCIAS</strong></p>
                <ul>
                    <li><strong>Rescate:</strong> El atacante libera 1 prisionero pulsando sobre Ã©l en la mazmorra
                        enemiga. Sus tropas vuelven a su Reserva.</li>
                    <li><strong>Intercambio de Rehenes:</strong> El defensor salva 1 unidad (si hubo Rescate) sacÃ¡ndola
                        de la Reserva al Anillo de Salida o <strong>PIERDE
                            TODO</strong> (si no habÃ­a en su Mazmorra ninguna unidad con la que negociar el
                        intercambio).</li>
                </ul>
            </div>

            <div id="rules-en" class="rules-container">
                <h3>ğŸ¯ OBJECTIVE</h3>
                <p>The objective is simple and brutal: <strong>Capture the enemy ğŸ‘‘ King</strong>. You can achieve this
                    through a traditional <strong>Checkmate</strong> on the board or by besieging their ğŸ° Fortress
                    until
                    they are forced to come out and be annihilated.
                </p>
                <h3>0. HELP SYSTEM</h3>
                <ol>
                    <li>Hover your mouse over any unit for <strong>1 second</strong> to activate Visual Aid. A series of
                        icons
                        will appear in the Notification bar (under the title) to remind you how it moves, which
                        obstacles
                        to avoid, and what the unit's special characteristics are.</li>
                    <li>If you hold it for <strong>3 seconds</strong>, a visual aid will activate on the board, showing
                        you
                        which squares you can go to and which ones are blocked.</li>
                </ol>

                <h3>1. DEPLOYMENT PHASE (Fog of War)</h3>
                <ol>
                    <li><strong>ğŸ° The Fortress:</strong> You must ğŸ—ï¸ build it first: define your ğŸš© Territory (North
                        or South)
                        and your colors (Red & Gold or Black & Silver). No unit can â›” pass through it. It is the
                        only unit that can be placed on ğŸŒŠ Water tiles. If you haven't deployed troops yet, you can
                        return
                        it to the Reserve by clicking on it and placing it elsewhere. It cannot move during the game
                        (â¡ï¸:â›”).</li>
                    <li><strong>ğŸª– The Troops (ğŸ¤ Allies or ğŸ§¨ Enemies):</strong> Drag your units from the Reserve to
                        the
                        <strong>Exit Ring</strong> (the 12 squares surrounding your ğŸ° Fortress). If you want to return
                        a unit
                        to the Reserve during this phase, drag it out of the Exit Ring. Pieces with no room in the Exit
                        Ring
                        stay temporarily in the Reserve.
                    </li>
                    <li><strong>ğŸ”ï¸ The Mountains:</strong> Can be ğŸ—ï¸ placed anywhere in your ğŸš© Territory. Only
                        ğŸ‰ Dragons can fly over them. They cannot move during the game (â¡ï¸:â›”).</li>
                    <li><strong>End of Turn:</strong> To indicate you have finished deploying your army, click on your
                        Fortress.
                        Note that it won't let you finish the turn until you have placed all ğŸ”ï¸ Mountains and at least
                        one unit.</li>
                    <li><strong>To Battle!:</strong> Player 2 deploys "blindly". When Player 1 finishes their deployment
                        turn,
                        their army is hidden so Player 2 has no advantage.</li>
                </ol>

                <h3>2. MOVEMENT AND COMBAT</h3>
                <p>Moves are turn-based; the board frame indicates the color of the active army.
                    In a turn, you can move, shoot, or deploy units from the Reserve.
                </p>
                <p>Captured pieces go to the enemy <strong>Dungeon</strong>. You can rescue them later!
                    By besieging the enemy ğŸ° Fortress (SEE 3. SIEGE MECHANICS).
                </p>

                <h4>ğŸ›¡ï¸ Basic Units</h4>
                <ul>
                    <li><strong>ğŸ‘‘ King:</strong> Moves 1 square in any direction (â¬†ï¸:1âœ–ï¸â•). It is the
                        <strong>"KEY"</strong> piece:
                        if captured, the game ends. Cannot move to âš ï¸ Threatened or blocked squares (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸).
                    </li>
                    <li><strong>ğŸšï¸ Rabble:</strong> Moves 1 orthogonal square (â¬†ï¸:1â•). Cannot move to blocked squares
                        (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Forced March (âš¡:+1ğŸšï¸)":</strong> Move 2 different Rabble units
                        in the
                        same turn. You can waive the "Forced March" by clicking on the unit you just moved.</li>
                    <li><strong>ğŸ”± Lancer:</strong> Moves 1 orthogonal square (â¬†ï¸:1â•). Cannot move to blocked squares
                        (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Relay (âš¡:ğŸ¤ğŸ”„)":</strong> Swaps position with an ğŸ¤ Ally if moving
                        to
                        the square occupied by them.</li>
                    <li><strong>ğŸ¹ Archer:</strong> Moves 1 diagonal square (â¬†ï¸:1âœ–ï¸). Cannot move to blocked squares
                        (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Long Range (âš¡:ğŸ§¨+1)":</strong> Can move 2 squares to capture an
                        ğŸ§¨ Enemy unit.</li>
                </ul>

                <h4>ğŸ Cavalry and Beasts</h4>
                <ul>
                    <li><strong>ğŸ´ Light Cav.:</strong> Moves in a diagonal "L" (â¬†ï¸:2+1âœ”ï¸). <strong>CANNOT</strong> move
                        through
                        blocked squares (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Jump (âš¡:ğŸ‘»ğŸª–)":</strong> Jumps over ğŸ¤ Allied and
                        ğŸ§¨ Enemy troops.
                    </li>
                    <li><strong>ğŸ›¡ï¸ Heavy Cav.:</strong> Moves in an orthogonal "L" (â¬†ï¸:2+1L). <strong>CANNOT</strong>
                        move through
                        blocked squares (â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Right of Way (âš¡:ğŸ‘»ğŸ¤)":</strong> Passes through
                        ğŸ¤ Allied troops.
                    </li>
                    <li><strong>ğŸ˜ Elephant:</strong> Moves orthogonally (â¬†ï¸:â•). Cannot pass through blocked squares
                        (â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Thick Skin (âš¡:ğŸ”’+ğŸ§¨ğŸ§¨orğŸ‰):"</strong> Immune to individual
                        attacks
                        (needs 2+ enemies or a ğŸ‰ Dragon to capture it).</li>
                    <li><strong>ğŸ‰ Dragon:</strong> Moves in any direction (â¬†ï¸:â•âœ–ï¸). Cannot pass through blocked squares
                        (â›”:ğŸª–ğŸ°). <strong>EXTRA: "Flight (âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ):"</strong> Can fly over ğŸ”ï¸ Mountains and ğŸŒŠ
                        Water
                        and capture ğŸ˜ Elephants without support.</li>
                </ul>

                <h4>âš™ï¸ Siege Weapons</h4>
                <ul>
                    <li><strong>Siege Weapons</strong> can â¬†ï¸ Move (to an ğŸ”² empty square: they only capture by
                        shooting) or
                        ğŸ¯ Shoot, but cannot do both in the same turn.</li>
                    <li><strong>â˜„ï¸ Trebuchet:</strong> Moves Diagonally 1 square (must be ğŸ”² empty) (â¬†ï¸:1âœ–ï¸ğŸ”²). Shoots
                        Orthogonally (ğŸ¯:â•).
                        Cannot pass through blocked squares (â›”:ğŸ°ğŸ”ï¸). <strong>EXTRA: "Parabolic Shot
                            (âš¡:ğŸ‘»ğŸª–ğŸŒŠ):"</strong>
                        Can shoot over ğŸŒŠ Water and squares occupied by ğŸ§¨ Enemies or ğŸ¤ Allies.</li>
                    <li><strong>ğŸ¦‚ Scorpion:</strong> Moves Orthogonally 1 square (must be ğŸ”² empty) (â¬†ï¸:1â•ğŸ”²). Shoots
                        Diagonally (ğŸ¯:âœ–ï¸).
                        Cannot pass through blocked squares (â›”:ğŸ¤ğŸ°ğŸ”ï¸). <strong>EXTRA: "Skewer
                            (âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨):"</strong>
                        Can shoot over ğŸŒŠ Water and squares occupied by ğŸ§¨ Enemies if there is a second ğŸ§¨ Enemy unit
                        less than
                        2 squares away and the intermediate square, if any, is ğŸ”² empty or ğŸŒŠ water: in that case, it
                        captures both
                        (drag to the second enemy unit).</li>
                </ul>

                <h3>3. SIEGE MECHANICS</h3>
                <p><strong>STEP 1: THREAT</strong><br>Place <strong>2+ ğŸ¤ Allied units</strong> in the Exit Ring of the
                    ğŸ§¨ Enemy ğŸ° Fortress.</p>
                <p><strong>STEP 2: DEFENSE</strong><br>The defender has <strong>1 turn</strong> to break the siege.</p>
                <p><strong>STEP 3: EXECUTION</strong><br>If they fail, the attacker clicks the ğŸ° Fortress to EXECUTE
                    the SIEGE.</p>
                <p><strong>STEP 4: CONSEQUENCES</strong></p>
                <ul>
                    <li><strong>Rescue:</strong> The attacker frees 1 prisoner by clicking on them in the enemy dungeon.
                        Their troops return to their Reserve.</li>
                    <li><strong>Hostage Exchange:</strong> The defender saves 1 unit (if a Rescue occurred) by moving it
                        from
                        the Reserve to the Exit Ring or <strong>LOSES EVERYTHING</strong> (if there were no units in
                        their Dungeon
                        to negotiate the exchange).</li>
                </ul>
            </div>

            <div id="rules-ru" class="rules-container" style="display: none;">
                <h3>ğŸ¯ Ğ¦Ğ•Ğ›Ğ¬</h3>
                <p>Ğ¦ĞµĞ»ÑŒ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ° Ğ¸ Ğ¶ĞµÑÑ‚Ğ¾ĞºĞ°: <strong>Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ²Ñ€Ğ°Ğ¶ĞµÑĞºĞ¾Ğ³Ğ¾ ğŸ‘‘ ĞšĞ¾Ñ€Ğ¾Ğ»Ñ</strong>. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ´ĞµĞ»Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾ Ñ‡ĞµÑ€ĞµĞ·
                    Ñ‚Ñ€Ğ°Ğ´Ğ¸Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğ¹
                    <strong>ĞœĞ°Ñ‚</strong> Ğ½Ğ° Ğ´Ğ¾ÑĞºĞµ Ğ¸Ğ»Ğ¸ Ğ¾ÑĞ°Ğ¶Ğ´Ğ°Ñ ĞµĞ³Ğ¾ ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ, Ğ¿Ğ¾ĞºĞ° Ğ¾Ğ½ Ğ½Ğµ Ğ±ÑƒĞ´ĞµÑ‚ Ğ²Ñ‹Ğ½ÑƒĞ¶Ğ´ĞµĞ½ Ğ²Ñ‹Ğ¹Ñ‚Ğ¸ Ğ¸
                    Ğ¿Ğ¾Ğ³Ğ¸Ğ±Ğ½ÑƒÑ‚ÑŒ.
                </p>
                <h3>0. Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞŸĞĞœĞĞ©Ğ˜</h3>
                <ol>
                    <li>ĞĞ°Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºÑƒÑ€ÑĞ¾Ñ€ Ğ½Ğ° Ğ»ÑĞ±ÑƒÑ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ Ğ½Ğ° <strong>1 ÑĞµĞºÑƒĞ½Ğ´Ñƒ</strong>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ’Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½ÑƒÑ
                        ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ.
                        Ğ’ ÑÑ‚Ñ€Ğ¾ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹ (Ğ¿Ğ¾Ğ´ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ¾Ğ¼) Ğ¿Ğ¾ÑĞ²Ğ¸Ñ‚ÑÑ Ñ€ÑĞ´ Ğ¸ĞºĞ¾Ğ½Ğ¾Ğº, Ğ½Ğ°Ğ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°ÑÑ‰Ğ¸Ñ…, ĞºĞ°Ğº Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ,
                        ĞºĞ°ĞºĞ¸Ğµ Ğ¿Ñ€ĞµĞ¿ÑÑ‚ÑÑ‚Ğ²Ğ¸Ñ ÑƒÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ¸ ĞºĞ°ĞºĞ¾Ğ²Ñ‹ Ğ¾ÑĞ¾Ğ±Ñ‹Ğµ Ñ…Ğ°Ñ€Ğ°ĞºÑ‚ĞµÑ€Ğ¸ÑÑ‚Ğ¸ĞºĞ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹.</li>
                    <li>Ğ•ÑĞ»Ğ¸ ÑƒĞ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ ĞºÑƒÑ€ÑĞ¾Ñ€ <strong>3 ÑĞµĞºÑƒĞ½Ğ´Ñ‹</strong>, Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ Ğ½Ğ° Ğ´Ğ¾ÑĞºĞµ,
                        Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ÑÑ‰Ğ°Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ğ¸ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸.</li>
                </ol>

                <h3>1. Ğ¤ĞĞ—Ğ Ğ ĞĞ—Ğ’Ğ•Ğ Ğ¢Ğ«Ğ’ĞĞĞ˜Ğ¯ (Ğ¢ÑƒĞ¼Ğ°Ğ½ Ğ’Ğ¾Ğ¹Ğ½Ñ‹)</h3>
                <ol>
                    <li><strong>ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ:</strong> Ğ’Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ ğŸ—ï¸ Ğ½Ğ°Ñ‡Ğ°Ñ‚ÑŒ Ñ ĞµÑ‘ ÑÑ‚Ñ€Ğ¾Ğ¸Ñ‚ĞµĞ»ÑŒÑÑ‚Ğ²Ğ°: Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ²Ğ¾Ñ ğŸš©
                        Ğ¢ĞµÑ€Ñ€Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ
                        (Ğ¡ĞµĞ²ĞµÑ€ Ğ¸Ğ»Ğ¸ Ğ®Ğ³) Ğ¸ ÑĞ²Ğ¾Ğ¸ Ñ†Ğ²ĞµÑ‚Ğ°. ĞĞ¸ Ğ¾Ğ´Ğ½Ğ° Ñ„Ğ¸Ğ³ÑƒÑ€Ğ° Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ â›” Ğ¿Ñ€Ğ¾Ğ¹Ñ‚Ğ¸ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ½ĞµÑ‘. Ğ­Ñ‚Ğ¾
                        ĞµĞ´Ğ¸Ğ½ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ°Ñ Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°, ĞºĞ¾Ñ‚Ğ¾Ñ€ÑƒÑ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ° ğŸŒŠ Ğ’Ğ¾Ğ´Ñƒ. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ ĞµÑ‰Ğµ Ğ½Ğµ Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒĞ»Ğ¸ Ğ²Ğ¾Ğ¹ÑĞºĞ°,
                        Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ ĞµÑ‘ Ğ² Ğ ĞµĞ·ĞµÑ€Ğ², Ğ½Ğ°Ğ¶Ğ°Ğ² Ğ½Ğ° Ğ½ĞµÑ‘. Ğ’Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ¸Ğ³Ñ€Ñ‹ Ğ¾Ğ½Ğ° Ğ½Ğµ Ğ´Ğ²Ğ¸Ğ³Ğ°ĞµÑ‚ÑÑ (â¡ï¸:â›”).</li>
                    <li><strong>ğŸª– Ğ’Ğ¾Ğ¹ÑĞºĞ° (ğŸ¤ Ğ¡Ğ¾ÑĞ·Ğ½Ğ¸ĞºĞ¸ Ğ¸Ğ»Ğ¸ ğŸ§¨ Ğ’Ñ€Ğ°Ğ³Ğ¸):</strong> ĞŸĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ¸Ğ·
                        Ğ ĞµĞ·ĞµÑ€Ğ²Ğ° Ğ² <strong>ĞšĞ¾Ğ»ÑŒÑ†Ğ¾ Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ°</strong> (12 ĞºĞ»ĞµÑ‚Ğ¾Ğº Ğ²Ğ¾ĞºÑ€ÑƒĞ³ Ğ²Ğ°ÑˆĞµĞ¹ ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚Ğ¸). Ğ•ÑĞ»Ğ¸ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ
                        Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ Ğ² Ğ ĞµĞ·ĞµÑ€Ğ² Ğ½Ğ° ÑÑ‚Ğ¾Ğ¼ ÑÑ‚Ğ°Ğ¿Ğµ, Ğ¿ĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ ĞµÑ‘ Ğ·Ğ° Ğ¿Ñ€ĞµĞ´ĞµĞ»Ñ‹ ĞšĞ¾Ğ»ÑŒÑ†Ğ°.</li>
                    <li><strong>ğŸ”ï¸ Ğ“Ğ¾Ñ€Ñ‹:</strong> ĞœĞ¾Ğ¶Ğ½Ğ¾ ğŸ—ï¸ Ñ€Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒ Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ Ğ¼ĞµÑÑ‚Ğµ Ğ²Ğ°ÑˆĞµĞ¹ ğŸš© Ğ¢ĞµÑ€Ñ€Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¸.
                        Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ğŸ‰ Ğ”Ñ€Ğ°ĞºĞ¾Ğ½Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ»ĞµÑ‚Ğ°Ñ‚ÑŒ Ğ½Ğ°Ğ´ Ğ½Ğ¸Ğ¼Ğ¸. Ğ’Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ¸Ğ³Ñ€Ñ‹ Ğ¾Ğ½Ğ¸ Ğ½Ğµ Ğ´Ğ²Ğ¸Ğ³Ğ°ÑÑ‚ÑÑ (â¡ï¸:â›”).</li>
                    <li><strong>ĞšĞ¾Ğ½ĞµÑ† Ñ…Ğ¾Ğ´Ğ°:</strong> Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ°Ñ€Ğ¼Ğ¸Ğ¸, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ½Ğ° ÑĞ²Ğ¾Ñ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ.
                        Ğ£Ñ‡Ñ‚Ğ¸Ñ‚Ğµ, Ñ‡Ñ‚Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ·Ğ°ĞºĞ¾Ğ½Ñ‡Ğ¸Ñ‚ÑŒ Ñ…Ğ¾Ğ´, Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ñ‹ Ğ²ÑĞµ ğŸ”ï¸ Ğ“Ğ¾Ñ€Ñ‹ Ğ¸ Ñ…Ğ¾Ñ‚Ñ Ğ±Ñ‹ Ğ¾Ğ´Ğ½Ğ° Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°.</li>
                    <li><strong>Ğš Ğ±Ğ¾Ñ!:</strong> Ğ˜Ğ³Ñ€Ğ¾Ğº 2 Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ "Ğ²ÑĞ»ĞµĞ¿ÑƒÑ": Ğ¿Ğ¾ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğ¸ Ñ…Ğ¾Ğ´Ğ° Ğ˜Ğ³Ñ€Ğ¾ĞºĞ° 1
                        ĞµĞ³Ğ¾ Ğ°Ñ€Ğ¼Ğ¸Ñ ÑĞºÑ€Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ˜Ğ³Ñ€Ğ¾Ğº 2 Ğ½Ğµ Ğ¸Ğ¼ĞµĞ» Ğ¿Ñ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ°.</li>
                </ol>

                <h3>2. Ğ”Ğ’Ğ˜Ğ–Ğ•ĞĞ˜Ğ• Ğ˜ Ğ‘ĞĞ™</h3>
                <p>Ğ¥Ğ¾Ğ´Ñ‹ Ğ¿Ğ¾ Ğ¾Ñ‡ĞµÑ€ĞµĞ´Ğ¸, Ñ€Ğ°Ğ¼ĞºĞ° Ğ´Ğ¾ÑĞºĞ¸ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ†Ğ²ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ¹ Ğ°Ñ€Ğ¼Ğ¸Ğ¸. Ğ—Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ñ…Ğ¾Ğ´ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿ĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚ÑŒÑÑ,
                    Ğ²Ñ‹ÑÑ‚Ñ€ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ²Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ Ğ¸Ğ· Ğ ĞµĞ·ĞµÑ€Ğ²Ğ°.
                </p>
                <p>Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‡ĞµĞ½Ğ½Ñ‹Ğµ Ñ„Ğ¸Ğ³ÑƒÑ€Ñ‹ Ğ¿Ğ¾Ğ¿Ğ°Ğ´Ğ°ÑÑ‚ Ğ² <strong>Ğ¢ĞµĞ¼Ğ½Ğ¸Ñ†Ñƒ</strong> Ğ²Ñ€Ğ°Ğ³Ğ°. Ğ’Ñ‹ ÑĞ¼Ğ¾Ğ¶ĞµÑ‚Ğµ ÑĞ¿Ğ°ÑÑ‚Ğ¸ Ğ¸Ñ… Ğ¿Ğ¾Ğ·Ğ¶Ğµ,
                    Ğ¾ÑĞ°Ğ¶Ğ´Ğ°Ñ Ğ²Ñ€Ğ°Ğ¶ĞµÑĞºÑƒÑ ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ (Ğ¡Ğœ. 3. ĞœĞ•Ğ¥ĞĞĞ˜ĞšĞ ĞĞ¡ĞĞ”Ğ«).
                </p>

                <h4>ğŸ›¡ï¸ Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ¤Ğ¸Ğ³ÑƒÑ€Ñ‹</h4>
                <ul>
                    <li><strong>ğŸ‘‘ ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ (â¬†ï¸:1âœ–ï¸â•). Ğ­Ñ‚Ğ¾
                        <strong>"ĞšĞ›Ğ®Ğ§Ğ•Ğ’ĞĞ¯"</strong> Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°: ĞµÑĞ»Ğ¸ ĞµÑ‘ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚ÑÑ‚, Ğ¸Ğ³Ñ€Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ°.
                        ĞĞµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ½Ğ° ĞºĞ»ĞµÑ‚ĞºĞ¸ Ğ¿Ğ¾Ğ´ âš ï¸ Ğ£Ğ³Ñ€Ğ¾Ğ·Ğ¾Ğ¹ Ğ¸Ğ»Ğ¸ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸).
                    </li>
                    <li><strong>ğŸšï¸ Ğ§ĞµÑ€Ğ½ÑŒ:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ Ğ¾Ñ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (â¬†ï¸:1â•). ĞĞµ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
                        ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "ĞœĞ°Ñ€Ñˆ-Ğ±Ñ€Ğ¾ÑĞ¾Ğº (âš¡:+1ğŸšï¸)":</strong> ĞŸĞµÑ€ĞµĞ¼ĞµÑÑ‚Ğ¸Ñ‚Ğµ 2
                        Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ¾Ñ‚Ñ€ÑĞ´Ğ° Ñ‡ĞµÑ€Ğ½Ğ¸ Ğ·Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ñ…Ğ¾Ğ´. Ğ’Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ Ğ¾Ñ‚ĞºĞ°Ğ·Ğ°Ñ‚ÑŒÑÑ Ğ¾Ñ‚ Ğ±Ğ¾Ğ½ÑƒÑĞ°, Ğ½Ğ°Ğ¶Ğ°Ğ² Ğ½Ğ° Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾
                        Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ½ÑƒÑ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ.</li>
                    <li><strong>ğŸ”± ĞšĞ¾Ğ¿ĞµĞ¹Ñ‰Ğ¸Ğº:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ Ğ¾Ñ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (â¬†ï¸:1â•). ĞĞµ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ°
                        Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
                        ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "Ğ¡Ğ¼ĞµĞ½Ğ° (âš¡:ğŸ¤ğŸ”„)":</strong> ĞœĞµĞ½ÑĞµÑ‚ÑÑ
                        Ğ¼ĞµÑÑ‚Ğ°Ğ¼Ğ¸ Ñ ğŸ¤ Ğ¡Ğ¾ÑĞ·Ğ½Ğ¸ĞºĞ¾Ğ¼, ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° Ğ·Ğ°Ğ½ÑÑ‚ÑƒÑ Ğ¸Ğ¼ ĞºĞ»ĞµÑ‚ĞºÑƒ.</li>
                    <li><strong>ğŸ¹ Ğ›ÑƒÑ‡Ğ½Ğ¸Ğº:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ Ğ¿Ğ¾ Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»Ğ¸ (â¬†ï¸:1âœ–ï¸). ĞĞµ Ñ…Ğ¾Ğ´Ğ¸Ñ‚ Ğ½Ğ° Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
                        ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "Ğ”Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ²Ñ‹ÑÑ‚Ñ€ĞµĞ» (âš¡:ğŸ§¨+1)":</strong> ĞœĞ¾Ğ¶ĞµÑ‚ Ğ¿Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ½Ğ° 2
                        ĞºĞ»ĞµÑ‚ĞºĞ¸, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ ğŸ§¨ Ğ’Ñ€Ğ°Ğ³Ğ°.</li>
                </ul>

                <h4>ğŸ ĞšĞ°Ğ²Ğ°Ğ»ĞµÑ€Ğ¸Ñ Ğ¸ Ğ§ÑƒĞ´Ğ¾Ğ²Ğ¸Ñ‰Ğ°</h4>
                <ul>
                    <li><strong>ğŸ´ Ğ›ĞµĞ³ĞºĞ°Ñ ĞšĞ°Ğ².:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ±ÑƒĞºĞ²Ğ¾Ğ¹ "Ğ“" Ğ´Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (â¬†ï¸:2+1âœ”ï¸). <strong>ĞĞ•</strong>
                        Ğ¼Ğ¾Ğ¶ĞµÑ‚
                        Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "ĞŸÑ€Ñ‹Ğ¶Ğ¾Ğº (âš¡:ğŸ‘»ğŸª–)":</strong> ĞŸĞµÑ€ĞµĞ¿Ñ€Ñ‹Ğ³Ğ¸Ğ²Ğ°ĞµÑ‚ Ñ‡ĞµÑ€ĞµĞ· ğŸ¤ ÑĞ¾ÑĞ·Ğ½Ğ¸ĞºĞ¾Ğ² Ğ¸ ğŸ§¨ Ğ²Ñ€Ğ°Ğ³Ğ¾Ğ².
                    </li>
                    <li><strong>ğŸ›¡ï¸ Ğ¢ÑĞ¶ĞµĞ»Ğ°Ñ ĞšĞ°Ğ².:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ±ÑƒĞºĞ²Ğ¾Ğ¹ "Ğ“" Ğ¾Ñ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (â¬†ï¸:2+1L). <strong>ĞĞ•</strong>
                        Ğ¼Ğ¾Ğ¶ĞµÑ‚
                        Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑŒ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "ĞŸÑ€Ğ¾Ñ€Ñ‹Ğ² (âš¡:ğŸ‘»ğŸ¤)":</strong> ĞŸÑ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞºĞ²Ğ¾Ğ·ÑŒ ğŸ¤ Ğ²Ğ¾Ğ¹ÑĞºĞ° ÑĞ¾ÑĞ·Ğ½Ğ¸ĞºĞ¸.
                    </li>
                    <li><strong>ğŸ˜ Ğ¡Ğ»Ğ¾Ğ½:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ¾Ñ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (â¬†ï¸:â•). ĞĞµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
                        ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "Ğ¢Ğ¾Ğ»ÑÑ‚Ğ°Ñ ÑˆĞºÑƒÑ€Ğ° (âš¡:ğŸ”’+ğŸ§¨ğŸ§¨Ğ¸Ğ»Ğ¸ğŸ‰):"</strong> Ğ˜Ğ¼Ğ¼ÑƒĞ½Ğ¸Ñ‚ĞµÑ‚ Ğº
                        Ğ°Ñ‚Ğ°ĞºĞ°Ğ¼ Ğ¾Ğ´Ğ¸Ğ½Ğ¾Ñ‡ĞµĞº (Ğ½ÑƒĞ¶Ğ½Ğ¾ 2+ Ğ²Ñ€Ğ°Ğ³Ğ° Ğ¸Ğ»Ğ¸ ğŸ‰ Ğ”Ñ€Ğ°ĞºĞ¾Ğ½ Ğ´Ğ»Ñ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ°).</li>
                    <li><strong>ğŸ‰ Ğ”Ñ€Ğ°ĞºĞ¾Ğ½:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ² Ğ»ÑĞ±Ğ¾Ğ¼ Ğ½Ğ°Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğ¸ (â¬†ï¸:â•âœ–ï¸). ĞĞµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞºĞ²Ğ¾Ğ·ÑŒ
                        Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ
                        ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸª–ğŸ°). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "ĞŸĞ¾Ğ»ĞµÑ‚ (âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ):"</strong>
                        ĞœĞ¾Ğ¶ĞµÑ‚ Ğ»ĞµÑ‚Ğ°Ñ‚ÑŒ Ğ½Ğ°Ğ´ ğŸ”ï¸ Ğ“Ğ¾Ñ€Ğ°Ğ¼Ğ¸ Ğ¸ ğŸŒŠ Ğ’Ğ¾Ğ´Ğ¾Ğ¹ Ğ¸ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°Ñ‚ÑŒ ğŸ˜ ÑĞ»Ğ¾Ğ½Ğ¾Ğ² Ğ² Ğ¾Ğ´Ğ¸Ğ½Ğ¾Ñ‡ĞºÑƒ.</li>
                </ul>

                <h4>âš™ï¸ ĞÑĞ°Ğ´Ğ½Ñ‹Ğµ ĞÑ€ÑƒĞ´Ğ¸Ñ</h4>
                <ul>
                    <li><strong>ĞÑĞ°Ğ´Ğ½Ñ‹Ğµ ĞÑ€ÑƒĞ´Ğ¸Ñ</strong> Ğ¼Ğ¾Ğ³ÑƒÑ‚ â¬†ï¸ Ğ´Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒÑÑ (Ğ½Ğ° ğŸ”² Ğ¿ÑƒÑÑ‚ÑƒÑ ĞºĞ»ĞµÑ‚ĞºÑƒ: Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾
                        ÑÑ‚Ñ€ĞµĞ»ÑŒĞ±Ğ¾Ğ¹) Ğ¸Ğ»Ğ¸ ğŸ¯ ÑÑ‚Ñ€ĞµĞ»ÑÑ‚ÑŒ, Ğ½Ğ¾ Ğ½Ğµ Ğ¾Ğ±Ğ° Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ·Ğ° Ğ¾Ğ´Ğ¸Ğ½ Ñ…Ğ¾Ğ´.</li>
                    <li><strong>â˜„ï¸ Ğ¢Ñ€ĞµĞ±ÑƒÑˆĞµÑ‚:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ (Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ ğŸ”² Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹) (â¬†ï¸:1âœ–ï¸ğŸ”²).
                        Ğ¡Ñ‚Ñ€ĞµĞ»ÑĞµÑ‚
                        ĞÑ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (ğŸ¯:â•).
                        ĞĞµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ°ğŸ”ï¸). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "ĞĞ°Ğ²ĞµÑĞ½Ğ°Ñ ÑÑ‚Ñ€ĞµĞ»ÑŒĞ±Ğ°
                            (âš¡:ğŸ‘»ğŸª–ğŸŒŠ):"</strong> ĞœĞ¾Ğ¶ĞµÑ‚ ÑÑ‚Ñ€ĞµĞ»ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ²ĞµÑ€Ñ… ğŸŒŠ Ğ’Ğ¾Ğ´Ñ‹ Ğ¸ ĞºĞ»ĞµÑ‚Ğ¾Ğº, Ğ·Ğ°Ğ½ÑÑ‚Ñ‹Ñ… ğŸ§¨ Ğ’Ñ€Ğ°Ğ³Ğ°Ğ¼Ğ¸ Ğ¸Ğ»Ğ¸ ğŸ¤
                        Ğ¡Ğ¾ÑĞ·Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸.</li>
                    <li><strong>ğŸ¦‚ Ğ¡ĞºĞ¾Ñ€Ğ¿Ğ¸Ğ¾Ğ½:</strong> Ğ¥Ğ¾Ğ´Ğ¸Ñ‚ ĞÑ€Ñ‚Ğ¾Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ½Ğ° 1 ĞºĞ»ĞµÑ‚ĞºÑƒ (Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° Ğ±Ñ‹Ñ‚ÑŒ ğŸ”² Ğ¿ÑƒÑÑ‚Ğ¾Ğ¹) (â¬†ï¸:1â•ğŸ”²).
                        Ğ¡Ñ‚Ñ€ĞµĞ»ÑĞµÑ‚
                        Ğ”Ğ¸Ğ°Ğ³Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾ (ğŸ¯:âœ–ï¸).
                        ĞĞµ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´Ğ¸Ñ‚ ÑĞºĞ²Ğ¾Ğ·ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ ĞºĞ»ĞµÑ‚ĞºĞ¸ (â›”:ğŸ¤ğŸ°ğŸ”ï¸). <strong>Ğ­ĞšĞ¡Ğ¢Ğ Ğ: "Ğ¨Ğ°Ğ¼Ğ¿ÑƒÑ€
                            (âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨):"</strong> ĞœĞ¾Ğ¶ĞµÑ‚ ÑÑ‚Ñ€ĞµĞ»ÑÑ‚ÑŒ ÑĞºĞ²Ğ¾Ğ·ÑŒ ğŸŒŠ Ğ’Ğ¾Ğ´Ñƒ Ğ¸ ĞºĞ»ĞµÑ‚ĞºĞ¸ Ñ ğŸ§¨ Ğ’Ñ€Ğ°Ğ³Ğ°Ğ¼Ğ¸, ĞµÑĞ»Ğ¸
                        Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ¹ ğŸ§¨ Ğ’Ñ€Ğ°Ğ³ Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ¼ĞµĞ½ĞµĞµ Ñ‡ĞµĞ¼ Ğ² 2 ĞºĞ»ĞµÑ‚ĞºĞ°Ñ… Ğ¿Ğ¾Ğ·Ğ°Ğ´Ğ¸, Ğ° Ğ¿Ñ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ°Ñ ĞºĞ»ĞµÑ‚ĞºĞ° (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)
                        ğŸ”² Ğ¿ÑƒÑÑ‚Ğ° Ğ¸Ğ»Ğ¸ Ğ·Ğ°Ğ½ÑÑ‚Ğ° ğŸŒŠ Ğ²Ğ¾Ğ´Ğ¾Ğ¹: Ğ² ÑÑ‚Ğ¾Ğ¼ ÑĞ»ÑƒÑ‡Ğ°Ğµ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¾Ğ±Ğ¾Ğ¸Ñ… (Ğ¿ĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ Ğ½Ğ° Ğ²Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ğ²Ñ€Ğ°Ğ³Ğ°).
                    </li>
                </ul>

                <h3>3. ĞœĞ•Ğ¥ĞĞĞ˜ĞšĞ ĞĞ¡ĞĞ”Ğ«</h3>
                <p><strong>Ğ¨ĞĞ“ 1: Ğ£Ğ“Ğ ĞĞ—Ğ</strong><br>Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚Ğµ <strong>2+ ğŸ¤ Ğ¤Ğ¸Ğ³ÑƒÑ€Ñ‹ ÑĞ¾ÑĞ·Ğ½Ğ¸ĞºĞ¾Ğ²</strong> Ğ² ĞšĞ¾Ğ»ÑŒÑ†Ğµ
                    Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ° ğŸ§¨ Ğ’Ñ€Ğ°Ğ¶ĞµÑĞºĞ¾Ğ¹ ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚Ğ¸.</p>
                <p><strong>Ğ¨ĞĞ“ 2: Ğ—ĞĞ©Ğ˜Ğ¢Ğ</strong><br>Ğ£ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ğ¸ĞºĞ° ĞµÑÑ‚ÑŒ <strong>1 Ñ…Ğ¾Ğ´</strong>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ñ€Ğ¾Ñ€Ğ²Ğ°Ñ‚ÑŒ ĞºĞ¾Ğ»ÑŒÑ†Ğ¾.
                </p>
                <p><strong>Ğ¨ĞĞ“ 3: ĞšĞĞ—ĞĞ¬</strong><br>Ğ•ÑĞ»Ğ¸ Ğ½Ğµ Ğ²Ñ‹ÑˆĞ»Ğ¾, Ğ°Ñ‚Ğ°ĞºÑƒÑÑ‰Ğ¸Ğ¹ Ğ½Ğ°Ğ¶Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ½Ğ° ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ’Ğ«ĞŸĞĞ›ĞĞ˜Ğ¢Ğ¬
                    ĞĞ¡ĞĞ”Ğ£.</p>
                <p><strong>Ğ¨ĞĞ“ 4: ĞŸĞĞ¡Ğ›Ğ•Ğ”Ğ¡Ğ¢Ğ’Ğ˜Ğ¯</strong></p>
                <ul>
                    <li><strong>Ğ¡Ğ¿Ğ°ÑĞµĞ½Ğ¸Ğµ:</strong> ĞÑ‚Ğ°ĞºÑƒÑÑ‰Ğ¸Ğ¹ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµÑ‚ 1 Ğ¿Ğ»ĞµĞ½Ğ½Ğ¸ĞºĞ°, Ğ½Ğ°Ğ¶Ğ°Ğ² Ğ½Ğ° Ğ½ĞµĞ³Ğ¾ Ğ²Ğ¾ Ğ²Ñ€Ğ°Ğ¶ĞµÑĞºĞ¾Ğ¹ Ñ‚ĞµĞ¼Ğ½Ğ¸Ñ†Ğµ.
                        Ğ•Ğ³Ğ¾ Ğ²Ğ¾Ğ¹ÑĞºĞ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑ‚ÑÑ Ğ² Ğ ĞµĞ·ĞµÑ€Ğ².</li>
                    <li><strong>ĞĞ±Ğ¼ĞµĞ½ Ğ·Ğ°Ğ»Ğ¾Ğ¶Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸:</strong> Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ½Ğ¸Ğº ÑĞ¿Ğ°ÑĞ°ĞµÑ‚ 1 Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ (ĞµÑĞ»Ğ¸ Ğ±Ñ‹Ğ»Ğ¾ Ğ¡Ğ¿Ğ°ÑĞµĞ½Ğ¸Ğµ), Ğ²Ñ‹Ğ²Ğ¾Ğ´Ñ ĞµÑ‘
                        Ğ¸Ğ· Ğ ĞµĞ·ĞµÑ€Ğ²Ğ° Ğ² ĞšĞ¾Ğ»ÑŒÑ†Ğ¾ Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ°, Ğ¸Ğ»Ğ¸ <strong>Ğ¢Ğ•Ğ Ğ¯Ğ•Ğ¢
                            Ğ’Ğ¡Ğ</strong> (ĞµÑĞ»Ğ¸ Ğ² Ğ¢ĞµĞ¼Ğ½Ğ¸Ñ†Ğµ Ğ½Ğµ Ğ±Ñ‹Ğ»Ğ¾ Ñ„Ğ¸Ğ³ÑƒÑ€ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°).</li>
                </ul>
            </div>

        </div>
    </div>

    <script>
        // --- 1. CONFIGURACIÃ“N Y ESTADO ---
        const CONFIG = {
            repo: "https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main",
            // DefiniciÃ³n de cantidades y nombres de archivo
            pieces: {
                'fortaleza': { qty: 1, file: 'Castillo.svg' },
                'montana': { qty: 3, file: 'Montana.svg' },
                'rey': { qty: 1, file: 'Rey.svg' },
                'chusma': { qty: 3, file: 'Chusma.svg' },
                'lanceros': { qty: 3, file: 'Lanza.svg' },
                'arqueros': { qty: 3, file: 'Arco.svg' },
                'c_ligera': { qty: 3, file: 'CaballeriaL.svg' },
                'c_pesada': { qty: 2, file: 'CaballeriaP.svg' },
                'elefante': { qty: 2, file: 'Elefante.svg' },
                'escorpion': { qty: 1, file: 'Escorpion.svg' },
                'trabuquete': { qty: 1, file: 'Catapulta.svg' },
                'dragon': { qty: 1, file: 'Dragon.svg' }
            }
        };

        let reserves = { rojo: {}, negro: {} };
        // Matriz para las PIEZAS (Tropas) - Nombre nuevo para evitar errores
        let logicBoard = Array(10).fill().map(() => Array(10).fill(null));

        // Matriz para el TERRENO (Agua) - Esta ya la tenÃ­as, dÃ©jala igual
        let terrain = Array(10).fill().map(() => Array(10).fill(null));

        let draggingMeta = null; // GuardarÃ¡ quÃ© estamos moviendo

        let fortressPos = { rojo: null, negro: null };

        let chusmaMovedCoords = null; // GuardarÃ¡ {r, c} de la chusma que acaba de mover

        let shotHighlights = []; // GuardarÃ¡ las coordenadas {r,c} del Ãºltimo disparo para mantenerlas visibles

        let isNotificationActive = false; // Bloqueo para mensajes temporales
        let notificationTimer = null;     // Para limpiar el temporizador si se solapan mensajes

        let besiegedArmy = null; // GuardarÃ¡ 'rojo' o 'negro' durante la resoluciÃ³n del asedio

        // CAMBIO: DEJAMOS DE USAR UN BOOLEANO SIMPLE
        let siegeStatus = { rojo: false, negro: false }; // Estado de asedio INDEPENDIENTE para cada bando

        /* let isBesieged = false; // Nueva bandera para el estado de Asedio */

        let currentThreatMap = null; // Mapa Defensivo (DÃ³nde me atacan)

        let currentAttackMap = null; // NUEVO: Mapa Ofensivo (DÃ³nde ataco yo)

        let isCheck = false; // Nueva bandera para el estado de Jaque

        let gameOverData = null;

        // --- NUEVO: CONTROL DE NOTIFICACIONES AL ARRASTRAR ---
        let lastHoveredTile = null; // Para evitar parpadeos si nos movemos dentro de la misma casilla

        // FunciÃ³n auxiliar para traducir coordenadas (Ej: 0,0 -> "A1")
        function getCoordinateName(r, c) {
            const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
            // Asumimos fila 0 = 1, fila 9 = 10.
            return `${cols[c]}${10 - r}`;
        }

        // Almacena los prisioneros capturados POR cada jugador
        let dungeons = { rojo: [], negro: [] };

        // --- NUEVO: INFORMACIÃ“N DE UNIDADES (HOVER MULTI-IDIOMA) ---
        let hoverTimer = null;
        let infoDisplayTimer = null;
        let boardHelpTimer = null; // Timer para la ayuda visual en el tablero (3s)

        const UNIT_INFO = {
            'es': {
                'rey': "ğŸ‘‘ REY:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸",
                'chusma': "ğŸšï¸ CHUSMA:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:+1ğŸšï¸",
                'lanceros': "ğŸ”± LANCERO:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ¤ğŸ”„",
                'arqueros': "ğŸ¹ ARQUERO:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ§¨+1",
                'c_ligera': "ğŸ´ C. LIGERA:Â·Â·Â·Â·Â·â¬†ï¸:2+1âœ”ï¸Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–",
                'c_pesada': "ğŸ›¡ï¸ C. PESADA:Â·Â·Â·Â·Â·â¬†ï¸:2+1LÂ·Â·Â·Â·Â·â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸ¤",
                'elefante': "ğŸ˜ ELEFANTE:Â·Â·Â·Â·Â·â¬†ï¸:â•Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ”’+ğŸ§¨ğŸ§¨/ğŸ‰",
                'dragon': "ğŸ‰ DRAGÃ“N:Â·Â·Â·Â·Â·â¬†ï¸:â•âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°Â·Â·Â·Â·Â·âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ",
                'trabuquete': "â˜„ï¸ TRABUQUETE:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–ğŸŒŠ",
                'escorpion': "ğŸ¦‚ ESCORPIÃ“N:Â·Â·Â·Â·Â·â¬†ï¸:1â•ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨",
                'fortaleza': "ğŸ° FORTALEZA:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸŒŠÂ·Â·Â·Â·Â·â¬†ï¸:â›”",
                'montana': "ğŸ”ï¸ MONTAÃ‘A:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸš©Â·Â·Â·Â·Â·â¬†ï¸:â›”"
            },
            'en': {
                'rey': "ğŸ‘‘ KING:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸",
                'chusma': "ğŸšï¸ RABBLE:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:+1ğŸšï¸",
                'lanceros': "ğŸ”± LANCER:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ¤ğŸ”„",
                'arqueros': "ğŸ¹ ARCHER:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ§¨+1",
                'c_ligera': "ğŸ´ LT. CAVALRY:Â·Â·Â·Â·Â·â¬†ï¸:2+1âœ”ï¸Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–",
                'c_pesada': "ğŸ›¡ï¸ HVY. CAVALRY:Â·Â·Â·Â·Â·â¬†ï¸:2+1LÂ·Â·Â·Â·Â·â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸ¤",
                'elefante': "ğŸ˜ ELEPHANT:Â·Â·Â·Â·Â·â¬†ï¸:â•Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ”’+ğŸ§¨ğŸ§¨/ğŸ‰",
                'dragon': "ğŸ‰ DRAGON:Â·Â·Â·Â·Â·â¬†ï¸:â•âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°Â·Â·Â·Â·Â·âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ",
                'trabuquete': "â˜„ï¸ TREBUCHET:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–ğŸŒŠ",
                'escorpion': "ğŸ¦‚ SCORPION:Â·Â·Â·Â·Â·â¬†ï¸:1â•ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨",
                'fortaleza': "ğŸ° FORTRESS:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸŒŠÂ·Â·Â·Â·Â·â¬†ï¸:â›”.",
                'montana': "ğŸ”ï¸ MOUNTAIN:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸš©Â·Â·Â·Â·Â·â¬†ï¸:â›”"
            },
            'ru': {
                'rey': "ğŸ‘‘ ĞšĞĞ ĞĞ›Ğ¬:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸",
                'chusma': "ğŸšï¸ Ğ§Ğ•Ğ ĞĞ¬:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:+1ğŸšï¸",
                'lanceros': "ğŸ”± ĞšĞĞŸĞ•Ğ™Ğ©Ğ˜Ğš:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ¤ğŸ”„",
                'arqueros': "ğŸ¹ Ğ›Ğ£Ğ§ĞĞ˜Ğš:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ§¨+1",
                'c_ligera': "ğŸ´ Ğ›Ğ•Ğ“ĞšĞĞ¯ ĞšĞĞ’.:Â·Â·Â·Â·Â·â¬†ï¸:2+1âœ”ï¸Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–",
                'c_pesada': "ğŸ›¡ï¸ Ğ¢Ğ¯Ğ–Ğ•Ğ›ĞĞ¯ ĞšĞĞ’.:Â·Â·Â·Â·Â·â¬†ï¸:2+1LÂ·Â·Â·Â·Â·â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸ¤",
                'elefante': "ğŸ˜ Ğ¡Ğ›ĞĞ:Â·Â·Â·Â·Â·â¬†ï¸:â•Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ”’+ğŸ§¨ğŸ§¨/ğŸ‰",
                'dragon': "ğŸ‰ Ğ”Ğ ĞĞšĞĞ:Â·Â·Â·Â·Â·â¬†ï¸:â•âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°Â·Â·Â·Â·Â·âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ",
                'trabuquete': "â˜„ï¸ Ğ¢Ğ Ğ•Ğ‘Ğ£Ğ¨Ğ•Ğ¢:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–ğŸŒŠ",
                'escorpion': "ğŸ¦‚ Ğ¡ĞšĞĞ ĞŸĞ˜ĞĞ:Â·Â·Â·Â·Â·â¬†ï¸:1â•ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨",
                'fortaleza': "ğŸ° ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸŒŠÂ·Â·Â·Â·Â·â¬†ï¸:â›”",
                'montana': "ğŸ”ï¸ Ğ“ĞĞ Ğ:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸš©Â·Â·Â·Â·Â·â¬†ï¸:â›”"
            }

        };


        // --- DICCIONARIO DE TRADUCCIÃ“N (CORREGIDO Y COMPLETADO) ---
        const MESSAGES = {
            es: {
                // Nombres de EjÃ©rcitos (Solemnes)
                "north": "EJÃ‰RCITO DEL NORTE",
                "south": "EJÃ‰RCITO DEL SUR",
                "rojo": "ROJO",
                "negro": "NEGRO",
                // Claves compuestas para inicio de partida
                "DE ROJO": "DEL EJÃ‰RCITO ROJO",
                "DE NEGRO": "DEL EJÃ‰RCITO NEGRO",

                // Textos Generales
                "init": "Elige tu destino: Arrastra una Fortaleza para empezar. MantÃ©n el ratÃ³n sobre cualquier unidad para Ayuda Visual",
                "turn_part": "Turno",
                "deploy_phase": "Fase Despliegue",
                "dungeon_title": "MAZMORRA",

                // Mensajes de Juego
                "msg_valid": "Movimiento VÃ¡lido",
                "msg_invalid": "Movimiento InvÃ¡lido",
                "err_check": "âš ï¸ JAQUE âš ï¸",

                // Errores y Notas
                "water": " AGUA ğŸŒŠ",
                "fortress": "FORTALEZA ğŸ°",
                "mountain": "MONTAÃ‘A ğŸ”ï¸",
                "occupied": "OCUPADO",
                "limits": "ğŸš« FUERA DE LÃMITES",
                "siege_only": "ğŸ”’ Solo puedes mover las unidades que asedian la fortaleza.",
                "deploy_fort": "ğŸš« Solo despliegue en Fortaleza.",
                "invalid_cell": "ğŸš« Casilla invÃ¡lida.",
                "save_king": "ğŸ‘‘ Â¡Salva al REY!",
                "death_zone": "â›” Â¡Zona mortal!",
                "only_near": "â›” Solo junto a tu Fortaleza.",
                "no_water": "â›” No en el agua.",
                "zone_occ": "â›” Zona ocupada.",
                "illegal": "â›” Movimiento ilegal",
                "check_alert": "âš ï¸ Â¡ESTÃS EN JAQUE! Debes salvar al Rey.",
                "suicide": "â›” Movimiento invÃ¡lido: DejarÃ­a al Rey expuesto.",
                "relay": "ğŸ”„ Relevo de Lancero",
                "ally": "â›” Casilla aliada.",
                "shot": "ğŸ”¥ Â¡DISPARO!",
                "capture": "âš”ï¸ Â¡CAPTURA!",
                "siege_cancel": "ğŸ³ï¸ Asedio cancelado.",
                "first_fort": "ğŸš« Primero debes construir la FORTALEZA",
                "zone_forbid": "ğŸš« Zona Prohibida.",
                "deploy_near": "ğŸ›¡ï¸ Despliega junto a la Fortaleza",
                "no_fit": "Â¡No cabe aquÃ­!",
                "pos_invalid": "ğŸ° PosiciÃ³n invÃ¡lida",
                "turn_j1": "âš ï¸ Turno del JUGADOR 1",
                "turn_j2": "âš ï¸ Turno del JUGADOR 2",
                "relocated": "Unidad reubicada",
                "fort_set": "ğŸ° Fortaleza establecida.",
                "elephant_fail": "ğŸ˜ Â¡IMPOSIBLE! El ataque no es suficiente. Necesitas al menos 2 unidades amenazando al Elefante.",

                // Final de Partida y Fases
                "siege_use_reserve": "âš ï¸ Debes sacar una pieza de la RESERVA.",
                "mountains_left": "âš ï¸ Debes colocar todas las MONTAÃ‘AS en el mapa antes de terminar.",
                "mountains_start": "âš ï¸ Debes colocar todas las MONTAÃ‘AS en el mapa antes de empezar.",
                "fort_reset": "ğŸ° Reinicio: Fortaleza retirada. Puedes cambiar de bando.",
                "fort_soft": "â†©ï¸ Fortaleza retirada. (Tus montaÃ±as se mantienen).",
                "fort_retry": "â†©ï¸ Fortaleza retirada. Puedes colocarla de nuevo.",
                "rescue_fail": "â›” Necesitas mÃ¡s tropas rodeando la Fortaleza Enemiga para rescatar.",
                "rescue_empty": "ğŸš Â¡RESCATE Ã‰PICO! La fortaleza enemiga estaba vacÃ­a.",
                "siege_end": "ğŸ”„ Asedio finalizado. Tus tropas regresan a la RESERVA.",
                "fort_empty": "ğŸ“­ Fortaleza vacÃ­a. Fin del asedio.",
                "status_win": "ğŸ‘‘ VICTORIA DEL EJÃ‰RCITO {army}",
                "status_draw": "ğŸ FIN DE PARTIDA: TABLAS POR REY AHOGADO",
                "status_gameover": "ğŸ FIN DE PARTIDA: {reason}. {winner}",
                "reason_mate": "POR JAQUE MATE",
                "reason_stalemate": "TABLAS POR REY AHOGADO", // (Aunque esta no se usa en el mensaje final de tablas, es bueno tenerla)

                // Tooltips y Ayuda
                "debug_confirm": "âš ï¸ Â¿ACTIVAR MODO DEBUG?\nSe reiniciarÃ¡ la partida con despliegue aleatorio legal.",
                "debug_active": "ğŸ› ï¸ MODO DEBUG: Despliegue Legal Completado",
                "click_siege": "CLICK PARA EJECUTAR EL ASEDIO",
                "click_pass": "Click para CEDER EL TURNO",
                "click_rescue": "CLICK PARA RESCATAR Y EJECUTAR ASEDIO",
                "help_visualizing": "ğŸ’¡ Visualizando {count} movimientos posibles...",
                "help_blocked": "ğŸš« {unit}: SIN MOVIMIENTOS POSIBLES (BLOQUEADA)",
                "occupied_simple": "â›” Casilla ocupada",
                "water_error": "ğŸŒŠ Â¡Al agua no!",
                "water_simple": "â›” Agua.",
                "mountain_simple": "â›” MontaÃ±a.",
                "fortress_simple": "â›” Fortaleza.",
                "fortress_first_short": "âš ï¸ Primero la FORTALEZA.",

                // --- MENSAJES COMPUESTOS (NUEVOS) ---
                "msg_siege_break": "ğŸ”¥ Asedio roto. {count} capturados.",
                "msg_reinforcements": "ğŸ†• Refuerzos: {unit}",
                "msg_return_reserve": "â†©ï¸ {unit} devuelta a la reserva.",
                "msg_p1_control": "J1: {color} controla el {zone}.",
                "msg_deployed": "Desplegado: {unit}",
                "msg_p1_finish": "âœ… Despliegue J1 Finalizado. Turno del JUGADOR 2 ({color}).",
                "msg_game_start": "Â¡COMIENZA LA PARTIDA! Turno de {color}",
                "msg_rescued": "ğŸ”“ {unit} rescatado. Prisionero y tropas regresan a tu RESERVA.",
                "no_exchange": "ğŸš« Sin intercambio: {count} unidades capturadas en la reserva.",

                // ... (otras claves)
                "status_prisoner": "ğŸ”“ {army}: DEFENSA FALLIDA, Â¡SELECCIONA UN PRISIONERO!",
                "status_siege_ready": "ğŸ¯ {army}: ASEDIO LISTO, PULSA LA FORTALEZA.",
                "status_sacrifice": "ğŸ”¥ {army}: Â¡SACRIFICIO! DEBE SALVAR UNA PIEZA.",
                "status_chusma": "âš¡ BONIFICACIÃ“N CHUSMA: Mueve otra Chusma o haz click para terminar.",
                "status_check": "âš ï¸ Â¡JAQUE! {army} âš ï¸",
                "status_surrounded": "ğŸ›¡ï¸ {army}: Â¡ALERTA! FORTALEZA RODEADA.",

                // Unidades y Colores
                "rey": "REY", "chusma": "CHUSMA", "lanceros": "LANCERO", "arqueros": "ARQUERO",
                "c_ligera": "C. LIGERA", "c_pesada": "C. PESADA", "elefante": "ELEFANTE",
                "dragon": "DRAGÃ“N", "trabuquete": "TRABUQUETE", "escorpion": "ESCORPIÃ“N",
                "fortaleza": "FORTALEZA", "montana": "MONTAÃ‘A"
            },
            en: {
                "north": "NORTHERN ARMY",
                "south": "SOUTHERN ARMY",
                "rojo": "RED",
                "negro": "BLACK",
                "DE ROJO": "RED ARMY",
                "DE NEGRO": "BLACK ARMY",

                "init": "Choose your destiny: Drag a Fortress to start. Hover for Visual Aid.",
                "turn_part": "Turn",
                "deploy_phase": "Deployment Phase",
                "dungeon_title": "DUNGEON",

                "msg_valid": "Valid Move",
                "msg_invalid": "Invalid Move",
                "err_check": "âš ï¸ CHECK âš ï¸",

                "water": "WATER ğŸŒŠ",
                "fortress": "FORTRESS ğŸ°",
                "mountain": "MOUNTAIN ğŸ”ï¸",
                "occupied": "OCCUPIED",
                "limits": "ğŸš«OUT OF BOUNDS",
                "siege_only": "ğŸ”’ You can only move units besieging the fortress.",
                "deploy_fort": "ğŸš« Deployment only at Fortress.",
                "invalid_cell": "ğŸš« Invalid tile.",
                "save_king": "ğŸ‘‘ Save the KING!",
                "death_zone": "â›” Death zone!",
                "only_near": "â›” Only next to your Fortress.",
                "no_water": "â›” Not on water.",
                "zone_occ": "â›” Zone occupied.",
                "illegal": "â›” Illegal move",
                "check_alert": "âš ï¸ YOU ARE IN CHECK! You must save the King.",
                "suicide": "â›” Invalid move: King would be exposed.",
                "relay": "ğŸ”„ Lancer Relay",
                "ally": "â›” Ally tile.",
                "shot": "ğŸ”¥ SHOT!",
                "capture": "âš”ï¸ CAPTURE!",
                "siege_cancel": "ğŸ³ï¸ Siege canceled.",
                "first_fort": "ğŸš« You must build the FORTRESS first",
                "zone_forbid": "ğŸš« Forbidden Zone.",
                "deploy_near": "ğŸ›¡ï¸ Deploy next to the Fortress",
                "no_fit": "It doesn't fit here!",
                "pos_invalid": "ğŸ° Invalid position",
                "turn_j1": "âš ï¸ PLAYER 1 Turn",
                "turn_j2": "âš ï¸ PLAYER 2 Turn",
                "relocated": "Unit relocated",
                "fort_set": "ğŸ° Fortress established.",
                "elephant_fail": "ğŸ˜ IMPOSSIBLE! Attack insufficient. Need 2+ units threatening the Elephant.",

                "siege_use_reserve": "âš ï¸ You must take a piece from the RESERVE.",
                "mountains_left": "âš ï¸ You must place all MOUNTAINS before finishing.",
                "mountains_start": "âš ï¸ You must place all MOUNTAINS before starting.",
                "fort_reset": "ğŸ° Reset: Fortress removed. You can switch sides.",
                "fort_soft": "â†©ï¸ Fortress removed. (Your mountains remain).",
                "fort_retry": "â†©ï¸ Fortress removed. You can place it again.",
                "rescue_fail": "â›” Need more troops surrounding Enemy Fortress.",
                "rescue_empty": "ğŸš EPIC RESCUE! The enemy fortress was empty.",
                "siege_end": "ğŸ”„ Siege ended. Troops return to RESERVE.",
                "fort_empty": "ğŸ“­ Fortress empty. Siege over.",
                "status_win": "ğŸ‘‘ VICTORY FOR {army} ARMY",
                "status_draw": "ğŸ GAME OVER: DRAW (STALEMATE)",
                "status_gameover": "ğŸ GAME OVER: {reason}. {winner}",
                "reason_mate": "BY CHECKMATE",
                "reason_stalemate": "STALEMATE",

                "debug_confirm": "âš ï¸ ACTIVATE DEBUG MODE?\nThe game will restart with a legal random deployment.",
                "debug_active": "ğŸ› ï¸ DEBUG MODE: Legal Deployment Completed",
                "click_siege": "CLICK TO EXECUTE SIEGE",
                "click_pass": "CLICK TO PASS TURN",
                "click_rescue": "CLICK TO RESCUE AND EXECUTE SIEGE",
                "help_visualizing": "ğŸ’¡ Visualizing {count} possible moves...",
                "help_blocked": "ğŸš« {unit}: NO MOVES POSSIBLE (BLOCKED)",
                "occupied_simple": "â›” Tile occupied",
                "water_error": "ğŸŒŠ Not on water!",
                "water_simple": "â›” Water.",
                "mountain_simple": "â›” Mountain.",
                "fortress_simple": "â›” Fortress.",
                "fortress_first_short": "âš ï¸ FORTRESS first.",

                // --- COMPOSITE MESSAGES (NEW) ---
                "msg_siege_break": "ğŸ”¥ Siege broken. {count} captured.",
                "msg_reinforcements": "ğŸ†• Reinforcements: {unit}",
                "msg_return_reserve": "â†©ï¸ {unit} returned to reserve.",
                "msg_p1_control": "P1: {color} controls the {zone}.",
                "msg_deployed": "Deployed: {unit}",
                "msg_p1_finish": "âœ… P1 Deployment Finished. PLAYER 2 Turn ({color}).",
                "msg_game_start": "GAME START! {color} Turn",
                "msg_rescued": "ğŸ”“ {unit} rescued. Prisoner and troops return to RESERVE.",
                "no_exchange": "ğŸš« No exchange: {count} units captured in reserve.",

                // ... (other keys)
                "status_prisoner": "ğŸ”“ {army}: DEFENSE FAILED, SELECT PRISONER!",
                "status_siege_ready": "ğŸ¯ {army}: SIEGE READY, CLICK FORTRESS!",
                "status_sacrifice": "ğŸ”¥ {army}: SACRIFICE! SAVE ONE UNIT.",
                "status_chusma": "âš¡ RABBLE BONUS: Move another or click to finish.",
                "status_check": "âš ï¸ CHECK! {army} âš ï¸",
                "status_surrounded": "ğŸ›¡ï¸ {army}: ALERT! FORTRESS SURROUNDED.",

                "rey": "KING", "chusma": "RABBLE", "lanceros": "LANCER", "arqueros": "ARCHER",
                "c_ligera": "LT. CAVALRY", "c_pesada": "HVY. CAVALRY", "elefante": "ELEPHANT",
                "dragon": "DRAGON", "trabuquete": "TREBUCHET", "escorpion": "SCORPION",
                "fortaleza": "FORTRESS", "montana": "MOUNTAIN"
            },
            ru: {
                // Ğ˜Ğ¼ĞµĞ½Ğ° ĞÑ€Ğ¼Ğ¸Ğ¹
                "north": "Ğ¡Ğ•Ğ’Ğ•Ğ ĞĞĞ¯ ĞĞ ĞœĞ˜Ğ¯",
                "south": "Ğ®Ğ–ĞĞĞ¯ ĞĞ ĞœĞ˜Ğ¯",
                "rojo": "ĞšĞ ĞĞ¡ĞĞ«Ğ™",
                "negro": "Ğ§Ğ•Ğ ĞĞ«Ğ™",
                "DE ROJO": "ĞšĞ ĞĞ¡ĞĞĞ™ ĞĞ ĞœĞ˜Ğ˜",
                "DE NEGRO": "Ğ§Ğ•Ğ ĞĞĞ™ ĞĞ ĞœĞ˜Ğ˜",

                // Textos Generales
                "init": "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: ĞĞ°Ñ‡Ğ½Ğ¸Ñ‚Ğµ Ñ Ñ€Ğ°Ğ·Ğ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚Ğ¸.",
                "turn_part": "Ğ¥Ğ¾Ğ´",
                "deploy_phase": "Ğ¤Ğ°Ğ·Ğ° Ğ Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ",
                "dungeon_title": "Ğ¢Ğ•ĞœĞĞ˜Ğ¦Ğ",

                // Mensajes de Juego
                "msg_valid": "Ğ’ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ…Ğ¾Ğ´",
                "msg_invalid": "ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ñ…Ğ¾Ğ´",
                "err_check": "âš ï¸ Ğ¨ĞĞ¥ âš ï¸",

                // Errores y Notas
                "water": "Ğ’ĞĞ”Ğ ğŸŒŠ",
                "fortress": "ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬ ğŸ°",
                "mountain": "Ğ“ĞĞ Ğ ğŸ”ï¸",
                "occupied": "Ğ—ĞĞĞ¯Ğ¢Ğ",
                "limits": "ğŸš« Ğ—Ğ ĞŸĞ Ğ•Ğ”Ğ•Ğ›ĞĞœĞ˜",
                "siege_only": "ğŸ”’ ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ²Ğ¸Ğ³Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾ÑĞ°Ğ´Ğ½Ñ‹Ğµ Ğ²Ğ¾Ğ¹ÑĞºĞ°.",
                "deploy_fort": "ğŸš« Ğ Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñƒ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚Ğ¸.",
                "invalid_cell": "ğŸš« ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ ĞºĞ»ĞµÑ‚ĞºĞ°.",
                "save_king": "ğŸ‘‘ Ğ¡Ğ¿Ğ°ÑĞ¸Ñ‚Ğµ ĞšĞĞ ĞĞ›Ğ¯!",
                "death_zone": "â›” Ğ¡Ğ¼ĞµÑ€Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ·Ğ¾Ğ½Ğ°!",
                "only_near": "â›” Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ñ€ÑĞ´Ğ¾Ğ¼ Ñ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒÑ.",
                "no_water": "â›” ĞĞµ Ğ² Ğ²Ğ¾Ğ´Ñƒ.",
                "zone_occ": "â›” Ğ—Ğ¾Ğ½Ğ° Ğ·Ğ°Ğ½ÑÑ‚Ğ°.",
                "illegal": "â›” ĞĞµĞ»ĞµĞ³Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ñ…Ğ¾Ğ´",
                "check_alert": "âš ï¸ Ğ’ĞĞœ Ğ¨ĞĞ¥! Ğ¡Ğ¿Ğ°ÑĞ°Ğ¹Ñ‚Ğµ ĞšĞ¾Ñ€Ğ¾Ğ»Ñ.",
                "suicide": "â›” ĞĞµĞ»ÑŒĞ·Ñ: ĞšĞ¾Ñ€Ğ¾Ğ»ÑŒ Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿Ğ¾Ğ´ ÑƒĞ´Ğ°Ñ€Ğ¾Ğ¼.",
                "relay": "ğŸ”„ Ğ¡Ğ¼ĞµĞ½Ğ° ĞšĞ¾Ğ¿ĞµĞ¹Ñ‰Ğ¸ĞºĞ°",
                "ally": "â›” ĞšĞ»ĞµÑ‚ĞºĞ° ÑĞ¾ÑĞ·Ğ½Ğ¸ĞºĞ°.",
                "shot": "ğŸ”¥ Ğ’Ğ«Ğ¡Ğ¢Ğ Ğ•Ğ›!",
                "capture": "âš”ï¸ Ğ—ĞĞ¥Ğ’ĞĞ¢!",
                "siege_cancel": "ğŸ³ï¸ ĞÑĞ°Ğ´Ğ° Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½Ğ°.",
                "first_fort": "ğŸš« Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾Ğ¹Ñ‚Ğµ ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬",
                "zone_forbid": "ğŸš« Ğ—Ğ°Ğ¿Ñ€ĞµÑ‚Ğ½Ğ°Ñ Ğ·Ğ¾Ğ½Ğ°.",
                "deploy_near": "ğŸ›¡ï¸ Ğ Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğµ Ñƒ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚Ğ¸",
                "no_fit": "ĞĞµ Ğ¿Ğ¾Ğ¼ĞµÑ‰Ğ°ĞµÑ‚ÑÑ!",
                "pos_invalid": "ğŸ° ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ",
                "turn_j1": "âš ï¸ Ğ¥Ğ¾Ğ´ Ğ˜Ğ“Ğ ĞĞšĞ 1",
                "turn_j2": "âš ï¸ Ğ¥Ğ¾Ğ´ Ğ˜Ğ“Ğ ĞĞšĞ 2",
                "relocated": "Ğ¤Ğ¸Ğ³ÑƒÑ€Ğ° Ğ¿ĞµÑ€ĞµĞ¼ĞµÑ‰ĞµĞ½Ğ°",
                "fort_set": "ğŸ° ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°.",
                "elephant_fail": "ğŸ˜ ĞĞ•Ğ’ĞĞ—ĞœĞĞ–ĞĞ! ĞÑƒĞ¶Ğ½Ğ° Ğ°Ñ‚Ğ°ĞºĞ° 2+ Ñ„Ğ¸Ğ³ÑƒÑ€.",
                "siege_use_reserve": "âš ï¸ Ğ’Ğ¾Ğ·ÑŒĞ¼Ğ¸Ñ‚Ğµ Ñ„Ğ¸Ğ³ÑƒÑ€Ñƒ Ğ¸Ğ· Ğ Ğ•Ğ—Ğ•Ğ Ğ’Ğ.",

                // Final de Partida
                "mountains_left": "âš ï¸ Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚Ğµ Ğ²ÑĞµ Ğ“ĞĞ Ğ« Ğ¿ĞµÑ€ĞµĞ´ Ğ¾ĞºĞ¾Ğ½Ñ‡Ğ°Ğ½Ğ¸ĞµĞ¼ Ñ…Ğ¾Ğ´Ğ°.",
                "mountains_start": "âš ï¸ Ğ Ğ°Ğ·Ğ¼ĞµÑÑ‚Ğ¸Ñ‚Ğµ Ğ²ÑĞµ Ğ“ĞĞ Ğ« Ğ¿ĞµÑ€ĞµĞ´ Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾Ğ¼ Ğ¸Ğ³Ñ€Ñ‹.",
                "fort_reset": "ğŸ° Ğ¡Ğ±Ñ€Ğ¾Ñ: ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ ÑƒĞ±Ñ€Ğ°Ğ½Ğ°. ĞœĞ¾Ğ¶ĞµÑ‚Ğµ Ğ¿Ğ¾Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ñ†Ğ²ĞµÑ‚ ĞÑ€Ğ¼Ğ¸Ğ¸",
                "fort_soft": "â†©ï¸ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ ÑƒĞ±Ñ€Ğ°Ğ½Ğ° (Ğ“Ğ¾Ñ€Ñ‹ Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ).",
                "fort_retry": "â†©ï¸ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ ÑƒĞ±Ñ€Ğ°Ğ½Ğ°. ĞœĞ¾Ğ¶ĞµÑ‚Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ĞµĞµ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾",
                "rescue_fail": "â›” ĞÑƒĞ¶Ğ½Ğ¾ Ğ±Ğ¾Ğ»ÑŒÑˆĞµ Ğ²Ğ¾Ğ¹ÑĞº Ğ´Ğ»Ñ Ğ¾ĞºÑ€ÑƒĞ¶ĞµĞ½Ğ¸Ñ Ğ²Ñ€Ğ°Ğ¶ĞµÑĞºĞ¾Ğ¹ ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ˜ Ğ´Ğ»Ñ ÑĞ¿Ğ°ÑĞµĞ½Ğ¸Ñ.",
                "rescue_empty": "ğŸš Ğ­ĞŸĞ˜Ğ§ĞĞĞ• Ğ¡ĞŸĞĞ¡Ğ•ĞĞ˜Ğ•! Ğ’Ñ€Ğ°Ğ¶ĞµÑĞºĞ°Ñ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ Ğ¿ÑƒÑÑ‚Ğ°.",
                "siege_end": "ğŸ”„ ĞÑĞ°Ğ´Ğ° Ğ¾ĞºĞ¾Ğ½Ñ‡ĞµĞ½Ğ°. Ğ’Ğ¾Ğ¹ÑĞºĞ° Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ÑÑ‚ÑÑ Ğ² Ğ Ğ•Ğ—Ğ•Ğ Ğ’.",
                "fort_empty": "ğŸ“­ ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ Ğ¿ÑƒÑÑ‚Ğ°. ĞšĞ¾Ğ½ĞµÑ† Ğ¾ÑĞ°Ğ´Ñ‹.",

                // Mensajes Compuestos (Plantillas)
                "status_win": "ğŸ‘‘ ĞŸĞĞ‘Ğ•Ğ”Ğ ĞĞ ĞœĞ˜Ğ˜ {army}",
                "status_draw": "ğŸ ĞšĞĞĞ•Ğ¦ Ğ˜Ğ“Ğ Ğ«: ĞĞ˜Ğ§Ğ¬Ğ¯ (ĞŸĞĞ¢)",
                "status_gameover": "ğŸ ĞšĞĞĞ•Ğ¦ Ğ˜Ğ“Ğ Ğ«: {reason}. {winner}",
                "reason_mate": "ĞœĞĞ¢",
                "reason_stalemate": "ĞŸĞĞ¢",
                "msg_siege_break": "ğŸ”¥ ĞÑĞ°Ğ´Ğ° Ğ¿Ñ€Ğ¾Ñ€Ğ²Ğ°Ğ½Ğ°. Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‡ĞµĞ½Ğ¾: {count}.",
                "msg_reinforcements": "ğŸ†• ĞŸĞ¾Ğ´ĞºÑ€ĞµĞ¿Ğ»ĞµĞ½Ğ¸Ğµ: {unit}",
                "msg_return_reserve": "â†©ï¸ {unit} Ğ²ĞµÑ€Ğ½ÑƒĞ»ÑÑ Ğ² Ñ€ĞµĞ·ĞµÑ€Ğ².",
                "msg_p1_control": "Ğ˜Ğ“Ğ ĞĞš: {color} ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»Ğ¸Ñ€ÑƒĞµÑ‚ {zone}.",
                "msg_deployed": "Ğ Ğ°Ğ·Ğ²ĞµÑ€Ğ½ÑƒÑ‚: {unit}",
                "msg_p1_finish": "âœ… Ğ˜Ğ“Ğ ĞĞš Ğ“Ğ¾Ñ‚Ğ¾Ğ². Ğ¥Ğ¾Ğ´ Ğ˜Ğ“Ğ ĞĞšĞ ({color}).",
                "msg_game_start": "Ğ˜Ğ“Ğ Ğ ĞĞĞ§ĞĞ›ĞĞ¡Ğ¬! Ğ¥Ğ¾Ğ´: {color}",
                "msg_rescued": "ğŸ”“ {unit} ÑĞ¿Ğ°ÑĞµĞ½. Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ Ğ² Ğ Ğ•Ğ—Ğ•Ğ Ğ’.",
                "no_exchange": "ğŸš« ĞĞµÑ‚ Ğ¾Ğ±Ğ¼ĞµĞ½Ğ°: {count} Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‡ĞµĞ½Ğ¾ Ğ² Ñ€ĞµĞ·ĞµÑ€Ğ²Ğµ.",

                // Tooltips
                "click_siege": "ĞšĞ›Ğ˜Ğš Ğ”Ğ›Ğ¯ ĞĞ¡ĞĞ”Ğ«",
                "click_pass": "ĞšĞ›Ğ˜Ğš Ğ´Ğ»Ñ ĞŸĞĞ¡Ğ",
                "click_rescue": "ĞšĞ›Ğ˜Ğš Ğ”Ğ›Ğ¯ Ğ¡ĞŸĞĞ¡Ğ•ĞĞ˜Ğ¯ 1 Ğ¤Ğ˜Ğ“Ğ£Ğ Ğ«",
                "help_visualizing": "ğŸ’¡ Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ñ… Ñ…Ğ¾Ğ´Ğ¾Ğ²: {count}...",
                "help_blocked": "ğŸš« {unit}: ĞĞ•Ğ¢ Ğ¥ĞĞ”ĞĞ’ (Ğ—ĞĞ‘Ğ›ĞĞšĞ¢Ğ ĞĞ’ĞĞĞ)",
                "occupied_simple": "â›” Ğ—Ğ°Ğ½ÑÑ‚Ğ¾",
                "water_error": "ğŸŒŠ ĞĞµ Ğ² Ğ²Ğ¾Ğ´Ñƒ!",
                "water_simple": "â›” Ğ’Ğ¾Ğ´Ğ°.",
                "mountain_simple": "â›” Ğ“Ğ¾Ñ€Ğ°.",
                "fortress_simple": "â›” ĞšÑ€ĞµĞ¿Ğ¾ÑÑ‚ÑŒ.",
                "fortress_first_short": "âš ï¸ Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬.",
                "no_fit": "ĞĞµ Ğ²Ğ»ĞµĞ·Ğ°ĞµÑ‚!",

                // Debug
                "debug_confirm": "âš ï¸ Ğ’ĞšĞ›Ğ®Ğ§Ğ˜Ğ¢Ğ¬ ĞĞ¢Ğ›ĞĞ”ĞšĞ£?\nĞ¡Ğ»ÑƒÑ‡Ğ°Ğ¹Ğ½Ğ¾Ğµ Ñ€Ğ°Ğ·Ğ²ĞµÑ€Ñ‚Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğµ.",
                "debug_active": "ğŸ› ï¸ Ğ Ğ•Ğ–Ğ˜Ğœ ĞĞ¢Ğ›ĞĞ”ĞšĞ˜: Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾",

                // ... (Ğ´Ñ€ÑƒĞ³Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ¸)
                "status_prisoner": "ğŸ”“ {army}: ĞĞ‘ĞĞ ĞĞĞ ĞŸĞ ĞĞ Ğ’ĞĞĞ, Ğ’Ğ«Ğ‘Ğ•Ğ Ğ˜Ğ¢Ğ• ĞŸĞ›Ğ•ĞĞĞ˜ĞšĞ!",
                "status_siege_ready": "ğŸ¯ {army}: ĞĞ¡ĞĞ”Ğ Ğ“ĞĞ¢ĞĞ’Ğ, ĞĞĞ–ĞœĞ˜Ğ¢Ğ• ĞĞ ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬!",
                "status_sacrifice": "ğŸ”¥ {army}: Ğ–Ğ•Ğ Ğ¢Ğ’Ğ! Ğ¡ĞŸĞĞ¡Ğ˜Ğ¢Ğ• ĞĞ”ĞĞ£ Ğ¤Ğ˜Ğ“Ğ£Ğ Ğ£.",
                "status_chusma": "âš¡ Ğ‘ĞĞĞ£Ğ¡ Ğ§Ğ•Ğ ĞĞ˜: Ğ¥Ğ¾Ğ´Ğ¸Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğ¹ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ.",
                "status_check": "âš ï¸ Ğ¨ĞĞ¥! {army} âš ï¸",
                "status_surrounded": "ğŸ›¡ï¸ {army}: Ğ¢Ğ Ğ•Ğ’ĞĞ“Ğ! ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬ ĞĞšĞ Ğ£Ğ–Ğ•ĞĞ.",

                // Unidades
                "rey": "ĞšĞĞ ĞĞ›Ğ¬", "chusma": "Ğ§Ğ•Ğ ĞĞ¬", "lanceros": "ĞšĞĞŸĞ•Ğ™Ğ©Ğ˜Ğš", "arqueros": "Ğ›Ğ£Ğ§ĞĞ˜Ğš",
                "c_ligera": "Ğ›Ğ•Ğ“ĞšĞĞ¯ ĞšĞĞ’.", "c_pesada": "Ğ¢Ğ¯Ğ–Ğ•Ğ›ĞĞ¯ ĞšĞĞ’.", "elefante": "Ğ¡Ğ›ĞĞ",
                "dragon": "Ğ”Ğ ĞĞšĞĞ", "trabuquete": "Ğ¢Ğ Ğ•Ğ‘Ğ£Ğ¨Ğ•Ğ¢", "escorpion": "Ğ¡ĞšĞĞ ĞŸĞ˜ĞĞ",
                "fortaleza": "ĞšĞ Ğ•ĞŸĞĞ¡Ğ¢Ğ¬", "montana": "Ğ“ĞĞ Ğ"
            }
        };

        // FunciÃ³n mÃ¡gica: Busca el texto espaÃ±ol y devuelve el inglÃ©s
        function autoTranslate(text) {
            if ((currentLang || 'es') === 'es') return text; // Si estamos en espaÃ±ol, no hacer nada

            // 1. BÃºsqueda Inversa: Â¿Existe este texto exacto en MESSAGES.es?
            const esKeys = Object.keys(MESSAGES.es);
            const foundKey = esKeys.find(key => MESSAGES.es[key] === text);

            if (foundKey) {
                return MESSAGES.en[foundKey];
            }

            // Si no lo encuentra (por ejemplo, tiene variables), devuelve el original
            return text;
        }

        // FunciÃ³n manual (para los casos con variables)
        function t(key, params = {}) {
            const lang = currentLang || 'es';
            let text = MESSAGES[lang][key] || MESSAGES['es'][key] || key;
            for (const [k, v] of Object.entries(params)) {
                text = text.replace(`{${k}}`, v);
            }
            return text;
        }

        // --- FUNCIONES DE HOVER ACTUALIZADAS ---

        function handleUnitHover(type, army, r, c) {
            if (draggingMeta) return;

            // PROTECCIÃ“N: Si la partida terminÃ³, no tapamos el resultado
            if (gameState === 'game-over') return;

            // 1. Timer de ApariciÃ³n (1 segundo)
            if (hoverTimer) clearTimeout(hoverTimer);

            // Si ya habÃ­a un timer de auto-cierre corriendo, lo limpiamos para reiniciar el ciclo
            if (infoDisplayTimer) clearTimeout(infoDisplayTimer);

            hoverTimer = setTimeout(() => {
                if (!draggingMeta) {
                    const bar = document.getElementById('status-bar');
                    const lang = currentLang || 'es';
                    const dict = UNIT_INFO[lang] || UNIT_INFO['es'];
                    const info = dict[type] || type.toUpperCase();

                    // Mostramos la info
                    bar.innerText = `â„¹ï¸ ${info}`;
                    bar.style.color = '#3498db';
                    bar.classList.remove('status-critical');

                    // --- NUEVO: AUTO-CIERRE DE LA AYUDA ---
                    // Tras 4 segundos, restauramos el mensaje prioritario (Asedio/Jaque/Turno)
                    // aunque el ratÃ³n siga encima de la unidad.
                    infoDisplayTimer = setTimeout(() => {
                        updateStatusBar();
                    }, 4000);
                }
            }, 1000);

            // 2. Timer de Tablero (3 segundos) - Luces verdes
            const isMyPiece = (gameState === 'playing' && army === turnColor);

            if (boardHelpTimer) clearTimeout(boardHelpTimer);

            if (isMyPiece) {
                boardHelpTimer = setTimeout(() => {
                    if (!draggingMeta) {
                        activateBoardHelp(r, c, type, army);
                    }
                }, 3000);
            }
        }

        function handleUnitLeave() {
            // Limpiamos TODOS los timers
            if (hoverTimer) clearTimeout(hoverTimer);
            if (boardHelpTimer) clearTimeout(boardHelpTimer);
            if (infoDisplayTimer) clearTimeout(infoDisplayTimer); // <--- IMPORTANTE

            clearGhosts();

            if (!draggingMeta) {
                updateStatusBar(); // Restaura el texto original inmediatamente al salir
            }
        }

        // --- LÃ“GICA DE AYUDA VISUAL (3 SEGUNDOS) CON CONTADOR ---
        function activateBoardHelp(originR, originC, type, army) {
            if (draggingMeta) return;

            // 1. Contador de movimientos vÃ¡lidos encontrados
            let validMovesCount = 0;

            // Recorremos las 100 casillas
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    if (r === originR && c === originC) continue;

                    // Filtros de validez geomÃ©trica y obstaculos fÃ­sicos
                    if (isValidMove(type, originR, originC, r, c)) {

                        const target = logicBoard[r][c];
                        const isMountain = target && target.type === 'montana';
                        const isFortress = target && target.type === 'fortaleza';
                        // Lanceros pueden hacer relevo, el resto no puede comerse aliados
                        const isAlly = target && target.army === army && type !== 'lanceros';
                        // Agua bloquea salvo voladores/anfibios
                        const isWater = terrain[r][c] === 'water' && type !== 'trabuquete' && type !== 'escorpion' && type !== 'dragon';

                        if (isMountain || isFortress || isAlly || isWater) {
                            continue;
                        }

                        // ValidaciÃ³n de seguridad (Jaque)
                        let isSafe = true;
                        if (gameState === 'playing') {
                            try {
                                isSafe = isSimulatedMoveSafe(type, originR, originC, r, c, army);
                            } catch (e) { console.warn(e); }
                        }

                        // Pintar y CONTAR
                        const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                        if (tile) {
                            if (isSafe) {
                                tile.classList.add('ghost-valid'); // Verde
                                validMovesCount++; // <--- SUMAMOS MOVIMIENTO VÃLIDO
                            } else {
                                tile.classList.add('ghost-invalid'); // Rojo (Suicidio)
                                // No sumamos al contador porque no es un movimiento legal
                            }
                        }
                    }
                }
            }

            // 2. Feedback al usuario segÃºn el resultado
            // Primero traducimos el nombre de la unidad para el mensaje
            const unitName = t(type).toUpperCase(); // <--- TRADUCCIÃ“N AÃ‘ADIDA

            if (validMovesCount === 0) {
                showNotification(t('help_blocked', { unit: unitName }), true);
            } else {
                showNotification(t('help_visualizing', { count: validMovesCount }));
            }
        }


        // Estado del juego: 'init', 'deploy-p1', 'deploy-p2', 'playing'
        let gameState = 'init';
        let p1Color = null;
        let p2Color = null;
        let p1Territory = null; // 'north' (filas 0-4) o 'south' (filas 5-9)
        let turnColor = null; // 'rojo' o 'negro'


        // --- 0. INTERFAZ DE AYUDA ---
        let currentLang = 'en';

        function toggleRules() {
            const modal = document.getElementById("rulesModal");
            modal.style.display = (modal.style.display === "block") ? "none" : "block";
        }

        function toggleLanguage() {
            const es = document.getElementById('rules-es');
            const en = document.getElementById('rules-en');
            const btn = document.getElementById('langToggleBtn');
            const title = document.getElementById('rules-title');

            if (currentLang === 'es') {
                es.style.display = 'none';
                en.style.display = 'block';
                btn.innerText = 'Leer en EspaÃ±ol';
                title.innerText = 'ğŸ“œ COTADREZ RULES';
                currentLang = 'en';
            } else {
                es.style.display = 'block';
                en.style.display = 'none';
                btn.innerText = 'Read in English';
                title.innerText = 'ğŸ“œ REGLAMENTO';
                currentLang = 'es';
            }

            // --- NUEVO: Actualizar etiquetas de Mazmorra ---
            document.querySelectorAll('.dungeon-label').forEach(el => {
                el.innerText = t('dungeon_title');
            });
            // -----------------------------------------------

            updateStatusBar();
            // TambiÃ©n limpiamos cualquier tooltip que hubiera quedado
            if (boardHelpTimer) clearTimeout(boardHelpTimer);
        }

        // Cerrar al hacer clic fuera del modal
        window.onclick = function (event) {
            const modal = document.getElementById("rulesModal");
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        // --- 2. INICIALIZACIÃ“N ---
        function init() {
            console.log("Inicializando sistema...");

            // 1. Llenar las reservas con las cantidades iniciales
            for (const [type, data] of Object.entries(CONFIG.pieces)) {
                reserves.rojo[type] = data.qty;
                reserves.negro[type] = data.qty;
            }

            // 2. Inicializar grÃ¡ficos
            initWater();
            renderBoard();
            updateInventories();
            updateDungeons();
            document.getElementById('status-bar').innerText = getStatusText();
        }
        function initWater() {
            const waterCoords = [[3, 1], [1, 3]]; // b4, d2
            waterCoords.forEach(([r, c]) => {
                terrain[r][c] = 'water'; terrain[r][9 - c] = 'water';
                terrain[9 - r][c] = 'water'; terrain[9 - r][9 - c] = 'water';
            });
        }

        // --- 3. RENDERIZADO BÃSICO ---

        function renderBoard() {
            const b = document.getElementById('board');
            b.innerHTML = '';

            // --- COLOR DEL BORDE SEGÃšN TURNO ---
            let borderColor = '#34495e'; // Color neutro por defecto (Azul grisÃ¡ceo oscuro)

            // Definimos el color oscuro manual para que destaque sobre el neutro
            const darkBorder = '#111111'; // <--- CORRECCIÃ“N: Gris casi negro

            if (gameState === 'deploy-p1') {
                borderColor = (p1Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'deploy-p2') {
                borderColor = (p2Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            // AÃ‘ADIMOS: ConfirmaciÃ³n, SelecciÃ³n de Prisionero y Bonus de Chusma
            else if (gameState === 'playing' ||
                gameState === 'siege-resolution' ||
                gameState === 'siege-confirmation' ||
                gameState === 'siege-prisoner-select' ||
                gameState === 'playing-chusma-bonus') {

                borderColor = (turnColor === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            b.style.borderColor = borderColor;
            // ------------------------------------------

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    // --- NUEVO: PINTAR RASTRO DE DISPARO (Diferenciando Origen/Destino) ---
                    const shot = shotHighlights.find(h => h.r === r && h.c === c);
                    if (shot) {
                        if (shot.type === 'source') tile.classList.add('shot-source'); // Dorado
                        else tile.classList.add('shot-highlight'); // Oscuro
                    }

                    tile.ondragover = (e) => handleDragOver(e, r, c);
                    tile.ondrop = (e) => handleDrop(e, r, c);

                    if (terrain[r][c] === 'water') {
                        tile.classList.add('water');
                    }

                    // Pintar pieza
                    const piece = logicBoard[r][c];
                    let isVisible = true;

                    // Niebla de Guerra
                    if (piece && gameState === 'deploy-p2' && piece.army === p1Color) {
                        isVisible = false;
                    }

                    if (piece && isVisible) {
                        const img = document.createElement('img');
                        img.src = getImgUrl(piece.army, piece.type);
                        img.className = 'piece';

                        // --- NUEVO: Eventos de Hover ---
                        img.onmouseenter = () => handleUnitHover(piece.type, piece.army, r, c);
                        img.onmouseleave = () => handleUnitLeave();


                        // --- LÃ“GICA DE PARPADEO DE FORTALEZA ---
                        if (piece.type === 'fortaleza') {
                            // 1. Fase de ConfirmaciÃ³n (Turno Atacante): La fortaleza enemiga es clickable
                            if (gameState === 'siege-confirmation' && piece.army !== turnColor) {
                                img.classList.add('siege-pulse');
                                img.onclick = () => executeConfirmedSiege(turnColor, piece.army);
                                img.title = t('click_siege');
                            }
                            // 2. Fase Normal (Turno Defensor): Si MI fortaleza estÃ¡ asediada, parpadea
                            // Usamos siegeStatus[piece.army] para saber si ESTA fortaleza concreta sufre asedio
                            else if (siegeStatus[piece.army] === true) {
                                img.classList.add('siege-pulse');
                            }
                        }

                        // --- GESTIÃ“N DE ARRASTRE Y CLICKS ---
                        let canDrag = true;

                        // Bloqueos estÃ¡ndar
                        if (piece.type === 'fortaleza') canDrag = false;
                        if (gameState.startsWith('playing') && piece.type === 'montana') canDrag = false; // startWith para pillar ambos estados
                        if (gameState.includes('deploy')) {
                            const myColor = (gameState === 'deploy-p1') ? p1Color : p2Color;
                            if (piece.army !== myColor) canDrag = false;
                        }

                        // LÃ“GICA ESPECIAL: MEDIO TURNO DE CHUSMA
                        if (gameState === 'playing-chusma-bonus') {
                            // Si es la chusma que acabamos de mover -> NO DRAG, SÃ CLICK
                            if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                                canDrag = false;
                                img.style.cursor = "pointer"; // Dedo para hacer click
                                img.title = t('click_pass');
                                img.onclick = () => finishChusmaBonusTurn();
                                // Efecto visual para destacar que estÃ¡ esperando
                                img.style.filter = "drop-shadow(0 0 5px var(--c-gold)) brightness(1.2)";
                            }
                            // El resto de piezas no-chusma se bloquean en handleDragStart, 
                            // pero visualmente podemos quitarles el drag aquÃ­ si quieres pulirlo mÃ¡s.
                        }

                        // Asignar draggable
                        img.draggable = canDrag;
                        if (canDrag) {
                            img.ondragstart = (e) => handleDragStart(e, 'board', piece.army, piece.type, r, c);

                            img.ondragend = () => {
                                clearRingHighlights();
                                clearGhosts();
                                lastHoveredTile = null;
                                updateStatusBar(); // Restaurar texto original
                            };

                            img.style.cursor = "grab";
                        } else if (!img.onclick) {
                            // Si no es arrastrable ni tiene onclick especial (como la chusma o fortaleza)
                            img.style.cursor = "default";
                        }

                        // --- GESTIÃ“N DE CLICS DE FORTALEZAS (Mantenemos tu cÃ³digo anterior aquÃ­) ---
                        if (piece.type === 'fortaleza') {
                            // ... (Tu cÃ³digo de finishTurnP1 / P2 / Asedio sigue igual) ...
                            if (gameState === 'deploy-p1' && piece.army === p1Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP1();
                            } else if (gameState === 'deploy-p2' && piece.army === p2Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP2();
                            } else if (gameState.startsWith('playing') && piece.army !== turnColor) {
                                // ... (LÃ³gica de asedio si la tienes implementada) ...
                            }
                        }

                        tile.appendChild(img);
                    }

                    b.appendChild(tile);
                }
            }

            // --- EASTER EGG: BotÃ³n Invisible de Debug ---
            const egg = document.createElement('div');
            egg.className = 'debug-egg';
            egg.title = "v5.2"; // Pista sutil si dejas el ratÃ³n quieto

            // Usamos DOBLE CLICK para evitar accidentes durante la partida
            egg.ondblclick = () => activateDebugMode();

            b.appendChild(egg);

        }

        // Devuelve 'north' (filas 0-4) o 'south' (filas 5-9)
        function getTerritory(r) {
            return r < 5 ? 'north' : 'south';
        }



        // Verifica si una casilla estÃ¡ en el "Anillo de Salida" (perÃ­metro adyacente)

        function isInExitZone(r, c, fOrigin) {
            if (!fOrigin) return false;

            // La fortaleza ocupa (fr, fc) hasta (fr+1, fc+1)
            // El anillo va desde (fr-1, fc-1) hasta (fr+2, fc+2)
            const minR = fOrigin.r - 1;
            const maxR = fOrigin.r + 2;
            const minC = fOrigin.c - 1;
            const maxC = fOrigin.c + 2;

            // 1. Debe estar dentro del rectÃ¡ngulo exterior
            if (r >= minR && r <= maxR && c >= minC && c <= maxC) {
                // 2. Pero NO debe ser la propia fortaleza (el hueco central)
                if (r >= fOrigin.r && r <= fOrigin.r + 1 && c >= fOrigin.c && c <= fOrigin.c + 1) {
                    return false; // Es la propia estructura
                }
                return true; // Es el anillo
            }
            return false;
        }

        // Arrancar
        init();

        // Construye la URL de la imagen segÃºn el bando y el tipo
        function getImgUrl(army, type) {
            const folder = army === 'rojo' ? 'Rojo' : 'Negro';
            const filename = CONFIG.pieces[type].file;
            return `${CONFIG.repo}/${folder}/${filename}`;
        }

        // Dibuja las piezas en los paneles laterales (Con efecto de desactivado)
        function updateInventories() {
            ['rojo', 'negro'].forEach(army => {
                const list = document.getElementById(`inv-${army}`);
                list.innerHTML = '';

                // --- 1. Determinar si este ejÃ©rcito estÃ¡ ACTIVO ---
                let isActive = true; // En 'init' ambos estÃ¡n activos

                if (gameState === 'deploy-p1') {
                    isActive = (army === p1Color);
                } else if (gameState === 'deploy-p2') {
                    isActive = (army === p2Color);
                } else if (gameState === 'game-over') {
                    isActive = false; // Nadie mueve al final
                } else if (gameState !== 'init') {
                    // Para cualquier fase de juego (playing, siege, etc.)
                    isActive = (army === turnColor);
                }
                // --------------------------------------------------

                for (const [type, data] of Object.entries(CONFIG.pieces)) {
                    const count = reserves[army][type];

                    if (count > 0) {
                        const item = document.createElement('div');
                        item.className = 'inv-item';

                        const img = document.createElement('img');
                        img.src = getImgUrl(army, type);

                        // --- NUEVO: Eventos de Hover en Reserva ---
                        img.onmouseenter = () => handleUnitHover(type);
                        img.onmouseleave = () => handleUnitLeave();

                        // --- 2. Aplicar propiedades segÃºn estado ---
                        if (isActive) {
                            img.draggable = true;
                            img.style.cursor = "grab";
                            img.style.filter = "none"; // Normal
                            img.style.opacity = "1";

                            img.ondragstart = (e) => handleDragStart(e, 'reserve', army, type);
                            img.ondragend = () => {
                                clearRingHighlights();
                                lastHoveredTile = null;
                                updateStatusBar(); // Restaurar texto original
                            };
                        } else {
                            img.draggable = false;
                            img.style.cursor = "not-allowed"; // Icono de prohibido
                            // Efecto visual: Escala de grises y semitransparente
                            img.style.filter = "grayscale(100%)";
                            img.style.opacity = "0.3";
                        }
                        // -------------------------------------------

                        item.appendChild(img);

                        if (count > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'inv-badge';
                            badge.innerText = count;

                            // TambiÃ©n apagamos el badge visualmente si estÃ¡ inactivo
                            if (!isActive) badge.style.filter = "grayscale(100%)";

                            item.appendChild(badge);
                        }
                        list.appendChild(item);
                    }
                }
            });
        }

        // --- 4. LÃ“GICA DE ARRASTRAR Y SOLTAR ---

        function handleDragStart(e, source, army, type, r = null, c = null) {

            if (hoverTimer) clearTimeout(hoverTimer);
            if (boardHelpTimer) clearTimeout(boardHelpTimer);
            clearGhosts();

            // --- LÃ“GICA DE JUEGO Y MEDIO TURNO ---
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus') {

                if (gameState === 'game-over') { e.preventDefault(); return; }

                if (gameState === 'siege-confirmation') {
                    if (army !== turnColor) { e.preventDefault(); return; }
                    // Solo permitimos mover si la pieza es parte del asedio (estÃ¡ en el anillo enemigo)
                    const enemyFort = fortressPos[(army === 'rojo') ? 'negro' : 'rojo'];
                    if (!isInExitZone(r, c, enemyFort)) {
                        showNotification(t('siege_only'));
                        e.preventDefault();
                        return;
                    }
                }

                if (army !== turnColor) { e.preventDefault(); return; }

                // RESTRICCIONES DEL MEDIO TURNO (BONUS CHUSMA)
                if (gameState === 'playing-chusma-bonus') {
                    // 1. Solo se puede mover otra CHUSMA
                    if (type !== 'chusma') {
                        e.preventDefault(); return;
                    }
                    // 2. Solo piezas del TABLERO (Reserva bloqueada)
                    if (source !== 'board') {
                        e.preventDefault(); return;
                    }
                    // 3. NO se puede mover la misma unidad dos veces
                    if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                        e.preventDefault(); return;
                    }
                }
            }

            // CALCULAR MAPAS DE INFLUENCIA (Solo si no estamos en fase 'init')
            if (gameState !== 'init') {
                const enemy = (army === 'rojo') ? 'negro' : 'rojo';
                currentThreatMap = getThreatMap(enemy); // Para que mi Rey no se suicide
                currentAttackMap = getThreatMap(army);  // Para coordinar ataques (Elefante)
            } else {
                currentThreatMap = null;
                currentAttackMap = null;
            }
            // 1. Guardamos metadatos (AÃ‘ADIDO: coordenadas de origen)
            draggingMeta = {
                type: type,
                army: army,
                source: source,
                originR: r, // <--- NUEVO
                originC: c  // <--- NUEVO
            };

            // 2. Datos estÃ¡ndar para el Drop
            const data = { source, army, type, originR: r, originC: c };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';

            // --- NUEVO: RESALTAR ANILLO SI VIENE DE RESERVA ---
            // (La lÃ³gica estÃ¡ DENTRO de la funciÃ³n, antes de la llave de cierre)
            if (source === 'reserve' && type !== 'montana') {
                highlightFortressRing(army);
            }
        }

        // 2. Permitir soltar (El navegador bloquea por defecto, hay que prevenirlo)
        // FunciÃ³n auxiliar para limpiar fantasmas previos
        function clearGhosts() {
            document.querySelectorAll('.ghost-valid, .ghost-invalid').forEach(el => {
                el.classList.remove('ghost-valid', 'ghost-invalid');
            });
        }

        // Nueva funciÃ³n DragOver con lÃ³gica de visualizaciÃ³n

        function handleDragOver(e, r, c) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!draggingMeta) return;

            let isValid = true;
            let specialMessage = "";
            let cells = [];

            clearGhosts();

            if (gameState === 'playing' || gameState === 'siege-confirmation' || gameState === 'playing-chusma-bonus') {
                const target = logicBoard[r][c];
                const type = draggingMeta.type;
                const army = draggingMeta.army;
                const source = draggingMeta.source;

                // --- TRADUCCIÃ“N AQUÃ ---
                if (terrain[r][c] === 'water') { isValid = false; specialMessage = t('water'); }
                if (target && target.type === 'fortaleza') { isValid = false; specialMessage = t('fortress'); }
                if (target && target.type === 'montana') { isValid = false; specialMessage = t('mountain'); }

                if (source === 'reserve') {
                    const fOrigin = fortressPos[army];
                    if (!isInExitZone(r, c, fOrigin)) isValid = false;
                    if (target !== null) isValid = false;
                } else {
                    // 1. ValidaciÃ³n GeomÃ©trica
                    if (!isValidMove(type, draggingMeta.originR, draggingMeta.originC, r, c)) {
                        isValid = false;
                        // Dejamos el mensaje por defecto (Movimiento Ilegal)
                    }

                    // 2. ValidaciÃ³n de OcupaciÃ³n (Si la geometrÃ­a era vÃ¡lida)
                    if (isValid && target) {
                        if (target.army === army && type !== 'lanceros') {
                            isValid = false;
                            specialMessage = t('occupied'); // <--- AHORA TE AVISARÃ ESPECÃFICAMENTE
                        }
                    }
                }
                cells = [{ r: r, c: c }];
            }
            else {
                // FASE DESPLIEGUE
                const army = draggingMeta.army;
                const type = draggingMeta.type;
                const isFortress = (type === 'fortaleza');
                const fOrigin = fortressPos[army];
                const hasFortress = fOrigin !== null;
                const isMountain = (type === 'montana');

                cells = [];
                if (isFortress) {
                    if (r + 1 > 9 || c + 1 > 9) {
                        isValid = false;
                        specialMessage = t('limits'); // TRADUCCIÃ“N
                        cells = [{ r: r, c: c }];
                    } else {
                        cells.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                    }
                } else {
                    cells.push({ r: r, c: c });
                }

                if (!isFortress && !hasFortress) isValid = false;

                // ValidaciÃ³n 2: Â¿EstÃ¡s en tu territorio?
                let isWrongTerritory = false; // <--- NUEVA LÃNEA 1: Bandera de control
                if (p1Territory) {
                    const rowTerritory = getTerritory(r);
                    const myZone = (army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                    if (rowTerritory !== myZone) {
                        isValid = false;
                        isWrongTerritory = true; // <--- NUEVA LÃNEA 2: Marcamos que estamos fuera
                    }
                }

                if (!isFortress && !isMountain && hasFortress) {
                    if (isValid && !isInExitZone(r, c, fOrigin)) isValid = false;
                }

                if (isFortress) {
                    const invalidRows = [0, 4, 5, 9];
                    const invalidCols = [0, 9];
                    if (invalidRows.includes(r) || invalidRows.includes(r + 1)) isValid = false;
                    if (invalidCols.includes(c) || invalidCols.includes(c + 1)) isValid = false;
                }

                for (let cell of cells) {
                    if (terrain[cell.r][cell.c] === 'water' && !isFortress) {
                        isValid = false; specialMessage = t('water'); // TRADUCCIÃ“N
                    }
                    if (logicBoard[cell.r][cell.c] !== null) {
                        isValid = false;
                        // SOLO mostramos el mensaje si estamos en nuestro territorio.
                        // Si estamos fuera, dejamos el mensaje genÃ©rico para no dar pistas.
                        if (!isWrongTerritory) specialMessage = t('occupied');
                    }
                }
            }

            if (isValid && gameState.startsWith('playing') && draggingMeta.source === 'board') {
                try {
                    if (!isSimulatedMoveSafe(draggingMeta.type, draggingMeta.originR, draggingMeta.originC, r, c, draggingMeta.army)) {
                        isValid = false;
                        specialMessage = t('err_check'); // TRADUCCIÃ“N
                    }
                } catch (err) { }
            }

            const className = isValid ? 'ghost-valid' : 'ghost-invalid';
            cells.forEach(cell => {
                const tile = document.querySelector(`.tile[data-r="${cell.r}"][data-c="${cell.c}"]`);
                if (tile) tile.classList.add(className);
            });

            const currentTileId = `${r}-${c}`;
            lastHoveredTile = currentTileId;

            const coordName = getCoordinateName(r, c);
            const statusIcon = isValid ? "âœ…" : "â›”";
            // TRADUCCIÃ“N FINAL
            const detailText = specialMessage ? specialMessage : (isValid ? t('msg_valid') : t('msg_invalid'));

            const bar = document.getElementById('status-bar');
            bar.innerText = `${coordName} ${detailText} ${statusIcon}`;
            bar.style.color = isValid ? '#2ecc71' : '#e74c3c';
            bar.classList.remove('status-critical');
            bar.style.opacity = 1;
        }

        //             // 3. Al soltar en una casilla

        function handleDrop(e, r, c) {
            e.preventDefault();

            // --- CORRECCIÃ“N VISUAL: Limpieza TOTAL al soltar cualquier cosa ---
            lastHoveredTile = null;
            updateStatusBar();
            clearRingHighlights();
            clearGhosts();
            shotHighlights = []; // <--- ESTO ARREGLA EL RASTRO DEL TRABUQUETE PEGADO

            // Forzamos repintado para borrar rastros antiguos inmediatamente
            renderBoard();
            // ------------------------------------------------------------------

            const rawData = e.dataTransfer.getData('text/plain');
            if (!rawData) return;
            const data = JSON.parse(rawData);

            draggingMeta = null;

            // ============================================================
            //  FASE ESPECIAL: RESOLUCIÃ“N DE ASEDIO
            // ============================================================
            if (gameState === 'siege-resolution') {
                // ... (MANTÃ‰N TU CÃ“DIGO DE ASEDIO EXACTAMENTE IGUAL QUE ANTES AQUÃ) ...
                // Para ahorrar espacio, asumo que dejas el bloque 'if (gameState === 'siege-resolution')'
                // tal cual lo tenÃ­as en la versiÃ³n 4.6, ya que eso funcionaba bien.
                if (data.army !== besiegedArmy) return;
                // ... copia tu lÃ³gica de asedio aquÃ­ ...
                // (Si necesitas que te la pegue entera dÃ­melo, pero es la misma de antes)
                // ... FIN BLOQUE ASEDIO ...

                // PEQUEÃ‘O RECORDATORIO: Si copias el bloque, asegÃºrate de que al final del bloque
                // de asedio hagas return;

                // --- INICIO RESUMEN BLOQUE ASEDIO (CÃ³pialo de tu v4.6) ---
                if (data.source !== 'reserve') { showNotification(t('siege_use_reserve'), true); return; }
                const fOrigin = fortressPos[data.army];
                if (!isInExitZone(r, c, fOrigin)) { showNotification(t('deploy_fort'), true); return; }
                if (logicBoard[r][c] !== null || terrain[r][c] === 'water') { showNotification(t('invalid_cell'), true); return; }

                const myReserve = reserves[data.army];
                if (myReserve['rey'] > 0 && data.type !== 'rey') { showNotification(t('save_king'), true); return; }
                if (data.type === 'rey' && currentThreatMap && currentThreatMap[r][c] > 0) { showNotification(t('death_zone'), true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    logicBoard[r][c] = { army: data.army, type: data.type };
                }
                const attackerArmy = (besiegedArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;
                for (const [t, count] of Object.entries(reserves[data.army])) {
                    if (t === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) { dungeons[attackerArmy].push({ type: t, army: besiegedArmy }); capturedCount++; }
                        reserves[data.army][t] = 0;
                    }
                }
                showNotification(t('msg_siege_break', { count: capturedCount }));
                gameState = 'playing'; besiegedArmy = null; turnColor = attackerArmy;
                renderBoard(); updateInventories(); updateDungeons(); checkTurnStatus();
                return;
                // --- FIN RESUMEN BLOQUE ASEDIO ---
            }

            // ============================================================
            //  FASE 1: MODO JUEGO (NORMAL Y BONUS)
            // ============================================================
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus' || gameState === 'siege-confirmation') {

                // --- A. REFUERZOS (DESDE RESERVA) ---
                if (data.source === 'reserve') {
                    const fOrigin = fortressPos[data.army];
                    if (!isInExitZone(r, c, fOrigin)) { showNotification(t('only_near')); return; }
                    if (terrain[r][c] === 'water') { showNotification(t('no_water')); return; }
                    if (logicBoard[r][c] !== null) { showNotification(t('zone_occ')); return; }

                    if (reserves[data.army][data.type] > 0) {
                        reserves[data.army][data.type]--;
                        logicBoard[r][c] = { army: data.army, type: data.type };

                        showNotification(t('msg_reinforcements', { unit: t(data.type).toUpperCase() }));
                    } else { return; }
                }

                // --- B. MOVIMIENTO (TABLERO A TABLERO) ---
                else if (data.source === 'board') {
                    shotHighlights = []; // Aseguramos limpieza al iniciar movimiento

                    const target = logicBoard[r][c];

                    // Validaciones bÃ¡sicas
                    if (terrain[r][c] === 'water' && data.type !== 'trabuquete' && data.type !== 'escorpion') { showNotification(t('water_simple')); return; }
                    if (target === null && terrain[r][c] === 'water') { showNotification(t('water_simple')); return; }
                    if (target && target.type === 'montana') { showNotification(t('mountain_simple')); return; }
                    if (target && target.type === 'fortaleza') { showNotification(t('fortress_simple')); return; }

                    // --- CORRECCIÃ“N ELEFANTE: LÃ“GICA ROBUSTA ---
                    if (target && target.type === 'elefante' && target.army !== data.army && data.type !== 'dragon') {
                        // CÃLCULO: Total amenazas (Yo + Aliados)
                        const totalThreats = countTotalThreats(r, c, data.army);

                        if (totalThreats < 2) {
                            showNotification(t('elephant_fail'), true);
                            return;
                        }
                    }

                    // ValidaciÃ³n GeomÃ©trica
                    if (!isValidMove(data.type, data.originR, data.originC, r, c)) {
                        showNotification(t('illegal')); return;
                    }

                    // --- NUEVO: VALIDACIÃ“N DE SEGURIDAD (ANTI-SUICIDIO / OBLIGACIÃ“N DE SALVAR REY) ---
                    // Antes de mover, simulamos si esto nos deja en Jaque.
                    if (!isSimulatedMoveSafe(data.type, data.originR, data.originC, r, c, data.army)) {
                        const msg = isCheck ? t('check_alert') : t('suicide');
                        showNotification(msg, true);
                        return; // Cancelamos el movimiento
                    }

                    let wasCapture = false;

                    if (target) {
                        if (target.army === data.army) {
                            // Aliado (Solo Lanceros)
                            if (data.type === 'lanceros') {
                                logicBoard[data.originR][data.originC] = target;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification(t('relay'));
                            } else { showNotification(t('ally')); return; }
                        } else {
                            // Enemigo (Captura/Disparo)
                            wasCapture = true;

                            // DISPARO (Trabuquete/EscorpiÃ³n) - NO SE MUEVEN
                            if (data.type === 'trabuquete' || data.type === 'escorpion') {
                                shotHighlights.push({ r: data.originR, c: data.originC, type: 'source' });
                                shotHighlights.push({ r: r, c: c, type: 'target' });

                                if (data.type === 'escorpion') {
                                    // LÃ³gica perforaciÃ³n EscorpiÃ³n
                                    const sR = Math.sign(r - data.originR);
                                    const sC = Math.sign(c - data.originC);
                                    let cR = data.originR + sR, cC = data.originC + sC;
                                    while (cR !== r || cC !== c) {
                                        const obs = logicBoard[cR][cC];
                                        if (obs && obs.army !== data.army) {
                                            dungeons[data.army].push({ type: obs.type, army: obs.army });
                                            logicBoard[cR][cC] = null;
                                            shotHighlights.push({ r: cR, c: cC, type: 'target' });
                                        }
                                        cR += sR; cC += sC;
                                    }
                                }

                                // Captura Objetivo
                                if (target.type === 'rey') {
                                    gameState = 'game-over'; logicBoard[r][c] = null; renderBoard();
                                    finishGame(data.army, "reason_mate");
                                    return;
                                }
                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[r][c] = null;
                                showNotification(t('shot'));
                            } else {
                                // CAPTURA CUERPO A CUERPO (Se mueven)
                                if (target.type === 'rey') {
                                    gameState = 'game-over'; logicBoard[data.originR][data.originC] = null;
                                    logicBoard[r][c] = { army: data.army, type: data.type }; renderBoard();
                                    finishGame(data.army, "reason_mate");
                                    return;
                                }
                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[data.originR][data.originC] = null;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification(t('capture'));
                            }
                        }
                    } else {
                        // Movimiento a vacÃ­o
                        logicBoard[data.originR][data.originC] = null;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        wasCapture = false;
                    }

                    // --- Asedio creado? ---
                    let siegeCreated = false;
                    const enemyFortCheck = fortressPos[(data.army === 'rojo') ? 'negro' : 'rojo'];
                    if (enemyFortCheck) {
                        let count = 0;
                        for (let rx = 0; rx < 10; rx++) {
                            for (let cx = 0; cx < 10; cx++) {
                                if (isInExitZone(rx, cx, enemyFortCheck)) {
                                    const u = logicBoard[rx][cx];
                                    if (u && u.army === data.army) count++;
                                }
                            }
                        }
                        if (count >= 2) siegeCreated = true;
                    }

                    // --- Bonus Chusma ---
                    if (gameState === 'playing' && data.type === 'chusma' && !wasCapture && gameState !== 'siege-confirmation' && !siegeCreated) {

                        // NUEVO: Verificamos si realmente hay OTRA chusma para mover
                        let totalChusmas = 0;
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                const p = logicBoard[tr][tc];
                                if (p && p.army === data.army && p.type === 'chusma') {
                                    totalChusmas++;
                                }
                            }
                        }

                        // Solo activamos el Bonus si tienes mÃ¡s de 1 chusma (la que moviste + otra)
                        if (totalChusmas > 1) {
                            gameState = 'playing-chusma-bonus';
                            chusmaMovedCoords = { r: r, c: c };
                            renderBoard(); updateInventories(); updateDungeons(); checkTurnStatus();
                            return;
                        }
                        // Si solo tienes 1, ignoramos el bonus y dejamos que el cÃ³digo siga hacia abajo (cambio de turno)
                    }
                }

                // --- FINAL DE TURNO / GESTIÃ“N ASEDIO (IGUAL QUE ANTES) ---
                if (gameState === 'siege-confirmation') {
                    const defender = (data.army === 'rojo') ? 'negro' : 'rojo';
                    turnColor = defender; gameState = 'playing';
                    checkTurnStatus(); renderBoard(); updateInventories(); updateDungeons();
                    if (!siegeStatus[defender]) showNotification(t('siege_cancel'));
                    return;
                }

                const defenderArmy = data.army;
                const attackerArmy = (defenderArmy === 'rojo') ? 'negro' : 'rojo';
                const myFort = fortressPos[defenderArmy];
                if (myFort) {
                    let enemiesAtGate = 0;
                    for (let rx = 0; rx < 10; rx++) {
                        for (let cx = 0; cx < 10; cx++) {
                            if (isInExitZone(rx, cx, myFort)) {
                                const u = logicBoard[rx][cx];
                                if (u && u.army === attackerArmy) enemiesAtGate++;
                            }
                        }
                    }
                    // SI LA DEFENSA FALLA (Sigue habiendo 2+ enemigos)
                    // Esto comprueba correctamente si quedan 2, 3 o 100 enemigos.
                    // Si eliminaste uno pero quedan 2, entrarÃ¡ aquÃ­ correctamente.
                    if (enemiesAtGate >= 2) {
                        gameState = 'siege-confirmation';
                        turnColor = attackerArmy; // El turno vuelve al atacante

                        // --- CORRECCIÃ“N QUIRÃšRGICA: PRIORIDAD DE ALERTA ---
                        // Si venimos de una captura, hay una notificaciÃ³n bloqueando la barra.
                        // La desactivamos a la fuerza para que el aviso de ASEDIO se vea SÃ o SÃ.
                        isNotificationActive = false;
                        if (notificationTimer) clearTimeout(notificationTimer);
                        // --------------------------------------------------

                        renderBoard(); updateInventories(); updateDungeons();
                        updateStatusBar(); // Ahora sÃ­ mostrarÃ¡ "ASEDIO LISTO" en rojo
                        return;
                    }
                }

                turnColor = attackerArmy; gameState = 'playing'; chusmaMovedCoords = null;
                checkTurnStatus(); renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // ============================================================
            //  FASE 2: MODO DESPLIEGUE (SETUP) - (MANTENER TU CÃ“DIGO ACTUAL)
            // ============================================================
            // Copia aquÃ­ el bloque "const isFortress = ..." y todo el despliegue
            // que ya tenÃ­as funcionando en 4.6. No hay cambios ahÃ­.
            // ... (Pega tu cÃ³digo de despliegue aquÃ­) ...
            const isFortress = (data.type === 'fortaleza');
            const isMountain = (data.type === 'montana');
            const fOrigin = fortressPos[data.army];
            const hasFortress = fOrigin !== null;

            // Validaciones
            if (!isFortress && !hasFortress) { showNotification(t('first_fort'), true); return; }

            if (p1Territory) {
                const currentZone = getTerritory(r);
                const myZone = (data.army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                if (currentZone !== myZone) { showNotification(t('zone_forbid'), true); return; }
            }

            // BLOQUE MODIFICADO: Retorno a reserva si sale del anillo
            if (!isFortress && !isMountain && hasFortress) {
                if (!isInExitZone(r, c, fOrigin)) {

                    // --- NUEVO: SI VIENE DEL TABLERO, LA DEVOLVEMOS A LA RESERVA ---
                    if (data.source === 'board') {
                        logicBoard[data.originR][data.originC] = null;
                        reserves[data.army][data.type]++;

                        showNotification(t('msg_return_reserve', { unit: t(data.type).toUpperCase() }));
                        renderBoard();
                        updateInventories();
                        return;
                    }

                    showNotification(t('deploy_near'), true); return;
                }
            }

            let cellsToCheck = [];
            if (isFortress) {
                if (r + 1 > 9 || c + 1 > 9) { showNotification(t('no_fit'), true); return; }
                cellsToCheck.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                const invalidRows = [0, 4, 5, 9]; const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1) || invalidCols.includes(c) || invalidCols.includes(c + 1)) {
                    showNotification(t('pos_invalid'), true); return;
                }
            } else {
                cellsToCheck.push({ r: r, c: c });
            }

            for (let cell of cellsToCheck) {
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) { showNotification(t('water_error'), true); return; }
                if (logicBoard[cell.r][cell.c] !== null) { showNotification(t('occupied'), true); return; }
            }

            if (data.source === 'reserve') {
                if (gameState === 'init') {
                    if (!isFortress) { showNotification(t('first_fort'), true); return; }
                    p1Color = data.army;
                    p2Color = (p1Color === 'rojo') ? 'negro' : 'rojo';
                    p1Territory = getTerritory(r);
                    gameState = 'deploy-p1';
                }
                if (gameState === 'deploy-p1' && data.army !== p1Color) { showNotification(t('turn_j1'), true); return; }
                if (gameState === 'deploy-p2' && data.army !== p2Color) { showNotification(t('turn_j2'), true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });

                    if (isFortress) {
                        fortressPos[data.army] = { r: r, c: c };

                        if (gameState === 'deploy-p1') {
                            showNotification(t('msg_p1_control', {
                                color: t(p1Color).toUpperCase(),
                                zone: t(p1Territory).toUpperCase()
                            }));
                        } else {
                            showNotification(t('fort_set'));
                        }
                    } else {
                        showNotification(t('msg_deployed', { unit: t(data.type).toUpperCase() }));
                    }
                }
            } else if (data.source === 'board') {
                logicBoard[data.originR][data.originC] = null;
                cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });
                if (isFortress) fortressPos[data.army] = { r: r, c: c };
                showNotification(t('relocated'));
            }

            renderBoard();
            updateInventories();
        }

        function updateDungeons() {
            ['rojo', 'negro'].forEach(jailerArmy => {
                const container = document.getElementById(`grave-${jailerArmy}`);
                if (!container) return;
                container.innerHTML = '';

                // Conjunto para recordar quÃ© tipos de piezas ya hemos pintado en esta vuelta
                const drawnTypes = new Set();

                dungeons[jailerArmy].forEach((captive, index) => {
                    // Si ya hemos dibujado una pieza de este tipo, la saltamos (agrupaciÃ³n visual)
                    if (drawnTypes.has(captive.type)) return;

                    // Si es nueva, la registramos y la dibujamos
                    drawnTypes.add(captive.type);

                    const img = document.createElement('img');
                    img.src = getImgUrl(captive.army, captive.type);
                    // Necesitamos una clave simple o construirlo
                    const uName = t(captive.type).toUpperCase();
                    img.title = (currentLang === 'en') ? `Prisoner: ${uName}` : `Prisionero: ${uName}`;

                    // LÃ“GICA DE RESCATE
                    // Permitimos click si estamos en la fase de selecciÃ³n obligatoria
                    const isRescueState = (gameState === 'siege-prisoner-select');

                    if (isRescueState && captive.army === turnColor && jailerArmy !== turnColor) {
                        img.classList.add('rescue-target');
                        img.onclick = () => selectPrisonerToRescue(jailerArmy, index);
                        img.title = t('click_rescue');
                    }

                    container.appendChild(img);
                });
            });
        }

        function finishTurnP1() {
            // 1. NUEVA LÃ“GICA: GestiÃ³n de Fortaleza "solitaria" (CorrecciÃ³n MontaÃ±as)
            const fPos = fortressPos[p1Color];
            let isRingEmpty = true;

            if (fPos) {
                // Comprobamos si hay tropas en el anillo
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (isInExitZone(r, c, fPos) && logicBoard[r][c] !== null) {
                            isRingEmpty = false;
                            break;
                        }
                    }
                    if (!isRingEmpty) break;
                }
            }

            if (isRingEmpty) {
                // --- AQUÃ ESTÃ EL CAMBIO SOLICITADO ---
                const maxMountains = CONFIG.pieces['montana'].qty; // Generalmente 3
                const currentMountains = reserves[p1Color]['montana'];

                // ESCENARIO A: No ha puesto montaÃ±as (Reserva llena) -> REINICIO TOTAL
                // Le permitimos cambiar de bando/territorio porque no ha construido nada fijo.
                if (currentMountains === maxMountains) {
                    // --- CORRECCIÃ“N: LIMPIEZA PROFUNDA DE VARIABLES ---
                    logicBoard = Array(10).fill().map(() => Array(10).fill(null)); // Borrar tablero
                    fortressPos = { rojo: null, negro: null }; // Olvidar fortalezas
                    dungeons = { rojo: [], negro: [] }; // Vaciar mazmorras
                    shotHighlights = []; // Quitar marcas de disparo

                    // Resetear identidades
                    p1Color = null;
                    p2Color = null;
                    p1Territory = null;

                    // Volver al estado inicial real
                    gameState = 'init';

                    init(); // Ahora sÃ­, llenamos reservas y pintamos el tablero vacÃ­o
                    showNotification(t('fort_reset'));
                    return;
                }

                // ESCENARIO B: Ya hay montaÃ±as puestas -> REINICIO PARCIAL (Soft Reset)
                // Solo retiramos la fortaleza, pero mantenemos el bando y las montaÃ±as.
                else {
                    const r = fPos.r;
                    const c = fPos.c;
                    // Limpiamos las 4 celdas del castillo
                    logicBoard[r][c] = null; logicBoard[r][c + 1] = null;
                    logicBoard[r + 1][c] = null; logicBoard[r + 1][c + 1] = null;

                    // Devolvemos a reserva
                    fortressPos[p1Color] = null;
                    reserves[p1Color]['fortaleza'] = 1;

                    showNotification(t('fort_soft'));
                    renderBoard();
                    updateInventories();
                    return;
                }
            }

            // 2. CondiciÃ³n existente: Verificar si quedan montaÃ±as por poner
            if (reserves[p1Color]['montana'] > 0) {
                showNotification(t('mountains_left'), true);
                return;
            }

            // 3. Pasar turno
            gameState = 'deploy-p2';

            showNotification(t('msg_p1_finish', { color: t(p2Color).toUpperCase() }));

            renderBoard();
            updateInventories();
        }


        function finishTurnP2() {
            // 1. NUEVA CONDICIÃ“N: Si el anillo estÃ¡ vacÃ­o, devolvemos la fortaleza a la reserva
            const fPos = fortressPos[p2Color];
            let isRingEmpty = true;
            if (fPos) {
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (isInExitZone(r, c, fPos) && logicBoard[r][c] !== null) {
                            isRingEmpty = false;
                            break;
                        }
                    }
                    if (!isRingEmpty) break;
                }
            }

            if (isRingEmpty) {
                // Retirar Fortaleza del J2 del tablero
                const r = fPos.r;
                const c = fPos.c;
                // Limpiamos las 4 celdas
                logicBoard[r][c] = null; logicBoard[r][c + 1] = null;
                logicBoard[r + 1][c] = null; logicBoard[r + 1][c + 1] = null;

                // Resetear variables
                fortressPos[p2Color] = null;
                reserves[p2Color]['fortaleza'] = 1;

                showNotification(t('fort_retry'));
                renderBoard();
                updateInventories();
                return;
            }

            // 2. CondiciÃ³n existente: MontaÃ±as
            if (reserves[p2Color]['montana'] > 0) {
                showNotification(t('mountains_start'), true);
                return;
            }

            // AcciÃ³n directa
            gameState = 'playing';
            turnColor = p1Color;

            // Repintar (se quita la niebla)
            renderBoard();
            updateInventories();

            // 1. PRIMERO: Verificamos el estado real (Jaque, Asedios, etc.)
            checkTurnStatus();

            // 2. SEGUNDO: Notificamos SOLO si no hay una emergencia
            if (!isCheck) {
                showNotification(t('msg_game_start', { color: t(turnColor).toUpperCase() }));
            }
        }

        function attemptRescue(jailerArmy, captiveIndex, captive) {
            // 1. Identificar al enemigo y su fortaleza
            const myArmy = turnColor;
            const enemyFortPos = fortressPos[jailerArmy];

            if (!enemyFortPos) return;

            // 2. Buscar "El Equipo de Rescate"
            let rescueTeam = [];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === myArmy) {
                        if (isInExitZone(r, c, enemyFortPos)) {
                            rescueTeam.push({ r, c, type: piece.type });
                        }
                    }
                }
            }

            // 3. REGLA: Â¿Hay equipo de rescate?
            if (rescueTeam.length < 2) {
                showNotification(t('rescue_fail'), true);
                return;
            }

            // 4. EJECUTAR EL RESCATE (Todo vuelve a la reserva)
            // A. Recuperar al prisionero
            dungeons[jailerArmy].splice(captiveIndex, 1);
            reserves[myArmy][captive.type]++;

            // B. Retirar al equipo de rescate 
            rescueTeam.forEach(soldier => {
                logicBoard[soldier.r][soldier.c] = null;
                reserves[myArmy][soldier.type]++;
            });

            // 5. VERIFICAR RESERVAS DEL ENEMIGO (SOLUCIÃ“N AL BLOQUEO)
            let enemyReserveCount = 0;
            for (const key in reserves[jailerArmy]) {
                enemyReserveCount += reserves[jailerArmy][key];
            }

            if (enemyReserveCount > 0) {
                // --- CASO A: EL ENEMIGO TIENE RESERVAS (ASEDIO NORMAL) ---
                /* const msg = `ğŸš Â¡RESCATE Ã‰PICO!`;
                 showNotificat(msg); // Mensaje corto para que no solape */

                gameState = 'siege-resolution';
                besiegedArmy = jailerArmy;
                turnColor = besiegedArmy; // Turno para el defensor

                updateStatusBar(); // Poner la barra en rojo
            } else {
                // --- CASO B: EL ENEMIGO NO TIENE RESERVAS (SALTAR FASE) ---
                // Como no tiene nada en la reserva, no puede "salvar" nada, 
                // pero tampoco le "matamos" nada extra porque no tiene.
                // Simplemente recuperas tus tropas y sigue tu turno (o pasa al siguiente).

                showNotification(t('rescue_empty'));

                // El turno se mantiene en el atacante (o pasa al siguiente, segÃºn prefieras).
                // Normalmente tras un asedio resuelto, le tocarÃ­a al atacante mover con sus nuevas tropas
                // o pasamos turno. En la lÃ³gica actual de 'handleDrop', tras romper asedio, turnColor = attacker.
                // AquÃ­ ya somos el attacker.

                // OpciÃ³n: Mantenemos el juego fluyendo
                gameState = 'playing';
                // turnColor sigue siendo myArmy

                checkTurnStatus(); // Actualizar amenazas tras sacar piezas del tablero
            }

            renderBoard();
            updateInventories();
            updateDungeons();
        }

        function getStatusText() {
            // A. Prioridades Absolutas (Fin de Partida)
            if (gameState === 'game-over') {
                if (!gameOverData) return "";
                if (gameOverData.winner) {
                    const armyName = t(gameOverData.winner).toUpperCase();
                    return t('status_gameover', {
                        reason: t(gameOverData.reason || "reason_mate"),
                        winner: t('status_win', { army: armyName })
                    });
                } else {
                    return t('status_draw');
                }
            }

            // TRADUCCIÃ“N INICIAL
            if (gameState === 'init') return t('init');

            // B. Preparar nombre del ejÃ©rcito activo
            const rawArmy = getArmyName(turnColor);

            // C. InteracciÃ³n Forzada (Textos largos ahora TRADUCIDOS)
            if (gameState === 'siege-prisoner-select') {
                return t('status_prisoner', { army: rawArmy });
            }
            if (gameState === 'siege-confirmation') {
                return t('status_siege_ready', { army: rawArmy });
            }
            if (gameState === 'siege-resolution') {
                return t('status_sacrifice', { army: rawArmy });
            }

            // D. Bonus
            if (gameState === 'playing-chusma-bonus') {
                return t('status_chusma');
            }

            // E. Alertas
            if (isCheck) {
                return t('status_check', { army: rawArmy });
            }
            if (siegeStatus[turnColor] === true) {
                return t('status_surrounded', { army: rawArmy });
            }

            // F. Estado EstÃ¡ndar (Fase Despliegue y Turno)
            if (gameState.includes('deploy')) {
                const playerColor = (gameState === 'deploy-p1' ? p1Color : p2Color);
                const pName = playerColor ? t(playerColor).toUpperCase() : '';
                return `${t('deploy_phase')}: ${pName}`;
            }

            // Turno Normal
            return `${t('turn_part')} ${rawArmy}`;
        }

        // Pinta el anillo de salida de la fortaleza del ejÃ©rcito indicado
        function highlightFortressRing(army) {
            const fPos = fortressPos[army];
            if (!fPos) return;

            // Recorremos todo el tablero (ineficiente pero seguro y rÃ¡pido en 10x10)
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    // Si es zona de salida, estÃ¡ vacÃ­a y no es agua
                    if (isInExitZone(r, c, fPos)) {
                        if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                            if (tile) tile.classList.add('highlight-ring');
                        }
                    }
                }
            }
        }

        // Limpia el resaltado del anillo
        function clearRingHighlights() {
            document.querySelectorAll('.highlight-ring').forEach(el => {
                el.classList.remove('highlight-ring');
            });
        }

        // Valida SOLO la geometrÃ­a y el camino del movimiento
        function isValidMove(type, r1, c1, r2, c2) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // --- 0. REGLA ESPECIAL: CAPTURA DE ELEFANTES ---
            const myPiece = logicBoard[r1][c1];
            const target = logicBoard[r2][c2];

            if (myPiece && target && target.type === 'elefante' && target.army !== myPiece.army) {
                if (type === 'dragon') { /* Pasa */ }
                else {
                    const totalThreats = countTotalThreats(r2, c2, myPiece.army);
                    if (totalThreats < 2) return false;
                }
            }

            // --- 1. REY ---
            if (type === 'rey') {
                if (currentThreatMap && currentThreatMap[r2][c2] > 0) return false;
                return (dR <= 1 && dC <= 1) && (dR + dC > 0);
            }
            // --- 2. LANCEROS / CHUSMA ---
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            // --- 3. DRAGÃ“N ---
            if (type === 'dragon') {
                if (!((dR === dC) || (r1 === r2 || c1 === c2))) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const obs = logicBoard[cR][cC];
                    if (obs && obs.type !== 'montana') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 4. ARQUEROS (REVISADO) ---
            if (type === 'arqueros') {
                // Movimiento Diagonal Exclusivo
                if (dR !== dC) return false;

                // Distancia 1: Siempre posible (Mover o Capturar)
                if (dR === 1) return true;

                // Distancia 2: Habilidad "Largo Alcance"
                if (dR === 2) {
                    // CONDICIÃ“N 1: Solo sirve para CAPTURAR (debe haber alguien en destino)
                    // Si la casilla destino estÃ¡ vacÃ­a, NO puede saltar.
                    if (logicBoard[r2][c2] === null) return false;

                    // CONDICIÃ“N 2: No puede saltar obstÃ¡culos (la casilla intermedia debe estar VACÃA)
                    const midR = (r1 + r2) / 2;
                    const midC = (c1 + c2) / 2;

                    // Verificamos bloqueo fÃ­sico (pieza) y terreno (agua)
                    // Nota: logicBoard[midR][midC] debe ser null para que el tiro pase.
                    const pathClear = (logicBoard[midR][midC] === null && terrain[midR][midC] !== 'water');

                    return pathClear;
                }
                return false;
            }

            // --- 5. ELEFANTE ---
            if (type === 'elefante') {
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    // Bloqueo total por unidades, montaÃ±as, fortalezas y agua
                    if (logicBoard[cR][cC] !== null || terrain[cR][cC] === 'water') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 6. CABALLERÃA LIGERA (Ruta Dual: 2+1 Ã³ 1+2) ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;

                const checkBlock = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };

                // RUTA A: Primero salto largo (2), luego corto (1)
                let pathA_Valid = false;
                const diags2 = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [kr, kc] of diags2) {
                    // Buscamos la "rodilla" a distancia 2 del origen que conecte con destino
                    if (Math.abs(r2 - (r1 + kr)) === 1 && Math.abs(c2 - (c1 + kc)) === 1) {
                        const kneeR = r1 + kr;
                        const kneeC = c1 + kc;
                        const midR = (r1 + kneeR) / 2;
                        const midC = (c1 + kneeC) / 2;

                        if (!checkBlock(midR, midC) && !checkBlock(kneeR, kneeC)) {
                            pathA_Valid = true;
                        }
                        break;
                    }
                }

                // RUTA B: Primero salto corto (1), luego largo (2)
                let pathB_Valid = false;
                const diags1 = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [kr, kc] of diags1) {
                    // Buscamos la "rodilla" a distancia 1 del origen que conecte con destino
                    if (Math.abs(r2 - (r1 + kr)) === 2 && Math.abs(c2 - (c1 + kc)) === 2) {
                        const kneeR = r1 + kr;
                        const kneeC = c1 + kc;
                        const midR = (kneeR + r2) / 2;
                        const midC = (kneeC + c2) / 2;

                        if (!checkBlock(kneeR, kneeC) && !checkBlock(midR, midC)) {
                            pathB_Valid = true;
                        }
                        break;
                    }
                }

                return (pathA_Valid || pathB_Valid);
            }

            // --- 7. CABALLERÃA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const myArmy = logicBoard[r1][c1] ? logicBoard[r1][c1].army : null;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true; // Agua bloquea
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== myArmy) return true; // Enemigo bloquea
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- 8. TRABUQUETE ---
            if (type === 'trabuquete') {
                // A. MOVIMIENTO (Destino vacÃ­o): Solo Diagonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR === 1 && dC === 1); // El agua se valida fuera (handleDrop)
                }
                // B. DISPARO: Solo Ortogonal
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Dispara sobre unidades y agua. Solo bloquean Muros.
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 9. ESCORPIÃ“N ---
            if (type === 'escorpion') {
                // A. MOVIMIENTO (Destino vacÃ­o): Solo Ortogonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR + dC === 1);
                }
                // B. DISPARO: Solo Diagonal
                if (dR !== dC) return false;

                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Bloqueos fÃ­sicos
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;

                    // Unidades
                    if (o) {
                        if (o.army !== logicBoard[r1][c1].army) {
                            enemiesInPath++;
                            lastEnemyPos = { r: cR, c: cC };
                        } else {
                            // BLOQUEO: No puede atravesar unidades amigas
                            return false;
                        }
                    }
                    // Agua: Se ignora (proyectil vuela sobre ella)

                    cR += sR; cC += sC;
                }

                // LÃ³gica de PerforaciÃ³n
                if (enemiesInPath === 0) return true; // Tiro limpio
                if (enemiesInPath === 1) {
                    // Distancia entre la vÃ­ctima intermedia y el objetivo final
                    const dist = Math.abs(r2 - lastEnemyPos.r);
                    // Permite hueco de 0, 1 o 2 casillas (ocupadas por agua o vacÃ­o)
                    if (dist >= 1 && dist <= 3) return true;
                }
                return false;
            }

            return false;
        }

        function finishChusmaBonusTurn() {
            /* isBesieged = false; // <--- AÃ‘ADE ESTA LÃNEA: Apaga la alarma anterior a la fuerza */
            // Cambiar turno y volver a la normalidad
            turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
            gameState = 'playing';
            chusmaMovedCoords = null;

            /* showNotificat(`Turno ${getArmyName(turnColor)}`); */

            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

        // --- SISTEMA DE AMENAZAS (Influence Maps) ---

        // Genera una matriz 10x10 donde cada celda indica cuÃ¡ntas unidades del 'attackingArmy' amenazan esa posiciÃ³n
        function getThreatMap(attackingArmy) {
            // 1. Crear matriz vacÃ­a de ceros
            let map = Array(10).fill().map(() => Array(10).fill(0));

            // 2. Identificar al Rey VÃ­ctima para hacerlo transparente (Fix Dragon X-Ray)
            // Si ataca el rojo, la vÃ­ctima es el negro.
            const victimArmy = (attackingArmy === 'rojo') ? 'negro' : 'rojo';
            let kingPos = null;

            // Buscamos al Rey
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.type === 'rey' && p.army === victimArmy) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            // 3. Recorrer tablero buscando atacantes
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === attackingArmy) {

                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                if (r === tr && c === tc) continue;

                                // Pasamos la posiciÃ³n del rey a ignorar (kingPos)
                                if (canUnitAttack(piece.type, r, c, tr, tc, piece.army, kingPos)) {
                                    map[tr][tc]++;
                                }
                            }
                        }
                    }
                }
            }
            return map;
        }

        // Verifica si una unidad en (r1,c1) podrÃ­a atacar/capturar en (r2,c2)
        function canUnitAttack(type, r1, c1, r2, c2, army, ignorePos = null) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            if (type === 'rey') return (dR <= 1 && dC <= 1);
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    const isMidEmpty = (logicBoard[midR][midC] === null || (ignorePos && midR === ignorePos.r && midC === ignorePos.c));
                    // Agua bloquea ataque de salto
                    return (isMidEmpty && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // --- CABALLERÃA LIGERA (Ruta Dual para Amenazas) ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;

                const checkBlock = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (ignorePos && r === ignorePos.r && c === ignorePos.c) return false;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };

                // RUTA A (2+1)
                let pathA = false;
                const diags2 = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [kr, kc] of diags2) {
                    if (Math.abs(r2 - (r1 + kr)) === 1 && Math.abs(c2 - (c1 + kc)) === 1) {
                        const kneeR = r1 + kr, kneeC = c1 + kc;
                        const midR = (r1 + kneeR) / 2, midC = (c1 + kneeC) / 2;
                        if (!checkBlock(midR, midC) && !checkBlock(kneeR, kneeC)) pathA = true;
                        break;
                    }
                }

                // RUTA B (1+2)
                let pathB = false;
                const diags1 = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [kr, kc] of diags1) {
                    if (Math.abs(r2 - (r1 + kr)) === 2 && Math.abs(c2 - (c1 + kc)) === 2) {
                        const kneeR = r1 + kr, kneeC = c1 + kc;
                        const midR = (kneeR + r2) / 2, midC = (kneeC + c2) / 2;
                        if (!checkBlock(kneeR, kneeC) && !checkBlock(midR, midC)) pathB = true;
                        break;
                    }
                }

                return (pathA || pathB);
            }

            // --- CABALLERÃA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    if (ignorePos && r === ignorePos.r && c === ignorePos.c) return false;
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== army) return true;
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- RAYCAST (DragÃ³n, Armas) ---
            const checkRay = (isOrtho, isDiag, canFly, isWeapon) => {
                const validOrtho = (r1 === r2 || c1 === c2);
                const validDiag = (dR === dC);
                if (isOrtho && isDiag) { if (!validOrtho && !validDiag) return false; }
                else if (isOrtho) { if (!validOrtho) return false; }
                else if (isDiag) { if (!validDiag) return false; }

                const sR = Math.sign(r2 - r1);
                const sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    if (ignorePos && cR === ignorePos.r && cC === ignorePos.c) {
                        cR += sR; cC += sC; continue;
                    }
                    const obs = logicBoard[cR][cC];

                    if (canFly) {
                        if (obs && obs.type !== 'montana') return false;
                    } else {
                        if (terrain[cR][cC] === 'water' && !isWeapon) return false;
                        if (obs) {
                            if (obs.type === 'montana' || obs.type === 'fortaleza') return false;
                            if (isWeapon && type === 'escorpion') {
                                if (obs.army !== army) { enemiesInPath++; lastEnemyPos = { r: cR, c: cC }; }
                                else return false; // Bloqueo amigo
                            } else if (isWeapon && type === 'trabuquete') {
                                // Ignora
                            } else {
                                return false;
                            }
                        }
                    }
                    cR += sR; cC += sC;
                }

                if (type === 'escorpion' && enemiesInPath > 0) {
                    if (enemiesInPath === 1) {
                        const dist = Math.abs(r2 - lastEnemyPos.r);
                        return (dist >= 1 && dist <= 3);
                    }
                    return false;
                }
                return true;
            };

            if (type === 'dragon') return checkRay(true, true, true, false);
            if (type === 'elefante') return checkRay(true, false, false, false);
            if (type === 'trabuquete') return checkRay(true, false, false, true);
            if (type === 'escorpion') return checkRay(false, true, false, true);

            return false;
        }

        // Verifica amenazas y estados globales
        function checkTurnStatus() {
            // 1. Calcular mapas de amenaza
            const enemy = (turnColor === 'rojo') ? 'negro' : 'rojo';
            const threatMap = getThreatMap(enemy);
            const attackMap = getThreatMap(turnColor);

            // A. DETECCIÃ“N DE ASEDIO
            siegeStatus.rojo = false;
            siegeStatus.negro = false;

            ['rojo', 'negro'].forEach(army => {
                const fort = fortressPos[army];
                if (fort) {
                    const attacker = (army === 'rojo') ? 'negro' : 'rojo';
                    let enemiesAtGate = 0;
                    for (let r = 0; r < 10; r++) {
                        for (let c = 0; c < 10; c++) {
                            if (isInExitZone(r, c, fort)) {
                                const p = logicBoard[r][c];
                                if (p && p.army === attacker) enemiesAtGate++;
                            }
                        }
                    }
                    if (enemiesAtGate >= 2) siegeStatus[army] = true;
                }
            });

            // B. BUSCAR AL REY
            let kingPos = null;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === turnColor && p.type === 'rey') {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) { isCheck = false; updateStatusBar(); return; }

            // 2. DETECCIÃ“N DE JAQUE
            isCheck = (threatMap[kingPos.r][kingPos.c] > 0);

            // C. ACTUALIZAR INTERFAZ (Prioridad inmediata)
            updateStatusBar();

            // D. VERIFICAR SI HAY SALVACIÃ“N (MATE / AHOGADO)
            currentThreatMap = threatMap;
            currentAttackMap = attackMap;

            let hasMoves = false;

            try {
                // BUSCAMOS CUALQUIER MOVIMIENTO QUE SALVE AL REY
                // Recorremos todas nuestras piezas
                outerLoop:
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        const p = logicBoard[r][c];
                        if (p && p.army === turnColor) {

                            // Probamos todos los destinos posibles
                            for (let tr = 0; tr < 10; tr++) {
                                for (let tc = 0; tc < 10; tc++) {

                                    // 1. Â¿Es un movimiento geomÃ©tricamente vÃ¡lido?
                                    if (isValidMove(p.type, r, c, tr, tc)) {

                                        // Filtros bÃ¡sicos de terreno/ocupaciÃ³n
                                        if (terrain[tr][tc] === 'water' && p.type !== 'trabuquete' && p.type !== 'escorpion') continue;
                                        const target = logicBoard[tr][tc];
                                        if (target && target.army === turnColor && p.type !== 'lanceros') continue;
                                        if (target && (target.type === 'montana' || target.type === 'fortaleza')) continue;

                                        // 2. SIMULACIÃ“N DE SEGURIDAD (EL JUEZ FINAL)
                                        // Realizamos el movimiento en el tablero lÃ³gico temporalmente
                                        const originalSource = logicBoard[r][c];
                                        const originalTarget = logicBoard[tr][tc];

                                        logicBoard[r][c] = null;
                                        logicBoard[tr][tc] = originalSource;

                                        // RE-CALCULAMOS: Â¿Sigue el Rey en jaque en este futuro hipotÃ©tico?
                                        // Nota: Si movimos al Rey, su posiciÃ³n ha cambiado a (tr, tc)
                                        let simKingR = (p.type === 'rey') ? tr : kingPos.r;
                                        let simKingC = (p.type === 'rey') ? tc : kingPos.c;

                                        // Usamos getAttackers que lee el tablero modificado (con el bloqueo/captura aplicado)
                                        const threats = getAttackers(simKingR, simKingC, turnColor);
                                        const isSuicide = (threats.length > 0);

                                        // Deshacemos el movimiento (Revertir)
                                        logicBoard[r][c] = originalSource;
                                        logicBoard[tr][tc] = originalTarget;

                                        if (!isSuicide) {
                                            hasMoves = true;
                                            break outerLoop; // Â¡Encontramos al menos una salida! No es Mate.
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error cÃ¡lculo Mate:", err);
                hasMoves = true; // Ante la duda, dejar jugar
            }

            // Si el Rey parece condenado en el tablero, verificamos "en secreto" 
            // si la reserva puede salvarle. Si es asÃ­, NO declaramos Mate.
            if (!hasMoves) {
                const myFort = fortressPos[turnColor];

                // 1. Â¿Tenemos alguna tropa en la reserva? (Excluimos MontaÃ±as/Fortalezas)
                let canDeploySomething = false;
                let samplePiece = null;

                if (myFort) {
                    for (const [type, count] of Object.entries(reserves[turnColor])) {
                        if (type !== 'montana' && type !== 'fortaleza' && count > 0) {
                            canDeploySomething = true;
                            samplePiece = type; // Usamos el primer tipo disponible para probar
                            break;
                        }
                    }
                }

                // 2. Si hay tropas, simulamos poner una en el anillo para bloquear
                if (canDeploySomething) {
                    // Limitamos la bÃºsqueda al Ã¡rea de la fortaleza para optimizar
                    const minR = Math.max(0, myFort.r - 1);
                    const maxR = Math.min(9, myFort.r + 2);
                    const minC = Math.max(0, myFort.c - 1);
                    const maxC = Math.min(9, myFort.c + 2);

                    reserveLoop:
                    for (let r = minR; r <= maxR; r++) {
                        for (let c = minC; c <= maxC; c++) {
                            // Solo probamos en casillas vÃ¡lidas de despliegue
                            if (isInExitZone(r, c, myFort) && logicBoard[r][c] === null && terrain[r][c] !== 'water') {

                                // A. Simular despliegue (Bloqueo fÃ­sico)
                                logicBoard[r][c] = { army: turnColor, type: samplePiece };

                                // B. Â¿Sigue el Rey amenazado?
                                // (Al poner un cuerpo sÃ³lido, getAttackers detectarÃ¡ si se cortÃ³ la visiÃ³n)
                                const threats = getAttackers(kingPos.r, kingPos.c, turnColor);

                                // C. Revertir simulaciÃ³n
                                logicBoard[r][c] = null;

                                if (threats.length === 0) {
                                    hasMoves = true; // Â¡Existe salvaciÃ³n! No decimos cuÃ¡l, pero el juego sigue.
                                    break reserveLoop;
                                }
                            }
                        }
                    }
                }
            }

            // E. RESOLUCIÃ“N DE PARTIDA
            if (!hasMoves) {
                if (isCheck) {
                    finishGame(enemy, "reason_mate");
                } else {
                    finishGame(null, "reason_stalemate");
                }
            }
        }

        function finishGame(winnerArmy, reason = "") {
            gameState = 'game-over';

            // Guardamos los datos para usarlos en getStatusText
            gameOverData = {
                winner: winnerArmy,
                reason: reason
            };

            // Forzamos actualizaciÃ³n inmediata usando el traductor
            updateStatusBar();
        }

        // Actualiza la barra de estado gestionando prioridades y colores
        function showNotification(msg, isError = false) {
            // Verificar estado crÃ­tico primero
            if (isCheck || siegeStatus[turnColor] === true || gameState === 'siege-resolution' || gameState === 'siege-confirmation') {
                updateStatusBar();
                return;
            }

            const bar = document.getElementById('status-bar');
            isNotificationActive = true;

            // --- MAGIA AQUÃ: TRADUCCIÃ“N AUTOMÃTICA ---
            // Intentamos traducir el mensaje 'msg'. Si es un texto fijo espaÃ±ol, lo cambiarÃ¡ a inglÃ©s.
            // Si ya viene traducido (porque usamos t()), lo dejarÃ¡ igual.
            bar.innerText = autoTranslate(msg);
            // -----------------------------------------

            bar.classList.remove('status-critical');
            bar.style.color = isError ? '#e74c3c' : '#f1c40f';

            bar.style.opacity = 0;
            setTimeout(() => bar.style.opacity = 1, 50);

            if (notificationTimer) clearTimeout(notificationTimer);

            notificationTimer = setTimeout(() => {
                isNotificationActive = false;
                updateStatusBar();
                bar.style.opacity = 1;
                notificationTimer = null;
            }, 3000);
        }

        function updateStatusBar() {
            const bar = document.getElementById('status-bar');

            // --- 0. PRIORIDAD ABSOLUTA: FIN DE PARTIDA ---
            if (gameState === 'game-over') {
                // Si la partida acabÃ³, forzamos el mensaje final y el estilo de victoria
                bar.innerText = getStatusText();

                // Color: Verde si ganÃ³ alguien, Blanco si tablas
                const color = (gameOverData && gameOverData.winner) ? '#2ecc71' : '#fff';

                bar.style.color = color;
                bar.classList.remove('status-critical'); // Quitamos la animaciÃ³n de alarma roja
                bar.style.fontWeight = 'bold';
                bar.style.opacity = 1;
                return; // IMPORTANTE: Salimos aquÃ­ para que nadie sobrescriba esto
            }

            // 1. Calculamos PRIMERO si la situaciÃ³n actual es CRÃTICA
            const isCritical = (
                gameState === 'siege-resolution' ||
                gameState === 'siege-confirmation' ||
                gameState === 'siege-prisoner-select' ||
                siegeStatus[turnColor] === true ||
                isCheck
            );

            // 2. FILTRO DE PRIORIDAD:
            // Si hay una notificaciÃ³n temporal activa (ej: "Â¡Captura!")...
            // ...SOLO la respetamos si NO estamos en una situaciÃ³n crÃ­tica.
            // Si es crÃ­tica (Jaque/Asedio), ignoramos el bloqueo y sobrescribimos el mensaje inmediatamente.
            if (isNotificationActive && !isCritical) return;

            // 3. Obtenemos el texto segÃºn la jerarquÃ­a
            const text = getStatusText();
            bar.innerText = text;

            // 4. Aplicamos estilos
            if (isCritical) {
                bar.classList.add('status-critical'); // Clase CSS con animaciÃ³n roja
                bar.style.color = '#ff2e2e'; // Aseguramos rojo

                // Si acabamos de sobrescribir una notificaciÃ³n temporal, nos aseguramos de que se vea
                bar.style.opacity = 1;
            } else {
                bar.classList.remove('status-critical');
                // Si es bonus de chusma, color especial (Cyan), si no, Dorado estÃ¡ndar
                if (gameState === 'playing-chusma-bonus') {
                    bar.style.color = '#3498db';
                } else {
                    bar.style.color = 'var(--c-gold)';
                }
            }

            bar.style.opacity = 1;
        }

        // Traduce el color del ejÃ©rcito a su territorio (Norte/Sur)
        function getArmyName(armyColor) {
            if (!armyColor) return "";

            // 1. Si aÃºn no hay territorios definidos
            if (!p1Territory) {
                // Usamos la clave compuesta "DE ROJO" -> "RED ARMY"
                const key = `DE ${armyColor.toUpperCase()}`;
                return t(key);
            }

            const isP1 = (armyColor === p1Color);
            const isNorth = isP1 ? (p1Territory === 'north') : (p1Territory === 'south');

            return isNorth ? t('north') : t('south');
        }

        // Ejecuta el asedio cuando no hay prisioneros que rescatar
        function triggerEmptySiege(attacker, victim) {
            // 1. Identificar y devolver tropas de asedio a casa
            const fortPos = fortressPos[victim];
            let rescueTeam = [];

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === attacker && isInExitZone(r, c, fortPos)) {
                        // Devolvemos a reserva y quitamos del tablero
                        logicBoard[r][c] = null;
                        reserves[attacker][p.type]++;
                    }
                }
            }

            // 2. Notificar
            /* showNotificat("âš”ï¸ Asedio sin prisioneros: Tropas replegadas. Â¡EL ENEMIGO DEBE SACRIFICAR!"); */

            // 3. Activar Fase de Sacrificio (Usando tu mecÃ¡nica existente en handleDrop)
            gameState = 'siege-resolution';
            besiegedArmy = victim;
            turnColor = victim; // Turno para el que sufre el sacrificio

            // 4. Actualizar todo
            updateStatusBar();
            renderBoard();
            updateInventories();
            updateDungeons();
        }

        // =========================================================
        //  FUNCIONES DE GESTIÃ“N DE ASEDIO Y CONSECUENCIAS
        // =========================================================

        // 1. Caso A: El jugador hace click en un prisionero (Ya tenÃ­as el onclick en updateDungeons)
        function selectPrisonerToRescue(jailerArmy, index) {
            const attackerArmy = turnColor;
            const defenderArmy = jailerArmy;
            const prisoner = dungeons[jailerArmy][index];

            // 1. Recuperar prisionero
            dungeons[jailerArmy].splice(index, 1);
            reserves[attackerArmy][prisoner.type]++;

            // 2. Retirar tropas de asedio
            executeSiegeReturn(defenderArmy, attackerArmy);

            // 3. INFORMAR AL JUGADOR (Con traducciÃ³n)
            showNotification(t('msg_rescued', { unit: t(prisoner.type).toUpperCase() }));

            // 4. TRANSICIÃ“N CON PAUSA (2 segundos para leer antes de la alarma roja)
            setTimeout(() => {
                startSacrificePhase(defenderArmy, true);
            }, 2000);
        }

        // 2. Caso B: No habÃ­a prisioneros (Asedio "accidental" o sin botÃ­n)
        function resolveSiegeNoPrisoners(attacker, victim) {
            // 1. Devolver tropas de asedio a casa
            executeSiegeReturn(victim, attacker);

            // 2. INFORMAR
            showNotification(t('siege_end'));

            // 3. PAUSA DE LECTURA (2 segundos)
            setTimeout(() => {
                startSacrificePhase(victim, false);
            }, 2000);
        }

        // Auxiliar: Devuelve las tropas de asedio a casa (VERSIÃ“N BLINDADA)
        function executeSiegeReturn(victimArmy, attackerArmy) {
            const fortPos = fortressPos[victimArmy];
            if (!fortPos) return; // Seguridad

            // Recorremos todo el tablero para asegurar limpieza total
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];

                    // Si encontramos una unidad del ATACANTE en la zona de salida de la VÃCTIMA
                    if (p && p.army === attackerArmy && isInExitZone(r, c, fortPos)) {
                        logicBoard[r][c] = null; // Eliminar del tablero
                        reserves[attackerArmy][p.type]++; // Devolver a reserva
                    }
                }
            }
            // Forzamos repintado inmediato para que no haya dudas visuales
            renderBoard();
            updateInventories();
        }

        // 3. FASE FINAL: Verificar si hay sacrificio o si la fortaleza estÃ¡ vacÃ­a
        function startSacrificePhase(victimArmy, wasExchange) {
            turnColor = victimArmy;
            siegeStatus[victimArmy] = false;

            // 1. Comprobar reservas
            let hasReserves = false;
            let hasKing = (reserves[victimArmy]['rey'] > 0);

            for (const type in reserves[victimArmy]) {
                if (reserves[victimArmy][type] > 0) hasReserves = true;
            }

            // CASO ESPECIAL: "CAPTURA TOTAL" (Ãšltimo supuesto)
            // No hubo intercambio Y no estÃ¡ el Rey -> El defensor no tiene derecho a salvar nada.
            if (hasReserves && !wasExchange && !hasKing) {
                // Captura automÃ¡tica de todo
                const attacker = (victimArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[victimArmy])) {
                    if (type === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) {
                            dungeons[attacker].push({ type: type, army: victimArmy });
                            capturedCount++;
                        }
                        reserves[victimArmy][type] = 0;
                    }
                }

                // --- CORRECCIÃ“N AQUÃ: Usamos traducciÃ³n ---
                showNotification(t('no_exchange', { count: capturedCount }));

                // Volver al juego
                gameState = 'playing';
                besiegedArmy = null;
                // El turno se queda en el defensor para que mueva en el tablero
                checkTurnStatus();

                renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // CASO ESTÃNDAR: Puede salvar (o debe salvar al Rey)
            if (hasReserves) {

                /* let msg = wasExchange
                    ? `ğŸš¨ FORTALEZA CAÃDA: ${victimArmy.toUpperCase()}, salva una unidad.`
                    : `ğŸ‘‘ Â¡PELIGRO CRÃTICO! ${victimArmy.toUpperCase()}, DEBES SALVAR AL REY (El resto serÃ¡ capturado).`;
 
                showNotificat(msg); */

                gameState = 'siege-resolution';
                besiegedArmy = victimArmy;
                updateStatusBar();
            } else {
                // CASO: NO TIENE RESERVAS (Ni para salvar ni para perder)
                showNotification(t('fort_empty'));
                gameState = 'playing';
                besiegedArmy = null;
                checkTurnStatus();
            }

            renderBoard(); updateInventories(); updateDungeons();
        }

        // FunciÃ³n nueva: Ejecuta el asedio una vez confirmado por el jugador
        function executeConfirmedSiege(attackerArmy, defenderArmy) {
            // CORRECCIÃ“N + SEGURIDAD: Buscamos tropas del ATACANTE en la mazmorra del DEFENSOR.
            const prisoners = dungeons[defenderArmy].filter(p => p.army === attackerArmy);

            if (prisoners.length > 0) {
                // CASO A: HAY RESCATE REAL -> EL ATACANTE ELIGE
                turnColor = attackerArmy;
                gameState = 'siege-prisoner-select';

                /* showNotificat(`âš”ï¸ ASEDIO Ã‰PICO: ${attackerArmy.toUpperCase()}, elige a quiÃ©n rescatar.`); */

                renderBoard(); updateInventories(); updateDungeons();
                updateStatusBar();
            } else {
                // CASO B: NO HAY PRISIONEROS -> RESOLUCIÃ“N DIRECTA
                resolveSiegeNoPrisoners(attackerArmy, defenderArmy);
            }
        }

        // Cuenta cuÃ¡ntas unidades del 'attackingArmy' amenazan la casilla (r, c)
        // Se usa para validar la captura del Elefante en tiempo real
        function countThreatsOnTarget(r, c, attackingArmy) {
            let threats = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    const piece = logicBoard[tr][tc];
                    // Si hay una pieza aliada y NO es la que estÃ¡ en la casilla destino (obvio)
                    if (piece && piece.army === attackingArmy) {
                        // Verificamos si esa pieza puede atacar la casilla objetivo
                        if (canUnitAttack(piece.type, tr, tc, r, c, attackingArmy)) {
                            threats++;
                        }
                    }
                }
            }
            return threats;
        }

        // Cuenta cuÃ¡ntos ALIADOS (excluyendo al propio atacante) amenazan la casilla objetivo
        function countAlliesThreatening(targetR, targetC, army, excludeR, excludeC) {
            let allies = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    // Saltamos nuestra propia casilla de origen (porque nos estamos moviendo/disparando)
                    if (tr === excludeR && tc === excludeC) continue;

                    const piece = logicBoard[tr][tc];
                    if (piece && piece.army === army) {
                        // Verificamos si este aliado puede atacar la casilla objetivo
                        if (canUnitAttack(piece.type, tr, tc, targetR, targetC, army)) {
                            allies++;
                        }
                    }
                }
            }
            return allies;
        }


        // Cuenta TODAS las unidades (yo incluido) que amenazan la casilla objetivo
        function countTotalThreats(targetR, targetC, army) {
            let threats = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    const piece = logicBoard[tr][tc];
                    if (piece && piece.army === army) {
                        // Verificamos si esta pieza puede atacar la casilla objetivo
                        // No hace falta excluir nada: si yo ataco, cuento como 1.
                        if (canUnitAttack(piece.type, tr, tc, targetR, targetC, army)) {
                            threats++;
                        }
                    }
                }
            }
            return threats;
        }

        // Devuelve una lista con las coordenadas y tipo de los enemigos que atacan (r, c)
        function getAttackers(targetR, targetC, victimArmy) {
            const attackers = [];
            const enemyArmy = (victimArmy === 'rojo') ? 'negro' : 'rojo';

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === enemyArmy) {
                        // Check rÃ¡pido: Â¿Esta pieza enemiga amenaza mi casilla?
                        if (canUnitAttack(p.type, r, c, targetR, targetC, enemyArmy)) {
                            attackers.push({ r: r, c: c, type: p.type });
                        }
                    }
                }
            }
            return attackers;
        }

        // Simula un movimiento para ver si deja al Rey en Jaque (Suicidio)
        // Simula un movimiento para ver si deja al Rey en Jaque (Suicidio)
        function isSimulatedMoveSafe(pieceType, r1, c1, r2, c2, army) {
            // 1. Identificar dÃ³nde estÃ¡ el Rey (PosiciÃ³n actual antes de mover)
            let currentKingR, currentKingC;
            // Buscamos al Rey en el tablero actual
            if (pieceType === 'rey') {
                // OptimizaciÃ³n: Si muevo el rey, ya sÃ© dÃ³nde estÃ¡ (en r1,c1)
                currentKingR = r1; currentKingC = c1;
            } else {
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        const p = logicBoard[r][c];
                        if (p && p.type === 'rey' && p.army === army) {
                            currentKingR = r; currentKingC = c; break;
                        }
                    }
                }
            }

            // Si por algÃºn error no hay rey, asumimos seguro
            if (currentKingR === undefined) return true;

            // VARIABLES PARA REVERTIR
            // Guardamos quÃ© habÃ­a en destino y origen
            const originalTarget = (logicBoard[r2] && logicBoard[r2][c2]) ? logicBoard[r2][c2] : null;
            const originalSource = logicBoard[r1][c1];

            // DETECTAR SI ES UN RELEVO (SWAP) VÃLIDO
            // CondiciÃ³n estricta: Soy Lancero Y el destino es Aliado
            const isRelay = (pieceType === 'lanceros' && originalTarget && originalTarget.army === army);

            try {
                // 2. APLICAR MOVIMIENTO SIMULADO
                if (isRelay) {
                    // Intercambio REAL: El aliado (Target) va al origen (r1,c1)
                    // El Lancero (Source) va al destino (r2,c2)
                    logicBoard[r1][c1] = originalTarget;
                    logicBoard[r2][c2] = originalSource;
                } else {
                    // Movimiento estÃ¡ndar: Origen vacÃ­o, destino ocupado por actor
                    logicBoard[r1][c1] = null;
                    logicBoard[r2][c2] = originalSource;
                }

                // 3. CALCULAR DÃ“NDE QUEDA EL REY TRAS LA SIMULACIÃ“N
                let checkR = currentKingR;
                let checkC = currentKingC;

                if (pieceType === 'rey') {
                    // A. Si movÃ­ el rey normal, ahora estÃ¡ en destino (r2,c2)
                    checkR = r2; checkC = c2;
                } else if (isRelay && originalTarget.type === 'rey') {
                    // B. Si soy Lancero y relevo al Rey, el Rey acaba en mi origen (r1,c1)
                    checkR = r1; checkC = c1;
                }
                // C. Si movÃ­ otra pieza y no toquÃ© al Rey, checkR/checkC siguen igual

                // 4. VERIFICAR AMENAZAS EN LA UBICACIÃ“N FINAL DEL REY
                const attackers = getAttackers(checkR, checkC, army);

                // Si hay atacantes, el movimiento es suicida (false)
                return (attackers.length === 0);

            } catch (e) {
                console.error("Error simulaciÃ³n:", e);
                return true; // Ante error, permitimos el movimiento por seguridad
            } finally {
                // 5. REVERTIR SIEMPRE EL TABLERO
                logicBoard[r1][c1] = originalSource;
                logicBoard[r2][c2] = originalTarget;
            }
        }

        // =========================================================
        //  MODO DEBUG: DESPLIEGUE ALEATORIO AUTOMÃTICO (CORREGIDO)
        // =========================================================
        // =========================================================
        //  MODO DEBUG: CAOS TOTAL (Aleatoriedad Pura)
        // =========================================================
        function activateDebugMode() {
            if (!confirm(t('debug_confirm'))) return;

            console.log("ğŸ› ï¸ Ejecutando Despliegue IA v6.0 (Influencia)...");

            init();
            // Limpieza inicial de variables globales
            logicBoard = Array(10).fill().map(() => Array(10).fill(null));
            fortressPos = { rojo: null, negro: null };
            dungeons = { rojo: [], negro: [] };
            shotHighlights = [];

            // ConfiguraciÃ³n de bandos
            p1Color = 'rojo'; p1Territory = 'north';
            p2Color = 'negro';

            // --- AQUÃ ESTÃ EL CAMBIO CLAVE ---
            // En lugar de colocar cosas manualmente paso a paso,
            // llamamos al "Cerebro" que ya sabe hacerlo todo (Fortaleza + MontaÃ±as + Tropas)

            setupAI_Smart('rojo');
            setupAI_Smart('negro');

            // Iniciar la partida
            gameState = 'playing';
            turnColor = 'rojo';

            showNotification(t('debug_active'));
            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

        function changeLanguage(selectedLang) {
            currentLang = selectedLang;

            // 1. GESTIÃ“N DE LAS REGLAS (HTML ESTÃTICO)
            // Ocultamos todos los bloques de reglas
            document.querySelectorAll('.rules-container').forEach(el => el.style.display = 'none');

            // Mostramos el bloque del idioma seleccionado
            const ruleBlock = document.getElementById(`rules-${currentLang}`);
            if (ruleBlock) {
                ruleBlock.style.display = 'block';
            } else {
                // Fallback: Si aÃ±adiste un idioma al selector pero no escribiste sus reglas HTML,
                // mostramos inglÃ©s por defecto para que no quede vacÃ­o.
                document.getElementById('rules-en').style.display = 'block';
            }

            // 2. ACTUALIZAR TÃTULO DEL MODAL
            // (Idealmente esto tambiÃ©n deberÃ­a ir al diccionario, pero por ahora lo gestionamos aquÃ­)
            const title = document.getElementById('rules-title');
            if (currentLang === 'es') title.innerText = 'ğŸ“œ REGLAMENTO';
            else title.innerText = 'ğŸ“œ COTADREZ RULES';

            // 3. ACTUALIZAR ETIQUETAS DINÃMICAS
            document.querySelectorAll('.dungeon-label').forEach(el => {
                el.innerText = t('dungeon_title');
            });

            // 4. ACTUALIZAR INTERFAZ DE JUEGO
            updateStatusBar();

            // Limpiamos tooltips antiguos para evitar mezclas
            if (boardHelpTimer) clearTimeout(boardHelpTimer);
        }

        // --- MOTOR DE IA: GENERADOR DE MOVIMIENTOS ---

        function generateAllMoves(board, army, currentReserves) {
            let allMoves = [];

            // 1. Recorremos el tablero buscando piezas de 'army'
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = board[r][c];
                    if (!piece || piece.army !== army) continue;

                    // 2. Para esta pieza, probamos los 100 destinos posibles (igual que activateBoardHelp)
                    // (Nota: Se puede optimizar, pero para 10x10 esto es rapidÃ­simo)
                    for (let tr = 0; tr < 10; tr++) {
                        for (let tc = 0; tc < 10; tc++) {
                            if (r === tr && c === tc) continue;

                            // A. Filtro GeomÃ©trico (Tu funciÃ³n actual)
                            if (isValidMove(piece.type, r, c, tr, tc)) {

                                // B. Filtro de ObstÃ¡culos (Copiado de activateBoardHelp)
                                const target = board[tr][tc];
                                const isMountain = target && target.type === 'montana';
                                const isFortress = target && target.type === 'fortaleza';
                                const isAlly = target && target.army === army && piece.type !== 'lanceros'; // Lanceros sÃ­ pueden
                                const isWater = terrain[tr][tc] === 'water' && piece.type !== 'trabuquete' && piece.type !== 'escorpion' && piece.type !== 'dragon';

                                if (isMountain || isFortress || isAlly || isWater) continue;

                                // C. Filtro de Seguridad (Jaque)
                                // IMPORTANTE: isSimulatedMoveSafe usa 'logicBoard' global. 
                                // Para la IA real, habrÃ­a que adaptarlo para usar el 'board' virtual que le pasamos.
                                // Por ahora, asumimos que validamos sobre el tablero real.
                                let isSafe = true;
                                try {
                                    isSafe = isSimulatedMoveSafe(piece.type, r, c, tr, tc, army);
                                } catch (e) { }

                                // D. Si pasa todo, lo guardamos en la lista
                                if (isSafe) {
                                    allMoves.push({
                                        from: { r: r, c: c },
                                        to: { r: tr, c: tc },
                                        piece: piece.type
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // --- B. MOVIMIENTOS DE DESPLIEGUE (NUEVO) ---
            // Solo si estamos jugando, no en fases raras
            const myFortPos = fortressPos[army];
            if (myFortPos && currentReserves) { // Verificamos que existan reservas clonadas

                // 1. Identificar casillas vacÃ­as en el anillo
                // (Reutilizamos lÃ³gica de isInExitZone optimizada)
                const minR = Math.max(0, myFortPos.r - 1);
                const maxR = Math.min(9, myFortPos.r + 2);
                const minC = Math.max(0, myFortPos.c - 1);
                const maxC = Math.min(9, myFortPos.c + 2);

                let validSpots = [];
                for (let r = minR; r <= maxR; r++) {
                    for (let c = minC; c <= maxC; c++) {
                        // Debe ser zona de salida, estar vacÃ­a y no ser agua (salvo excepciones)
                        if (isInExitZone(r, c, myFortPos) && board[r][c] === null && terrain[r][c] !== 'water') {
                            validSpots.push({ r, c });
                        }
                    }
                }

                // 2. Si hay huecos, probar a sacar cada tipo de unidad disponible
                if (validSpots.length > 0) {
                    for (const [type, qty] of Object.entries(currentReserves[army])) {
                        if (type === 'montana' || type === 'fortaleza') continue; // Esos no se mueven
                        if (qty > 0) {
                            // Por cada hueco, generamos una opciÃ³n de "SACAR TROPA"
                            for (const spot of validSpots) {
                                allMoves.push({
                                    type: 'deploy', // Marcamos que es un despliegue
                                    piece: type,
                                    from: 'reserve',
                                    to: { r: spot.r, c: spot.c }
                                });
                            }
                        }
                    }
                }
            }

            return allMoves;
        }

        // --- MOTOR DE IA: EVALUACIÃ“N DE TABLERO ---

        const PIECE_VALUES = {
            'rey': 20000,      // Si pierdes el Rey, pierdes todo. Valor infinito.
            'dragon': 900,     // La pieza mÃ¡s poderosa mÃ³vil.
            'elefante': 500,   // Tanque muy duro.
            'c_pesada': 350,   // CaballerÃ­a fuerte.
            'c_ligera': 300,   // CaballerÃ­a rÃ¡pida.
            'trabuquete': 400, // ArtillerÃ­a valiosa.
            'escorpion': 400,
            'arqueros': 200,   // Rango.
            'lanceros': 150,   // Utilidad tÃ¡ctica.
            'chusma': 100,     // Carne de caÃ±Ã³n.
            'fortaleza': 0,    // No se captura/mueve, no suma puntos de "material" mÃ³vil.
            'montana': 0
        };

        function evaluateBoard(board, myArmy) {
            let score = 0;
            const enemyArmy = (myArmy === 'rojo') ? 'negro' : 'rojo';

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = board[r][c];
                    if (piece) {
                        // Obtenemos el valor base de la pieza
                        const value = PIECE_VALUES[piece.type] || 0;

                        if (piece.army === myArmy) {
                            score += value;

                            // --- BONUS POSICIONALES (HeurÃ­stica simple) ---
                            // 1. Dominio del centro (Filas 3-6, Col 3-6)
                            if (r >= 3 && r <= 6 && c >= 3 && c <= 6) {
                                score += 10;
                            }

                            // 2. Bonus por avanzar (Si soy rojo/norte, avanzar es aumentar fila)
                            // (Ajustar segÃºn orientaciÃ³n del tablero, esto es un ejemplo genÃ©rico)
                            /* if (myArmy === 'rojo') score += r * 5; */

                        } else if (piece.army === enemyArmy) {
                            score -= value;

                            // Restamos tambiÃ©n sus bonus posicionales
                            if (r >= 3 && r <= 6 && c >= 3 && c <= 6) {
                                score -= 10;
                            }
                        }
                    }
                }
            }
            return score;
        }

        // FunciÃ³n auxiliar para aplicar un movimiento en la mente de la IA (sin grÃ¡ficos)
        function applyVirtualMove(board, move) {
            // move = { from: {r,c}, to: {r,c}, piece: type }
            const newBoard = JSON.parse(JSON.stringify(board)); // Clonamos tablero

            // Ejecutamos el movimiento simple (pisar destino, limpiar origen)
            newBoard[move.to.r][move.to.c] = newBoard[move.from.r][move.from.c];
            newBoard[move.from.r][move.from.c] = null;

            return newBoard;
        }

        function applyVirtualStateChange(board, reserves, move, army) {
            // 1. Clonamos TODO
            const newBoard = JSON.parse(JSON.stringify(board));
            const newReserves = JSON.parse(JSON.stringify(reserves));

            if (move.type === 'deploy') {
                // --- EJECUTAR DESPLIEGUE ---
                // Poner en tablero
                newBoard[move.to.r][move.to.c] = { type: move.piece, army: army };
                // Restar de reserva virtual
                newReserves[army][move.piece]--;

            } else {
                // --- EJECUTAR MOVIMIENTO NORMAL ---
                newBoard[move.to.r][move.to.c] = newBoard[move.from.r][move.from.c];
                newBoard[move.from.r][move.from.c] = null;
            }

            return { board: newBoard, reserves: newReserves };
        }


        // --- MOTOR DE IA: EL CEREBRO (MINIMAX v2.0 - Con Reservas) ---

        function minimax(board, reserves, depth, isMaximizing, alpha, beta, army) {
            // 1. Caso Base
            if (depth === 0) {
                return evaluateBoard(board, army);
            }

            const currentArmy = isMaximizing ? army : (army === 'rojo' ? 'negro' : 'rojo');

            // --- TRUCO DE MAGIA (SWAP GLOBAL) ---
            const realBoard = logicBoard;
            const realReserves = reserves; // No hay variable global de reservas directas, pero pasamos la virtual

            // EngaÃ±amos a las validaciones globales poniendo nuestro tablero virtual
            logicBoard = board;

            // Generamos movimientos pasando TAMBIÃ‰N las reservas actuales
            const moves = generateAllMoves(board, currentArmy, reserves);

            logicBoard = realBoard; // Restauramos la realidad
            // ------------------------------------

            if (moves.length === 0) {
                return evaluateBoard(board, army);
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    // Usamos la nueva funciÃ³n que devuelve {board, reserves}
                    const nextState = applyVirtualStateChange(board, reserves, move, currentArmy);

                    // Pasamos el nuevo tablero Y las nuevas reservas a la siguiente recursiÃ³n
                    const eval = minimax(nextState.board, nextState.reserves, depth - 1, false, alpha, beta, army);

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const nextState = applyVirtualStateChange(board, reserves, move, currentArmy);

                    const eval = minimax(nextState.board, nextState.reserves, depth - 1, true, alpha, beta, army);

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // --- FUNCIÃ“N PÃšBLICA: ORDENAR A LA IA QUE JUEGUE (v2.0) ---
        function playAITurn() {
            if (gameState !== 'playing') {
                console.warn("La IA no puede jugar en fase de despliegue o game-over.");
                return;
            }

            console.log(`ğŸ¤– IA (${turnColor}) calculando con Reservas...`);
            const startTime = Date.now();

            // 1. Generar opciones iniciales (pasando las reservas REALES globales)
            // Nota: 'reserves' es tu variable global del juego.
            const myMoves = generateAllMoves(logicBoard, turnColor, reserves);

            if (myMoves.length === 0) {
                console.log("IA: No tengo movimientos.");
                return;
            }

            let bestMove = null;
            let bestValue = -Infinity;
            const DEPTH = 3; // Profundidad de pensamiento

            // 2. Evaluar cada opciÃ³n
            for (const move of myMoves) {
                // Simular el primer paso
                const nextState = applyVirtualStateChange(logicBoard, reserves, move, turnColor);

                // Llamar a Minimax con el estado resultante
                const boardValue = minimax(nextState.board, nextState.reserves, DEPTH - 1, false, -Infinity, Infinity, turnColor);

                // console.log(`OpciÃ³n: ${move.piece} (${move.type}) -> Val: ${boardValue}`);

                if (boardValue > bestValue) {
                    bestValue = boardValue;
                    bestMove = move;
                }
            }

            const endTime = Date.now();
            console.log(`ğŸ¤– IA decidiÃ³ en ${(endTime - startTime) / 1000}s. Valor: ${bestValue}`);

            // 3. EJECUTAR LA JUGADA EN EL MUNDO REAL
            if (bestMove) {
                if (bestMove.type === 'deploy') {
                    // A. EJECUTAR DESPLIEGUE (RESERVA -> TABLERO)
                    console.log(`ğŸ¤– AcciÃ³n: Desplegar ${bestMove.piece}`);

                    // Simulamos evento de Drop desde la Reserva
                    const mockEvent = {
                        preventDefault: () => { },
                        dataTransfer: {
                            getData: () => JSON.stringify({
                                source: 'reserve',
                                army: turnColor,
                                type: bestMove.piece,
                                originR: null, originC: null
                            })
                        }
                    };
                    handleDrop(mockEvent, bestMove.to.r, bestMove.to.c);

                } else {
                    // B. EJECUTAR MOVIMIENTO NORMAL (TABLERO -> TABLERO)
                    console.log(`ğŸ¤– AcciÃ³n: Mover ${bestMove.piece}`);

                    const mockEvent = {
                        preventDefault: () => { },
                        dataTransfer: {
                            getData: () => JSON.stringify({
                                source: 'board',
                                army: turnColor,
                                type: bestMove.piece,
                                originR: bestMove.from.r,
                                originC: bestMove.from.c
                            })
                        }
                    };
                    handleDrop(mockEvent, bestMove.to.r, bestMove.to.c);
                }
            }
        }

        // =================================================================
        //  MÃ“DULO DE IA UNIFICADO v6.2 (Limpio y Sin Duplicados)
        // =================================================================

        // 1. HELPER: Validar Zona de Despliegue
        function isInDeploymentZone(r, army) {
            if (r < 0 || r > 9) return false;
            // Rojo (Norte): Filas 0 a 4
            if (army === 'rojo') return r <= 4;
            // Negro (Sur): Filas 5 a 9
            if (army === 'negro') return r >= 5;
            return false;
        }

        // 2. HELPER: Validar Casilla para MontaÃ±a (Sustituye a la antigua isValidSpot)
        function isValidMountainSpot(r, c) {
            if (r < 0 || r > 9 || c < 0 || c > 9) return false;
            if (logicBoard[r][c] !== null) return false; // Debe estar vacÃ­a
            if (terrain[r][c] === 'water') return false; // No en agua
            return true;
        }

        // 3. HELPER: Detectar montaÃ±as pegadas (Para evitar muros)
        function hasAdjacentMountain(r, c) {
            const deltas = [{ r: -1, c: 0 }, { r: 1, c: 0 }, { r: 0, c: -1 }, { r: 0, c: 1 }];
            for (const d of deltas) {
                const nr = r + d.r;
                const nc = c + d.c;
                if (nr >= 0 && nr < 10 && nc >= 0 && nc < 10) {
                    const cell = logicBoard[nr][nc];
                    if (cell && cell.type === 'montana') return true;
                }
            }
            return false;
        }

        // 4. EL EXPLORADOR: Calcula destinos vÃ¡lidos (Soporta Niebla de Guerra)
        function getValidMoves(type, r, c, activeArmy, blindMode = false) {
            let moves = [];
            const pieceArmy = activeArmy || (logicBoard[r][c] ? logicBoard[r][c].army : turnColor);

            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    if (r === tr && c === tc) continue;

                    if (isValidMove(type, r, c, tr, tc)) {
                        // ValidaciÃ³n de ObstÃ¡culos
                        let target = logicBoard[tr][tc];

                        // En Modo Ciego (Despliegue), ignoramos enemigos para ver el terreno puro
                        if (blindMode && target && target.army !== pieceArmy) {
                            target = null;
                        }

                        const isMountain = target && target.type === 'montana';
                        const isFortress = target && target.type === 'fortaleza';
                        const isAlly = target && target.army === pieceArmy && type !== 'lanceros';

                        const isWater = terrain[tr][tc] === 'water' &&
                            type !== 'trabuquete' &&
                            type !== 'escorpion' &&
                            type !== 'dragon';

                        if (isMountain || isFortress || isAlly || isWater) continue;

                        moves.push({ r: tr, c: tc });
                    }
                }
            }
            return moves;
        }

        // 5. EL ESTRATEGA: EvalÃºa influencia
        function evaluatePositionInfluence(r, c, type, army) {
            let score = 0;
            const originalContent = logicBoard[r][c];
            logicBoard[r][c] = { army: army, type: type };

            // A. OFENSIVA (VisiÃ³n ciega: potencial del terreno)
            const moves = getValidMoves(type, r, c, army, true);
            logicBoard[r][c] = originalContent;

            moves.forEach(m => {
                score += 10;
                // Bonus agresivo hacia el centro
                if (army === 'rojo' && m.r > 4) score += 5;
                if (army === 'negro' && m.r < 5) score += 5;
            });

            // B. DEFENSIVA (Cobertura de aliados)
            let defendingAllies = 0;
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    const ally = logicBoard[i][j];
                    if (ally && ally.army === army) {
                        const allyMoves = getValidMoves(ally.type, i, j, army, true);
                        if (allyMoves.some(m => m.r === r && m.c === c)) {
                            defendingAllies++;
                            if (['trabuquete', 'elefante', 'escorpion'].includes(ally.type)) score += 50;
                            else score += 20;
                        }
                    }
                }
            }
            // Los VIPs odian estar solos
            if (defendingAllies === 0 && ['rey', 'trabuquete'].includes(type)) {
                score -= 60;
            }
            return score;
        }

        // 6. EL ARQUITECTO: Despliegue Principal (Fortaleza Aleatoria + Tropas)
        function setupAI_Smart(aiArmy) {
            console.log(`ğŸ—ï¸ IA (${aiArmy}): Despliegue v6.2...`);

            // Limpieza
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    if (logicBoard[r][c] && logicBoard[r][c].army === aiArmy) logicBoard[r][c] = null;
                }
            }
            for (const [type, data] of Object.entries(CONFIG.pieces)) reserves[aiArmy][type] = data.qty;

            const isNorth = (aiArmy === 'rojo');
            const validRows = isNorth ? [1, 2] : [7, 8];
            const fwd = isNorth ? 1 : -1;

            // A. FORTALEZA ALEATORIA
            const fortR = validRows[Math.floor(Math.random() * validRows.length)];
            const fortC = Math.floor(Math.random() * 7) + 1;

            logicBoard[fortR][fortC] = { army: aiArmy, type: 'fortaleza' };
            logicBoard[fortR][fortC + 1] = { army: aiArmy, type: 'fortaleza' };
            logicBoard[fortR + fwd][fortC] = { army: aiArmy, type: 'fortaleza' };
            logicBoard[fortR + fwd][fortC + 1] = { army: aiArmy, type: 'fortaleza' };

            fortressPos[aiArmy] = { r: fortR, c: fortC };
            reserves[aiArmy]['fortaleza'] = 0;

            // B. MONTAÃ‘AS
            placeAIMountains_Smart(aiArmy);

            // C. TROPAS (INFLUENCIA CIEGA)
            const deploymentOrder = [
                'trabuquete', 'escorpion', 'dragon', 'elefante',
                'rey', 'c_pesada', 'arqueros', 'lanceros',
                'c_ligera', 'chusma'
            ];

            for (const type of deploymentOrder) {
                let loopSafety = 0;
                while (reserves[aiArmy][type] > 0 && loopSafety < 100) {
                    loopSafety++;
                    let candidates = [];

                    for (let r = 0; r < 10; r++) {
                        for (let c = 0; c < 10; c++) {
                            if (isInExitZone(r, c, fortressPos[aiArmy]) && logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                                const score = evaluatePositionInfluence(r, c, type, aiArmy);
                                candidates.push({ r, c, score });
                            }
                        }
                    }

                    if (candidates.length === 0) break;

                    candidates.sort((a, b) => b.score - a.score);
                    const topN = Math.min(candidates.length, 3);
                    const pickIndex = Math.floor(Math.random() * topN);
                    const bestMove = candidates[pickIndex];

                    logicBoard[bestMove.r][bestMove.c] = { army: aiArmy, type: type };
                    reserves[aiArmy][type]--;
                }
            }
            console.log(`âœ… IA (${aiArmy}): Listo.`);
            renderBoard();
            updateInventories();
        }

        // 7. EL INGENIERO DE MONTAÃ‘AS
        function placeAIMountains_Smart(army) {
            const fort = fortressPos[army];
            const isNorth = (army === 'rojo');
            const fwd = isNorth ? 1 : -1;
            let mountainsToPlace = 3;
            if (reserves[army]['montana'] < 3) mountainsToPlace = reserves[army]['montana'];

            const isLeftFlank = (fort.c <= 3);
            const isRightFlank = (fort.c >= 6);

            let tier1 = []; let tier2 = [];

            if (isLeftFlank) { tier1.push({ r: 0, c: 4 }); tier1.push({ r: fwd * 2, c: 3 }); tier2.push({ r: 1, c: 3 }); }
            else if (isRightFlank) { tier1.push({ r: 0, c: -3 }); tier1.push({ r: fwd * 2, c: -2 }); tier2.push({ r: 1, c: -2 }); }
            else { tier1.push({ r: fwd * 2, c: -2 }); tier1.push({ r: fwd * 2, c: 3 }); }

            tier1.push({ r: fwd * 3, c: 0 }); tier1.push({ r: fwd * 3, c: 1 });
            tier2.push({ r: 0, c: -1 }); tier2.push({ r: 0, c: 2 }); tier2.push({ r: 1, c: -1 }); tier2.push({ r: 1, c: 2 });
            tier2.push({ r: fwd * 2, c: -1 }); tier2.push({ r: fwd * 2, c: 2 });

            tier1.sort(() => Math.random() - 0.5); tier2.sort(() => Math.random() - 0.5);
            const wishList = [...tier1, ...tier2];

            for (const vec of wishList) {
                if (mountainsToPlace === 0) break;
                const tr = fort.r + vec.r, tc = fort.c + vec.c;
                if (isInDeploymentZone(tr, army) && isValidMountainSpot(tr, tc) && !hasAdjacentMountain(tr, tc)) {
                    logicBoard[tr][tc] = { army: army, type: 'montana' };
                    reserves[army]['montana']--; mountainsToPlace--;
                }
            }
            // Relleno seguridad
            let attempts = 100;
            while (mountainsToPlace > 0 && attempts > 0) {
                let rr = fort.r + Math.floor(Math.random() * 9) - 4;
                let rc = fort.c + Math.floor(Math.random() * 9) - 4;
                if (isInDeploymentZone(rr, army) && isValidMountainSpot(rr, rc)) {
                    logicBoard[rr][rc] = { army: army, type: 'montana' };
                    reserves[army]['montana']--; mountainsToPlace--;
                }
                attempts--;
            }
        }

        // 8. DEBUG MODE (Lanzador)
        function activateDebugMode() {
            if (!confirm(t('debug_confirm'))) return;
            console.log("ğŸ› ï¸ Debug: Iniciando SimulaciÃ³n...");
            init();
            logicBoard = Array(10).fill().map(() => Array(10).fill(null));
            fortressPos = { rojo: null, negro: null };
            currentThreatMap = null;
            p1Color = 'rojo'; p2Color = 'negro';

            // Despliegue independiente
            setupAI_Smart('rojo');
            setupAI_Smart('negro');

            gameState = 'playing';
            turnColor = 'rojo';
            showNotification(t('debug_active'));
            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

    </script>
</body>

</html>
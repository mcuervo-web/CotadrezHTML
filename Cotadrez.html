<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Cotadrez</title>
    <link rel="icon" type="image/svg+xml"
        href="https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main/Negro/Castillo.svg">
    <style>
        :root {
            --c-red: #e74c3c;
            --c-black: #7f8c8d;
            /* Un gris mÃ¡s claro para el borde negro para que se vea sobre el fondo oscuro */
            --c-board-l: #f0d9b5;
            --c-board-d: #b58863;
            --c-water: #3498db;
            --c-bg: #1a252f;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--c-bg);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- CABECERA --- */
        header {
            text-align: center;
            margin-bottom: 5px;
        }

        .game-title {
            font-size: 3em;
            margin: 0;
            letter-spacing: 5px;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            font-weight: 800;
        }

        .status-bar {
            font-size: 1.2em;
            color: var(--c-gold);
            margin-top: 10px;
            margin-bottom: 0;
            font-weight: 500;
            min-height: 1.5em;
            /* Para que no salte si estÃ¡ vacÃ­o */
        }

        /* --- ESTADO CRÃTICO (JAQUE / ASEDIO) --- */
        .status-critical {
            color: #ff2e2e !important;
            /* Rojo brillante */
            font-weight: 800 !important;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            /* Resplandor rojo */
            animation: pulse-text 0.8s infinite alternate;
        }

        /* --- FORTALEZA ASEDIADA (PARPADEO) --- */
        .siege-pulse {
            filter: drop-shadow(0 0 10px var(--c-red)) brightness(1.2);
            animation: pulse-fortress 1s infinite alternate;
            cursor: pointer !important;
            /* Mano para indicar que es clickable */
        }

        @keyframes pulse-fortress {
            from {
                filter: drop-shadow(0 0 5px var(--c-red));
                transform: scale(1);
            }

            to {
                filter: drop-shadow(0 0 15px var(--c-red));
                transform: scale(1.1);
            }
        }

        @keyframes pulse-text {
            from {
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                transform: scale(1);
            }

            to {
                text-shadow: 0 0 20px rgba(255, 0, 0, 1);
                transform: scale(1.02);
            }
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
            height: auto;
            margin-top: 5px;
        }

        /* --- PANELES LATERALES (Inventario + Mazmorra) --- */
        .panel {
            width: 240px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Para que la mazmorra no se salga de los bordes redondeados */
        }

        /* SecciÃ³n Superior: Reserva (Inventario) */
        .inventory-section {
            flex: 1;
            /* Ocupa el espacio restante */
            padding: 5px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }


        /* Resaltado del Anillo de Fortaleza */
        .highlight-ring {
            box-shadow: inset 0 0 0 3px #2ecc71 !important;
            /* Borde verde interior */
            /* background-color: rgba(46, 204, 113, 0.15) !important; */
            /* Fondo sutil */
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }

            50% {
                box-shadow: inset 0 0 0 1px #2ecc71;
            }

            100% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }
        }

        /* Feedback de disparo (Arma y VÃ­ctimas) - VERSIÃ“N INTENSA */
        .shot-highlight {
            /* Borde interior muy marcado y fondo teÃ±ido */
            box-shadow: inset 0 0 40px rgb(29, 4, 1) !important;
            /* background-color: rgba(231, 76, 60, 0) !important; */
            animation: pulse-shot 1.5s infinite;
            /* Pulso mÃ¡s rÃ¡pido (latido) */
            z-index: 5 !important;
            /* Asegura que se pinte sobre casillas de agua u otras */
        }

        @keyframes pulse-shot {
            0% {
                box-shadow: inset 0 0 40px rgba(27, 4, 2, 0.6);
                /* background-color: rgba(231, 76, 60, 0); */
            }

            50% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* Brillo mÃ¡ximo */
                /* background-color: rgba(231, 76, 60, 0.1); */
            }

            100% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* box-shadow: inset 0 0 40px rgba(231, 76, 60, 0.6); */
                /* background-color: rgba(231, 76, 60, 0); */
            }
        }

        /* Feedback de disparo - ORIGEN (Dorado) */
        .shot-source {
            box-shadow: inset 0 0 40px rgba(241, 196, 15, 0.8) !important;
            /* Gold intenso */
            animation: pulse-shot-gold 1.5s infinite;
            z-index: 5 !important;
        }

        @keyframes pulse-shot-gold {
            0% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }

            50% {
                box-shadow: inset 0 0 50px rgba(241, 196, 15, 1);
            }

            100% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }
        }

        /* SecciÃ³n Inferior: Mazmorra */
        .dungeon-section {
            height: 180px;
            /* TamaÃ±o fijo para la mazmorra */
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
            /* Efecto de profundidad */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dungeon-label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dungeon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            overflow-y: auto;
        }

        /* Estilo para las piezas dentro de la mazmorra */
        .dungeon-list img {
            width: 40px;
            height: 40px;
            margin: 2px;
            filter: grayscale(10%) opacity(0.7);
            /* Efecto "prisionero" */
            transition: all 0.3s ease;
        }

        .dungeon-list img:hover {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.2);
            cursor: help;
        }

        /* Fichas rescatables: Borde brillante o cursor de mano */
        .rescue-target {
            cursor: pointer !important;
            /* box-shadow: 0 0 5px 2px var(--c-gold); */
            /* Brillo dorado de esperanza */
            filter: grayscale(0%) opacity(1) !important;
            /* Se ven vivas */
        }

        /* Items del Inventario (Sin recuadro, icono grande) */
        .inv-item {
            width: 70px;
            height: 70px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            /* Indicamos que se puede agarrar */
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            /* La imagen ocupa todo el hueco */
            filter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.5));
            /* Sombra para que destaque sobre el fondo */
            transition: transform 0.1s;
        }

        .inv-item:active img {
            transform: scale(0.9);
            /* PequeÃ±o efecto al hacer clic */
        }

        /* El contador de unidades (Badge) */
        .inv-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--c-gold);
            /* Color dorado para destacar */
            color: #1a252f;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        /* --- TABLERO (AÃ±adimos position: relative) --- */
        #board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 15px solid #34495e;
            border-radius: 4px;
            background-color: #2c3e50;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            position: relative;
            /* <--- IMPORTANTE: Para posicionar el Easter Egg */
        }

        /* --- EASTER EGG (BotÃ³n Invisible) --- */
        .debug-egg {
            position: absolute;
            bottom: -15px;
            /* Se sale del contenido para cubrir el borde */
            right: -15px;
            /* Se sale del contenido para cubrir el borde */
            width: 40px;
            /* TamaÃ±o suficiente para acertar con el ratÃ³n */
            height: 40px;
            z-index: 1000;
            /* Por encima de todo */
            cursor: default;
            /* Cursor normal para no levantar sospechas */
            /* background-color: rgba(255,0,0,0.5); <--- Descomenta para ver dÃ³nde estÃ¡ mientras pruebas */
        }

        /* --- CASILLAS --- */
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            /* <--- Nivel base de apilamiento */
            overflow: visible;
            /* <--- Permite que las piezas sobresalgan sin cortarse */
        }

        .light {
            background-color: var(--c-board-l);
        }

        .dark {
            background-color: var(--c-board-d);
        }

        .water {
            background-color: var(--c-water) !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            /* Agua con mÃ¡s profundidad */
        }

        /* PIEZAS CUANDO ESTÃN EN EL TABLERO */
        .piece {
            width: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            height: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            z-index: 100;
            /* <--- IMPORTANTE: Muy alto para estar siempre encima de las casillas */
            position: relative;
            /* Necesario para que el z-index funcione bien */
            cursor: grab;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.6));
            /* Sombra mÃ¡s pronunciada para dar altura */
            pointer-events: auto;
            /* Asegura que reciba los eventos del ratÃ³n */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* GHOSTING (Feedback Visual) */
        .ghost-valid {
            background-color: rgba(46, 204, 113, 0.6) !important;
            /* Verde */
            box-shadow: inset 0 0 0 2px #27ae60;
        }

        .ghost-invalid {
            background-color: rgba(231, 76, 60, 0.6) !important;
            /* Rojo */
            box-shadow: inset 0 0 0 2px #c0392b;
        }

        /* --- VENTANA MODAL Y REGLAS --- */
        .modal {
            display: none;
            /* Oculto por defecto */
            position: fixed;
            z-index: 2000;
            /* Por encima de todo */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.85);
            /* Fondo oscuro */
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: #2c3e50;
            margin: 5% auto;
            padding: 20px;
            border: 2px solid var(--c-gold);
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            color: #ecf0f1;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-size: 0.95em;
            line-height: 1.6;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .close-btn {
            color: #bdc3c7;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: var(--c-red);
        }

        /* BotÃ³n de idioma (dentro del modal) */
        .btn-lang {
            background: transparent;
            border: 1px solid #7f8c8d;
            color: #bdc3c7;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            margin-right: 20px;
            transition: all 0.3s;
        }

        .btn-lang:hover {
            border-color: var(--c-gold);
            color: var(--c-gold);
            background-color: rgba(241, 196, 15, 0.1);
        }

        /* BotÃ³n principal (Footer) */
        footer {
            margin-top: 15px;
            margin-bottom: 10px;
            text-align: center;
        }

        .btn-rules {
            background: none;
            border: 1px solid var(--c-gold);
            color: var(--c-gold);
            padding: 5px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            text-transform: uppercase;
            font-weight: bold;
            transition: all 0.3s;
        }

        .btn-rules:hover {
            background-color: var(--c-gold);
            color: #1a252f;
            box-shadow: 0 0 10px var(--c-gold);
        }

        /* Formato de texto */
        .rules-container h3 {
            color: var(--c-gold);
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-top: 20px;
        }

        .rules-container h4 {
            color: #3498db;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        .rules-container ul,
        .rules-container ol {
            padding-left: 20px;
        }

        .rules-container li {
            margin-bottom: 5px;
        }

        /* Ocultar inglÃ©s por defecto */
        #rules-en {
            display: none;
        }

        #rules-es {
            display: block;
        }
    </style>
</head>

<body>

    <header>
        <h1 class="game-title">COTADREZ</h1>
        <div id="status-bar" class="status-bar">Elige tu ejÃ©rcito y sitÃºa en el tablero tu fortaleza</div>
    </header>

    <div class="main-container">
        <div class="panel" id="panel-rojo" style="border-color: var(--c-red);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-rojo"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-rojo"></div>
            </div>
        </div>

        <div id="board"></div>

        <div class="panel" id="panel-negro" style="border-color: var(--c-black);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-negro"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-negro"></div>
            </div>
        </div>
    </div>

    <footer>
        <button class="btn-rules" onclick="toggleRules()">ğŸ“œ Reglamento / Rules</button>
    </footer>


    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="rules-title" style="margin:0; color: var(--c-gold);">ğŸ“œ REGLAMENTO DEL COTADREZ</h2>
                <div style="display: flex; align-items: center;">
                    <button id="langToggleBtn" class="btn-lang" onclick="toggleLanguage()">Read in English</button>
                    <span class="close-btn" onclick="toggleRules()">&times;</span>
                </div>
            </div>

            <div id="rules-es" class="rules-container">
                <h3>ğŸ¯ OBJETIVO</h3>
                <p>El objetivo es simple y brutal: <strong>Capturar al ğŸ‘‘ Rey enemigo</strong>. Puedes lograrlo mediante
                    un
                    <strong>Jaque Mate</strong> tradicional en el tablero o asediando su ğŸ° Fortaleza hasta obligarle a
                    salir y aniquilarlo.
                </p>
                <h3>0. SISTEMA DE AYUDA</h3>
                <ol>
                    <li>MÃ¡ntÃ©n el ratÃ³n sobre cada una de las unidades durante <strong>1 segundo</strong> para que se
                        active las Ayuda Visual. Son una serie de iconos que aparecen en la linea de Notificaciones
                        (bajo el tÃ­tulo) te recuerdan cÃ³mo mover. QuÃ© obstÃ¡culos debes tener en cuenta. Y cuales son
                        las caracterÃ­sticas especiales de esa unidad.</li>
                    <li> Si lo mantienes durante <strong>3 segundos</strong> se activarÃ¡ una ayuda visual en el tablero,
                        mostrÃ¡ndote a que casillas puedes ir y cuales de encuentran bloqueadas.</li>
                </ol>

                <h3>1. FASE DE DESPLIEGUE (Niebla de Guerra)</h3>
                <ol>
                    <li><strong>ğŸ° La Fortaleza:</strong> Debes ğŸ—ï¸ construirla al principio: define tu ğŸš© Territorio
                        (Norte o Sur)
                        y tus colores (Rojo y Oro o Negro y Plata). Ninguna unidad puede â›” atravesarla. Es la
                        Ãºnica unidad que puede situarse sobre casillas ocupadas por ğŸŒŠ Agua. Si no has desplegado las
                        tropas puedes
                        devolverla a la Reserva pulsando sobre ella y colocarla en otro lugar. Durante la partida no se
                        puede mover (â¡ï¸:â›”)</li>
                    <li><strong>ğŸª– Las Tropas (ğŸ¤ Aliadas o ğŸ§¨ Enemigas):</strong> Arrastra tus unidades desde la
                        Reserva al <strong>Anillo de
                            Salida</strong> (las 12 casillas que rodean tu ğŸ° Fortaleza). Si en esta fase quieres
                        devolver alguna unidad a la
                        Reserva arrÃ¡strala fuera del Anillo de Salida. Las piezas que no tengan hueco en el Anillo de
                        Salida se quedan temporalmente en la Reserva.</li>
                    <li><strong>ğŸ”ï¸ Las MontaÃ±as:</strong> Se pueden ğŸ—ï¸ colocar en cualquier lugar de tu ğŸš© Territorio.
                        Solo los ğŸ‰ dragones pueden volar por encima de ellas. Durante la partida no se pueden mover
                        (â¡ï¸:â›”).</li>
                    <li><strong>Final del turno:</strong> Para indicar que has terminado el despliegue de tu ejÃ©rcito,
                        haz click en tu Fortaleza.
                        Ten en cuenta que no te dejarÃ¡ terminar el turno hasta que hayas colocado todas las ğŸ”ï¸ MontaÃ±as
                        y al menos una unidad.</li>
                    <li><strong>Â¡A la Batalla!:</strong> El Jugador 2 despliega "a ciegas". Al finalizar el turno
                        de despliegue del Jugador 1, se oculta su ejÃ©cito para que el Jugador 2 no tenga ventaja.</li>
                </ol>

                <h3>2. MOVIMIENTO Y COMBATE</h3>
                <p>Los movimientos se realizan por turnos, el marco del tablero indica el color del ejercito que tiene
                    el turno. En un turno, se puede mover, disparar, o sacar unidades de la Reserva.
                </p>
                <p>Las piezas capturadas van a la <strong>Mazmorra</strong> del enemigo. Â¡PodrÃ¡s rescatarlas luego!
                    Asediando la ğŸ° Fortaleza enemiga (VER 3. MECÃNICA DEL ASEDIO).
                </p>

                <h4>ğŸ›¡ï¸ Unidades BÃ¡sicas</h4>
                <ul>
                    <li><strong>ğŸ‘‘ Rey:</strong> Se mueve 1 casilla en cualquier direcciÃ³n (â¬†ï¸:1âœ–ï¸â•). Es la pieza
                        <strong>"CLAVE":</strong> si la capturan se termina la partida.
                        No puede mover a una casillas bajo âš ï¸ Amenaza o bloqueada (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸).
                    </li>
                    <li><strong>ğŸšï¸ Chusma:</strong> Se mueve 1 casilla ortogonal (â¬†ï¸:1â•). No puede mover a casillas
                        bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Marcha Forzada (âš¡:+1ğŸšï¸)":</strong> Mueve 2
                        unidades de chusma distintas en el mismo turno. Puedes renunciar a la "Marcha Forzada" haciendo
                        click sobre la unidad que acabas de mover.</li>
                    <li><strong>ğŸ”± Lancero:</strong> Mueve 1 casilla ortogonal (â¬†ï¸:1â•). No puede mover a casillas
                        bloqueadas (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Relevo (âš¡:ğŸ¤ğŸ”„)":</strong> Intercambia
                        su posiciÃ³n con un ğŸ¤ Aliado si movemos a la casilla ocupada por este.</li>
                    <li><strong>ğŸ¹ Arquero:</strong> Mueve 1 casilla diagonal (â¬†ï¸:1âœ–ï¸). No puede mover a casillas
                        bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Largo Alcance (âš¡:ğŸ§¨+1)":</strong> Puede mover 2
                        casillas
                        para capturar a una unidad ğŸ§¨ Enemiga.</li>
                </ul>

                <h4>ğŸ CaballerÃ­a y Bestias</h4>
                <ul>
                    <li><strong>ğŸ´ Cab. Ligera:</strong> Mueve en "L" diagonal (â¬†ï¸:2+1âœ”ï¸). <strong>NO:</strong> puede
                        atravesar casillas bloqueadas (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>EXTRA: "Salto (âš¡:ğŸ‘»ğŸª–)":</strong> Atraviesa tropas ğŸ¤ aliadas y ğŸ§¨ enemigas.
                    </li>
                    <li><strong>ğŸ›¡ï¸ Cab. Pesada:</strong> Mueve en "L" ortogonal (â¬†ï¸:2+1L).<strong>NO:</strong> puede
                        atravesar casillas bloqueadas (â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠ).
                        <strong>EXTRA: "Paso Preferente (âš¡:ğŸ‘»ğŸ¤)":</strong> Atraviesa tropas ğŸ¤ aliadas.
                    </li>
                    <li><strong>ğŸ˜ Elefante:</strong> Mueve ortogonal (â¬†ï¸:â•). No puede atravesar casillas bloqueadas
                        (â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠ).<strong>EXTRA: "Piel Dura (âš¡:ğŸ”’+ğŸ§¨ğŸ§¨oğŸ‰):"</strong> Inmune a
                        ataques individuales (necesita 2+ enemigos o un ğŸ‰ DragÃ³n para capturarlo).</li>
                    <li><strong>ğŸ‰ DragÃ³n:</strong> Mueve en cualquier direcciÃ³n (â¬†ï¸:â•âœ–ï¸). No puede atravesar casillas
                        bloqueadas (â›”:ğŸª–ğŸ°).<strong>EXTRA: "Vuelo (âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ):"</strong>
                        Puede volar sobre las ğŸ”ï¸ MontaÃ±as y el ğŸŒŠ Agua y capturar ğŸ˜ elefantes sin apoyo.</li>
                </ul>

                <h4>âš™ï¸ Armas de Asedio</h4>
                <ul>
                    <li>Las <strong>Armas de Asedio</strong> pueden â¬†ï¸ mover (a una casilla ğŸ”² vacÃ­a: solo capturan
                        disparando) o ğŸ¯ disparar, pero no pueden hacer las dos cosas en el mismo turno.</li>
                    <li><strong>â˜„ï¸ Trabuquete:</strong> Mueve Diagonal 1 casilla (debe estar ğŸ”² vacÃ­a: solo captura
                        disparando) (â¬†ï¸:1âœ–ï¸ğŸ”²). Dispara Ortogonal (ğŸ¯:â•)
                        No puede atravesar casillas bloqueadas (â›”:ğŸ°ğŸ”ï¸).<strong>EXTRA: "Tiro ParabÃ³lico
                            (âš¡:ğŸ‘»ğŸª–ğŸŒŠ):"</strong> Puede disparar atravesado el ğŸŒŠ Agua y las
                        casillas ocupadas por ğŸ§¨ enemigos o ğŸ¤ aliados.</li>
                    <li><strong>ğŸ¦‚ EscorpiÃ³n:</strong> Mueve Ortogonal 1 casilla (debe estar ğŸ”² vacÃ­a: solo captura
                        disparando) (â¬†ï¸:1â•ğŸ”²). Dispara Diagonal (ğŸ¯:âœ–ï¸)
                        No puede atravesar casillas bloqueadas (â›”:ğŸ¤ğŸ°ğŸ”ï¸).<strong>EXTRA: "Brocheta
                            (âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨):"</strong> Puede disparar atravesado el ğŸŒŠ Agua y las
                        casillas ocupadas por ğŸ§¨ enemigos si hay una segunda unidad ğŸ§¨ enemiga a menos de 2 casillas de
                        distancia y la casilla intermedia, si la hay, esta
                        ğŸ”² vacÃ­a u ocupada por ğŸŒŠ agua: en ese caso puede capturar ambas (arrastra hasta la segunda
                        unidad enemiga).</li>
                </ul>

                <h3>3. MECÃNICA DEL ASEDIO</h3>
                <p><strong>PASO 1: AMENAZA</strong><br>Coloca <strong>2+ unidades</strong> ğŸ¤ Aliadas en el Anillo de
                    Salida de la ğŸ° Fortaleza
                    ğŸ§¨ Enemiga.</p>
                <p><strong>PASO 2: DEFENSA</strong><br>El defensor tiene <strong>1 turno</strong> para romper el cerco.
                </p>
                <p><strong>PASO 3: EJECUCIÃ“N</strong><br>Si falla, el atacante pulsa la ğŸ° Fortaleza para EJECUTAR el
                    ASEDIO.</p>
                <p><strong>PASO 4: CONSECUENCIAS</strong></p>
                <ul>
                    <li><strong>Rescate:</strong> El atacante libera 1 prisionero pulsando sobre Ã©l en la mazmorra
                        enemiga. Sus tropas vuelven a su Reserva.</li>
                    <li><strong>Intercambio de Rehenes:</strong> El defensor salva 1 unidad (si hubo Rescate) sacÃ¡ndola
                        de la Reserva al Anillo de Salida o <strong>PIERDE
                            TODO</strong> (si no habÃ­a en su Mazmorra ninguna unidad con la que negociar el
                        intercambio).</li>
                </ul>
            </div>

            <div id="rules-en" class="rules-container">
                <h3>ğŸ¯ OBJECTIVE</h3>
                <p>The objective is simple and brutal: <strong>Capture the enemy ğŸ‘‘ King</strong>. You can achieve this
                    through a traditional <strong>Checkmate</strong> on the board or by besieging their ğŸ° Fortress
                    until
                    they are forced to come out and be annihilated.
                </p>
                <h3>0. HELP SYSTEM</h3>
                <ol>
                    <li>Hover your mouse over any unit for <strong>1 second</strong> to activate Visual Aid. A series of
                        icons
                        will appear in the Notification bar (under the title) to remind you how it moves, which
                        obstacles
                        to avoid, and what the unit's special characteristics are.</li>
                    <li>If you hold it for <strong>3 seconds</strong>, a visual aid will activate on the board, showing
                        you
                        which squares you can go to and which ones are blocked.</li>
                </ol>

                <h3>1. DEPLOYMENT PHASE (Fog of War)</h3>
                <ol>
                    <li><strong>ğŸ° The Fortress:</strong> You must ğŸ—ï¸ build it first: define your ğŸš© Territory (North
                        or South)
                        and your colors (Red & Gold or Black & Silver). No unit can â›” pass through it. It is the
                        only unit that can be placed on ğŸŒŠ Water tiles. If you haven't deployed troops yet, you can
                        return
                        it to the Reserve by clicking on it and placing it elsewhere. It cannot move during the game
                        (â¡ï¸:â›”).</li>
                    <li><strong>ğŸª– The Troops (ğŸ¤ Allies or ğŸ§¨ Enemies):</strong> Drag your units from the Reserve to
                        the
                        <strong>Exit Ring</strong> (the 12 squares surrounding your ğŸ° Fortress). If you want to return
                        a unit
                        to the Reserve during this phase, drag it out of the Exit Ring. Pieces with no room in the Exit
                        Ring
                        stay temporarily in the Reserve.
                    </li>
                    <li><strong>ğŸ”ï¸ The Mountains:</strong> Can be ğŸ—ï¸ placed anywhere in your ğŸš© Territory. Only
                        ğŸ‰ Dragons can fly over them. They cannot move during the game (â¡ï¸:â›”).</li>
                    <li><strong>End of Turn:</strong> To indicate you have finished deploying your army, click on your
                        Fortress.
                        Note that it won't let you finish the turn until you have placed all ğŸ”ï¸ Mountains and at least
                        one unit.</li>
                    <li><strong>To Battle!:</strong> Player 2 deploys "blindly". When Player 1 finishes their deployment
                        turn,
                        their army is hidden so Player 2 has no advantage.</li>
                </ol>

                <h3>2. MOVEMENT AND COMBAT</h3>
                <p>Moves are turn-based; the board frame indicates the color of the active army.
                    In a turn, you can move, shoot, or deploy units from the Reserve.
                </p>
                <p>Captured pieces go to the enemy <strong>Dungeon</strong>. You can rescue them later!
                    By besieging the enemy ğŸ° Fortress (SEE 3. SIEGE MECHANICS).
                </p>

                <h4>ğŸ›¡ï¸ Basic Units</h4>
                <ul>
                    <li><strong>ğŸ‘‘ King:</strong> Moves 1 square in any direction (â¬†ï¸:1âœ–ï¸â•). It is the
                        <strong>"KEY"</strong> piece:
                        if captured, the game ends. Cannot move to âš ï¸ Threatened or blocked squares (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸).
                    </li>
                    <li><strong>ğŸšï¸ Rabble:</strong> Moves 1 orthogonal square (â¬†ï¸:1â•). Cannot move to blocked squares
                        (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Forced March (âš¡:+1ğŸšï¸)":</strong> Move 2 different Rabble units
                        in the
                        same turn. You can waive the "Forced March" by clicking on the unit you just moved.</li>
                    <li><strong>ğŸ”± Lancer:</strong> Moves 1 orthogonal square (â¬†ï¸:1â•). Cannot move to blocked squares
                        (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Relay (âš¡:ğŸ¤ğŸ”„)":</strong> Swaps position with an ğŸ¤ Ally if moving
                        to
                        the square occupied by them.</li>
                    <li><strong>ğŸ¹ Archer:</strong> Moves 1 diagonal square (â¬†ï¸:1âœ–ï¸). Cannot move to blocked squares
                        (â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Long Range (âš¡:ğŸ§¨+1)":</strong> Can move 2 squares to capture an
                        ğŸ§¨ Enemy unit.</li>
                </ul>

                <h4>ğŸ Cavalry and Beasts</h4>
                <ul>
                    <li><strong>ğŸ´ Light Cav.:</strong> Moves in a diagonal "L" (â¬†ï¸:2+1âœ”ï¸). <strong>CANNOT</strong> move
                        through
                        blocked squares (â›”:ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Jump (âš¡:ğŸ‘»ğŸª–)":</strong> Jumps over ğŸ¤ Allied and
                        ğŸ§¨ Enemy troops.
                    </li>
                    <li><strong>ğŸ›¡ï¸ Heavy Cav.:</strong> Moves in an orthogonal "L" (â¬†ï¸:2+1L). <strong>CANNOT</strong>
                        move through
                        blocked squares (â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Right of Way (âš¡:ğŸ‘»ğŸ¤)":</strong> Passes through
                        ğŸ¤ Allied troops.
                    </li>
                    <li><strong>ğŸ˜ Elephant:</strong> Moves orthogonally (â¬†ï¸:â•). Cannot pass through blocked squares
                        (â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠ). <strong>EXTRA: "Thick Skin (âš¡:ğŸ”’+ğŸ§¨ğŸ§¨orğŸ‰):"</strong> Immune to individual
                        attacks
                        (needs 2+ enemies or a ğŸ‰ Dragon to capture it).</li>
                    <li><strong>ğŸ‰ Dragon:</strong> Moves in any direction (â¬†ï¸:â•âœ–ï¸). Cannot pass through blocked squares
                        (â›”:ğŸª–ğŸ°). <strong>EXTRA: "Flight (âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ):"</strong> Can fly over ğŸ”ï¸ Mountains and ğŸŒŠ
                        Water
                        and capture ğŸ˜ Elephants without support.</li>
                </ul>

                <h4>âš™ï¸ Siege Weapons</h4>
                <ul>
                    <li><strong>Siege Weapons</strong> can â¬†ï¸ Move (to an ğŸ”² empty square: they only capture by
                        shooting) or
                        ğŸ¯ Shoot, but cannot do both in the same turn.</li>
                    <li><strong>â˜„ï¸ Trebuchet:</strong> Moves Diagonally 1 square (must be ğŸ”² empty) (â¬†ï¸:1âœ–ï¸ğŸ”²). Shoots
                        Orthogonally (ğŸ¯:â•).
                        Cannot pass through blocked squares (â›”:ğŸ°ğŸ”ï¸). <strong>EXTRA: "Parabolic Shot
                            (âš¡:ğŸ‘»ğŸª–ğŸŒŠ):"</strong>
                        Can shoot over ğŸŒŠ Water and squares occupied by ğŸ§¨ Enemies or ğŸ¤ Allies.</li>
                    <li><strong>ğŸ¦‚ Scorpion:</strong> Moves Orthogonally 1 square (must be ğŸ”² empty) (â¬†ï¸:1â•ğŸ”²). Shoots
                        Diagonally (ğŸ¯:âœ–ï¸).
                        Cannot pass through blocked squares (â›”:ğŸ¤ğŸ°ğŸ”ï¸). <strong>EXTRA: "Skewer
                            (âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨):"</strong>
                        Can shoot over ğŸŒŠ Water and squares occupied by ğŸ§¨ Enemies if there is a second ğŸ§¨ Enemy unit
                        less than
                        2 squares away and the intermediate square, if any, is ğŸ”² empty or ğŸŒŠ water: in that case, it
                        captures both
                        (drag to the second enemy unit).</li>
                </ul>

                <h3>3. SIEGE MECHANICS</h3>
                <p><strong>STEP 1: THREAT</strong><br>Place <strong>2+ ğŸ¤ Allied units</strong> in the Exit Ring of the
                    ğŸ§¨ Enemy ğŸ° Fortress.</p>
                <p><strong>STEP 2: DEFENSE</strong><br>The defender has <strong>1 turn</strong> to break the siege.</p>
                <p><strong>STEP 3: EXECUTION</strong><br>If they fail, the attacker clicks the ğŸ° Fortress to EXECUTE
                    the SIEGE.</p>
                <p><strong>STEP 4: CONSEQUENCES</strong></p>
                <ul>
                    <li><strong>Rescue:</strong> The attacker frees 1 prisoner by clicking on them in the enemy dungeon.
                        Their troops return to their Reserve.</li>
                    <li><strong>Hostage Exchange:</strong> The defender saves 1 unit (if a Rescue occurred) by moving it
                        from
                        the Reserve to the Exit Ring or <strong>LOSES EVERYTHING</strong> (if there were no units in
                        their Dungeon
                        to negotiate the exchange).</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACIÃ“N Y ESTADO ---
        const CONFIG = {
            repo: "https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main",
            // DefiniciÃ³n de cantidades y nombres de archivo
            pieces: {
                'fortaleza': { qty: 1, file: 'Castillo.svg' },
                'montana': { qty: 3, file: 'Montana.svg' },
                'rey': { qty: 1, file: 'Rey.svg' },
                'chusma': { qty: 3, file: 'Chusma.svg' },
                'lanceros': { qty: 3, file: 'Lanza.svg' },
                'arqueros': { qty: 3, file: 'Arco.svg' },
                'c_ligera': { qty: 3, file: 'CaballeriaL.svg' },
                'c_pesada': { qty: 2, file: 'CaballeriaP.svg' },
                'elefante': { qty: 2, file: 'Elefante.svg' },
                'escorpion': { qty: 1, file: 'Escorpion.svg' },
                'trabuquete': { qty: 1, file: 'Catapulta.svg' },
                'dragon': { qty: 1, file: 'Dragon.svg' }
            }
        };

        let reserves = { rojo: {}, negro: {} };
        // Matriz para las PIEZAS (Tropas) - Nombre nuevo para evitar errores
        let logicBoard = Array(10).fill().map(() => Array(10).fill(null));

        // Matriz para el TERRENO (Agua) - Esta ya la tenÃ­as, dÃ©jala igual
        let terrain = Array(10).fill().map(() => Array(10).fill(null));

        let draggingMeta = null; // GuardarÃ¡ quÃ© estamos moviendo

        let fortressPos = { rojo: null, negro: null };

        let chusmaMovedCoords = null; // GuardarÃ¡ {r, c} de la chusma que acaba de mover

        let shotHighlights = []; // GuardarÃ¡ las coordenadas {r,c} del Ãºltimo disparo para mantenerlas visibles

        let isNotificationActive = false; // Bloqueo para mensajes temporales
        let notificationTimer = null;     // Para limpiar el temporizador si se solapan mensajes

        let besiegedArmy = null; // GuardarÃ¡ 'rojo' o 'negro' durante la resoluciÃ³n del asedio

        // CAMBIO: DEJAMOS DE USAR UN BOOLEANO SIMPLE
        let siegeStatus = { rojo: false, negro: false }; // Estado de asedio INDEPENDIENTE para cada bando

        /* let isBesieged = false; // Nueva bandera para el estado de Asedio */

        let currentThreatMap = null; // Mapa Defensivo (DÃ³nde me atacan)

        let currentAttackMap = null; // NUEVO: Mapa Ofensivo (DÃ³nde ataco yo)

        let isCheck = false; // Nueva bandera para el estado de Jaque

        // --- NUEVO: CONTROL DE NOTIFICACIONES AL ARRASTRAR ---
        let lastHoveredTile = null; // Para evitar parpadeos si nos movemos dentro de la misma casilla

        // FunciÃ³n auxiliar para traducir coordenadas (Ej: 0,0 -> "A1")
        function getCoordinateName(r, c) {
            const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
            // Asumimos fila 0 = 1, fila 9 = 10.
            return `${cols[c]}${10 - r}`;
        }

        // Almacena los prisioneros capturados POR cada jugador
        let dungeons = { rojo: [], negro: [] };

        // --- NUEVO: INFORMACIÃ“N DE UNIDADES (HOVER MULTI-IDIOMA) ---
        let hoverTimer = null;

        let boardHelpTimer = null; // Timer para la ayuda visual en el tablero (3s)

        const UNIT_INFO = {
            'es': {
                'rey': "ğŸ‘‘ REY:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸",
                'chusma': "ğŸšï¸ CHUSMA:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:+1ğŸšï¸",
                'lanceros': "ğŸ”± LANCERO:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ¤ğŸ”„",
                'arqueros': "ğŸ¹ ARQUERO:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ§¨+1",
                'c_ligera': "ğŸ´ C. LIGERA:Â·Â·Â·Â·Â·â¬†ï¸:2+1âœ”ï¸Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–",
                'c_pesada': "ğŸ›¡ï¸ C. PESADA:Â·Â·Â·Â·Â·â¬†ï¸:2+1LÂ·Â·Â·Â·Â·â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸ¤",
                'elefante': "ğŸ˜ ELEFANTE:Â·Â·Â·Â·Â·â¬†ï¸:â•Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ”’+ğŸ§¨ğŸ§¨oğŸ‰",
                'dragon': "ğŸ‰ DRAGÃ“N:Â·Â·Â·Â·Â·â¬†ï¸:â•âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°Â·Â·Â·Â·Â·âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ",
                'trabuquete': "â˜„ï¸ TRABUQUETE:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–ğŸŒŠ",
                'escorpion': "ğŸ¦‚ ESCORPIÃ“N:Â·Â·Â·Â·Â·â¬†ï¸:1â•ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨",
                'fortaleza': "ğŸ° FORTALEZA:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸŒŠÂ·Â·Â·Â·Â·â¬†ï¸:â›”",
                'montana': "ğŸ”ï¸ MONTAÃ‘A:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸš©Â·Â·Â·Â·Â·â¬†ï¸:â›”"
            },
            'en': {
                'rey': "ğŸ‘‘ KING:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠâš ï¸",
                'chusma': "ğŸšï¸ RABBLE:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:+1ğŸšï¸",
                'lanceros': "ğŸ”± LANCER:Â·Â·Â·Â·Â·â¬†ï¸:1â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ¤ğŸ”„",
                'arqueros': "ğŸ¹ ARCHER:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ§¨+1",
                'c_ligera': "ğŸ´ LT. CAVALRY:Â·Â·Â·Â·Â·â¬†ï¸:2+1âœ”ï¸Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–",
                'c_pesada': "ğŸ›¡ï¸ HVY. CAVALRY:Â·Â·Â·Â·Â·â¬†ï¸:2+1LÂ·Â·Â·Â·Â·â›”:ğŸ§¨ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸ¤",
                'elefante': "ğŸ˜ ELEPHANT:Â·Â·Â·Â·Â·â¬†ï¸:â•Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°ğŸ”ï¸ğŸŒŠÂ·Â·Â·Â·Â·âš¡:ğŸ”’+ğŸ§¨ğŸ§¨oğŸ‰",
                'dragon': "ğŸ‰ DRAGON:Â·Â·Â·Â·Â·â¬†ï¸:â•âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸª–ğŸ°Â·Â·Â·Â·Â·âš¡:ğŸ˜ğŸ‘»ğŸ”ï¸ğŸŒŠ",
                'trabuquete': "â˜„ï¸ TREBUCHET:Â·Â·Â·Â·Â·â¬†ï¸:1âœ–ï¸ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:â•Â·Â·Â·Â·Â·â›”:ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸª–ğŸŒŠ",
                'escorpion': "ğŸ¦‚ SCORPION:Â·Â·Â·Â·Â·â¬†ï¸:1â•ğŸ”²Â·Â·Â·Â·Â·ğŸ¯:âœ–ï¸Â·Â·Â·Â·Â·â›”:ğŸ¤ğŸ°ğŸ”ï¸Â·Â·Â·Â·Â·âš¡:ğŸ‘»ğŸŒŠğŸ§¨ğŸ¡ğŸ§¨",
                'fortaleza': "ğŸ° FORTRESS:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸŒŠÂ·Â·Â·Â·Â·â¬†ï¸:â›”.",
                'montana': "ğŸ”ï¸ MOUNTAIN:Â·Â·Â·Â·Â·ğŸ—ï¸:ğŸš©Â·Â·Â·Â·Â·â¬†ï¸:â›”"
            }
        };

        // --- FUNCIONES DE HOVER ACTUALIZADAS ---

        function handleUnitHover(type, army, r, c) {
            if (draggingMeta) return;

            // 1. Timer de Texto (1 segundo)
            if (hoverTimer) clearTimeout(hoverTimer);
            hoverTimer = setTimeout(() => {
                if (!draggingMeta) {
                    const bar = document.getElementById('status-bar');
                    // Detectar idioma
                    const lang = currentLang || 'es';
                    const dict = UNIT_INFO[lang] || UNIT_INFO['es'];
                    const info = dict[type] || type.toUpperCase();

                    bar.innerText = `â„¹ï¸ ${info}`;
                    bar.style.color = '#3498db'; // Azul informativo
                    bar.classList.remove('status-critical');
                }
            }, 1000);

            // 2. Timer de Tablero (3 segundos) - NUEVO
            // Solo si la pieza es del turno actual o es setup (para no dar pistas del enemigo)
            const isMyPiece = (gameState.includes('deploy') || army === turnColor);

            if (boardHelpTimer) clearTimeout(boardHelpTimer);

            if (isMyPiece) {
                boardHelpTimer = setTimeout(() => {
                    if (!draggingMeta) {
                        activateBoardHelp(r, c, type, army);
                    }
                }, 3000);
            }
        }

        function handleUnitLeave() {
            // Limpiamos ambos timers y los efectos visuales
            if (hoverTimer) clearTimeout(hoverTimer);
            if (boardHelpTimer) clearTimeout(boardHelpTimer);

            clearGhosts(); // Borra las luces verdes/rojas del tablero

            if (!draggingMeta) {
                updateStatusBar(); // Restaura el texto original
            }
        }

        // --- LÃ“GICA DE AYUDA VISUAL (3 SEGUNDOS) CON CONTADOR ---
        function activateBoardHelp(originR, originC, type, army) {
            if (draggingMeta) return;

            // 1. Contador de movimientos vÃ¡lidos encontrados
            let validMovesCount = 0;

            // Recorremos las 100 casillas
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    if (r === originR && c === originC) continue;

                    // Filtros de validez geomÃ©trica y obstaculos fÃ­sicos
                    if (isValidMove(type, originR, originC, r, c)) {

                        const target = logicBoard[r][c];
                        const isMountain = target && target.type === 'montana';
                        const isFortress = target && target.type === 'fortaleza';
                        // Lanceros pueden hacer relevo, el resto no puede comerse aliados
                        const isAlly = target && target.army === army && type !== 'lanceros';
                        // Agua bloquea salvo voladores/anfibios
                        const isWater = terrain[r][c] === 'water' && type !== 'trabuquete' && type !== 'escorpion' && type !== 'dragon';

                        if (isMountain || isFortress || isAlly || isWater) {
                            continue;
                        }

                        // ValidaciÃ³n de seguridad (Jaque)
                        let isSafe = true;
                        if (gameState === 'playing') {
                            try {
                                isSafe = isSimulatedMoveSafe(type, originR, originC, r, c, army);
                            } catch (e) { console.warn(e); }
                        }

                        // Pintar y CONTAR
                        const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                        if (tile) {
                            if (isSafe) {
                                tile.classList.add('ghost-valid'); // Verde
                                validMovesCount++; // <--- SUMAMOS MOVIMIENTO VÃLIDO
                            } else {
                                tile.classList.add('ghost-invalid'); // Rojo (Suicidio)
                                // No sumamos al contador porque no es un movimiento legal
                            }
                        }
                    }
                }
            }

            // 2. Feedback al usuario segÃºn el resultado
            if (validMovesCount === 0) {
                // Mensaje de error/aviso si estÃ¡ totalmente bloqueada
                showNotification(`ğŸš« ${type.toUpperCase()}: SIN MOVIMIENTOS POSIBLES (BLOQUEADA)`, true);
            } else {
                // Mensaje informativo estÃ¡ndar con el nÃºmero de opciones
                showNotification(`ğŸ’¡ Visualizando ${validMovesCount} movimientos posibles...`);
            }
        }


        // Estado del juego: 'init', 'deploy-p1', 'deploy-p2', 'playing'
        let gameState = 'init';
        let p1Color = null;
        let p2Color = null;
        let p1Territory = null; // 'north' (filas 0-4) o 'south' (filas 5-9)
        let turnColor = null; // 'rojo' o 'negro'


        // --- 0. INTERFAZ DE AYUDA ---
        let currentLang = 'es';

        function toggleRules() {
            const modal = document.getElementById("rulesModal");
            modal.style.display = (modal.style.display === "block") ? "none" : "block";
        }

        function toggleLanguage() {
            const es = document.getElementById('rules-es');
            const en = document.getElementById('rules-en');
            const btn = document.getElementById('langToggleBtn');
            const title = document.getElementById('rules-title'); // <--- NUEVO

            if (currentLang === 'es') {
                // Cambiar a INGLÃ‰S
                es.style.display = 'none';
                en.style.display = 'block';
                btn.innerText = 'Leer en EspaÃ±ol';
                title.innerText = 'ğŸ“œ COTADREZ RULES'; // <--- CAMBIO DE TÃTULO
                currentLang = 'en';
            } else {
                // Cambiar a ESPAÃ‘OL
                es.style.display = 'block';
                en.style.display = 'none';
                btn.innerText = 'Read in English';
                title.innerText = 'ğŸ“œ REGLAMENTO';     // <--- CAMBIO DE TÃTULO
                currentLang = 'es';
            }
        }

        // Cerrar al hacer clic fuera del modal
        window.onclick = function (event) {
            const modal = document.getElementById("rulesModal");
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }

        // --- 2. INICIALIZACIÃ“N ---
        function init() {
            console.log("Inicializando sistema...");

            // 1. Llenar las reservas con las cantidades iniciales
            for (const [type, data] of Object.entries(CONFIG.pieces)) {
                reserves.rojo[type] = data.qty;
                reserves.negro[type] = data.qty;
            }

            // 2. Inicializar grÃ¡ficos
            initWater();
            renderBoard();
            updateInventories();
            updateDungeons();
            document.getElementById('status-bar').innerText = getStatusText();
        }
        function initWater() {
            const waterCoords = [[3, 1], [1, 3]]; // b4, d2
            waterCoords.forEach(([r, c]) => {
                terrain[r][c] = 'water'; terrain[r][9 - c] = 'water';
                terrain[9 - r][c] = 'water'; terrain[9 - r][9 - c] = 'water';
            });
        }

        // --- 3. RENDERIZADO BÃSICO ---

        function renderBoard() {
            const b = document.getElementById('board');
            b.innerHTML = '';

            // --- COLOR DEL BORDE SEGÃšN TURNO ---
            let borderColor = '#34495e'; // Color neutro por defecto (Azul grisÃ¡ceo oscuro)

            // Definimos el color oscuro manual para que destaque sobre el neutro
            const darkBorder = '#111111'; // <--- CORRECCIÃ“N: Gris casi negro

            if (gameState === 'deploy-p1') {
                borderColor = (p1Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'deploy-p2') {
                borderColor = (p2Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            // AÃ‘ADIMOS: ConfirmaciÃ³n, SelecciÃ³n de Prisionero y Bonus de Chusma
            else if (gameState === 'playing' ||
                gameState === 'siege-resolution' ||
                gameState === 'siege-confirmation' ||
                gameState === 'siege-prisoner-select' ||
                gameState === 'playing-chusma-bonus') {

                borderColor = (turnColor === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            b.style.borderColor = borderColor;
            // ------------------------------------------

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    // --- NUEVO: PINTAR RASTRO DE DISPARO (Diferenciando Origen/Destino) ---
                    const shot = shotHighlights.find(h => h.r === r && h.c === c);
                    if (shot) {
                        if (shot.type === 'source') tile.classList.add('shot-source'); // Dorado
                        else tile.classList.add('shot-highlight'); // Oscuro
                    }

                    tile.ondragover = (e) => handleDragOver(e, r, c);
                    tile.ondrop = (e) => handleDrop(e, r, c);

                    if (terrain[r][c] === 'water') {
                        tile.classList.add('water');
                    }

                    // Pintar pieza
                    const piece = logicBoard[r][c];
                    let isVisible = true;

                    // Niebla de Guerra
                    if (piece && gameState === 'deploy-p2' && piece.army === p1Color) {
                        isVisible = false;
                    }

                    if (piece && isVisible) {
                        const img = document.createElement('img');
                        img.src = getImgUrl(piece.army, piece.type);
                        img.className = 'piece';

                        // --- NUEVO: Eventos de Hover ---
                        img.onmouseenter = () => handleUnitHover(piece.type, piece.army, r, c);
                        img.onmouseleave = () => handleUnitLeave();


                        // --- LÃ“GICA DE PARPADEO DE FORTALEZA ---
                        if (piece.type === 'fortaleza') {
                            // 1. Fase de ConfirmaciÃ³n (Turno Atacante): La fortaleza enemiga es clickable
                            if (gameState === 'siege-confirmation' && piece.army !== turnColor) {
                                img.classList.add('siege-pulse');
                                img.onclick = () => executeConfirmedSiege(turnColor, piece.army);
                                img.title = "CLICK PARA EJECUTAR EL ASEDIO";
                            }
                            // 2. Fase Normal (Turno Defensor): Si MI fortaleza estÃ¡ asediada, parpadea
                            // Usamos siegeStatus[piece.army] para saber si ESTA fortaleza concreta sufre asedio
                            else if (siegeStatus[piece.army] === true) {
                                img.classList.add('siege-pulse');
                            }
                        }

                        // --- GESTIÃ“N DE ARRASTRE Y CLICKS ---
                        let canDrag = true;

                        // Bloqueos estÃ¡ndar
                        if (piece.type === 'fortaleza') canDrag = false;
                        if (gameState.startsWith('playing') && piece.type === 'montana') canDrag = false; // startWith para pillar ambos estados
                        if (gameState.includes('deploy')) {
                            const myColor = (gameState === 'deploy-p1') ? p1Color : p2Color;
                            if (piece.army !== myColor) canDrag = false;
                        }

                        // LÃ“GICA ESPECIAL: MEDIO TURNO DE CHUSMA
                        if (gameState === 'playing-chusma-bonus') {
                            // Si es la chusma que acabamos de mover -> NO DRAG, SÃ CLICK
                            if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                                canDrag = false;
                                img.style.cursor = "pointer"; // Dedo para hacer click
                                img.title = "Click para CEDER EL TURNO";
                                img.onclick = () => finishChusmaBonusTurn();
                                // Efecto visual para destacar que estÃ¡ esperando
                                img.style.filter = "drop-shadow(0 0 5px var(--c-gold)) brightness(1.2)";
                            }
                            // El resto de piezas no-chusma se bloquean en handleDragStart, 
                            // pero visualmente podemos quitarles el drag aquÃ­ si quieres pulirlo mÃ¡s.
                        }

                        // Asignar draggable
                        img.draggable = canDrag;
                        if (canDrag) {
                            img.ondragstart = (e) => handleDragStart(e, 'board', piece.army, piece.type, r, c);

                            img.ondragend = () => {
                                clearRingHighlights();
                                clearGhosts();
                                lastHoveredTile = null;
                                updateStatusBar(); // Restaurar texto original
                            };

                            img.style.cursor = "grab";
                        } else if (!img.onclick) {
                            // Si no es arrastrable ni tiene onclick especial (como la chusma o fortaleza)
                            img.style.cursor = "default";
                        }

                        // --- GESTIÃ“N DE CLICS DE FORTALEZAS (Mantenemos tu cÃ³digo anterior aquÃ­) ---
                        if (piece.type === 'fortaleza') {
                            // ... (Tu cÃ³digo de finishTurnP1 / P2 / Asedio sigue igual) ...
                            if (gameState === 'deploy-p1' && piece.army === p1Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP1();
                            } else if (gameState === 'deploy-p2' && piece.army === p2Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP2();
                            } else if (gameState.startsWith('playing') && piece.army !== turnColor) {
                                // ... (LÃ³gica de asedio si la tienes implementada) ...
                            }
                        }

                        tile.appendChild(img);
                    }

                    b.appendChild(tile);
                }
            }

            // --- EASTER EGG: BotÃ³n Invisible de Debug ---
            const egg = document.createElement('div');
            egg.className = 'debug-egg';
            egg.title = "v5.2"; // Pista sutil si dejas el ratÃ³n quieto

            // Usamos DOBLE CLICK para evitar accidentes durante la partida
            egg.ondblclick = () => activateDebugMode();

            b.appendChild(egg);

        }

        // Devuelve 'north' (filas 0-4) o 'south' (filas 5-9)
        function getTerritory(r) {
            return r < 5 ? 'north' : 'south';
        }



        // Verifica si una casilla estÃ¡ en el "Anillo de Salida" (perÃ­metro adyacente)

        function isInExitZone(r, c, fOrigin) {
            if (!fOrigin) return false;

            // La fortaleza ocupa (fr, fc) hasta (fr+1, fc+1)
            // El anillo va desde (fr-1, fc-1) hasta (fr+2, fc+2)
            const minR = fOrigin.r - 1;
            const maxR = fOrigin.r + 2;
            const minC = fOrigin.c - 1;
            const maxC = fOrigin.c + 2;

            // 1. Debe estar dentro del rectÃ¡ngulo exterior
            if (r >= minR && r <= maxR && c >= minC && c <= maxC) {
                // 2. Pero NO debe ser la propia fortaleza (el hueco central)
                if (r >= fOrigin.r && r <= fOrigin.r + 1 && c >= fOrigin.c && c <= fOrigin.c + 1) {
                    return false; // Es la propia estructura
                }
                return true; // Es el anillo
            }
            return false;
        }

        // Arrancar
        init();

        // Construye la URL de la imagen segÃºn el bando y el tipo
        function getImgUrl(army, type) {
            const folder = army === 'rojo' ? 'Rojo' : 'Negro';
            const filename = CONFIG.pieces[type].file;
            return `${CONFIG.repo}/${folder}/${filename}`;
        }

        // Dibuja las piezas en los paneles laterales (Con efecto de desactivado)
        function updateInventories() {
            ['rojo', 'negro'].forEach(army => {
                const list = document.getElementById(`inv-${army}`);
                list.innerHTML = '';

                // --- 1. Determinar si este ejÃ©rcito estÃ¡ ACTIVO ---
                let isActive = true; // En 'init' ambos estÃ¡n activos

                if (gameState === 'deploy-p1') {
                    isActive = (army === p1Color);
                } else if (gameState === 'deploy-p2') {
                    isActive = (army === p2Color);
                } else if (gameState === 'game-over') {
                    isActive = false; // Nadie mueve al final
                } else if (gameState !== 'init') {
                    // Para cualquier fase de juego (playing, siege, etc.)
                    isActive = (army === turnColor);
                }
                // --------------------------------------------------

                for (const [type, data] of Object.entries(CONFIG.pieces)) {
                    const count = reserves[army][type];

                    if (count > 0) {
                        const item = document.createElement('div');
                        item.className = 'inv-item';

                        const img = document.createElement('img');
                        img.src = getImgUrl(army, type);

                        // --- NUEVO: Eventos de Hover en Reserva ---
                        img.onmouseenter = () => handleUnitHover(type);
                        img.onmouseleave = () => handleUnitLeave();

                        // --- 2. Aplicar propiedades segÃºn estado ---
                        if (isActive) {
                            img.draggable = true;
                            img.style.cursor = "grab";
                            img.style.filter = "none"; // Normal
                            img.style.opacity = "1";

                            img.ondragstart = (e) => handleDragStart(e, 'reserve', army, type);
                            img.ondragend = () => {
                                clearRingHighlights();
                                lastHoveredTile = null;
                                updateStatusBar(); // Restaurar texto original
                            };
                        } else {
                            img.draggable = false;
                            img.style.cursor = "not-allowed"; // Icono de prohibido
                            // Efecto visual: Escala de grises y semitransparente
                            img.style.filter = "grayscale(100%)";
                            img.style.opacity = "0.3";
                        }
                        // -------------------------------------------

                        item.appendChild(img);

                        if (count > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'inv-badge';
                            badge.innerText = count;

                            // TambiÃ©n apagamos el badge visualmente si estÃ¡ inactivo
                            if (!isActive) badge.style.filter = "grayscale(100%)";

                            item.appendChild(badge);
                        }
                        list.appendChild(item);
                    }
                }
            });
        }

        // --- 4. LÃ“GICA DE ARRASTRAR Y SOLTAR ---

        function handleDragStart(e, source, army, type, r = null, c = null) {

            if (hoverTimer) clearTimeout(hoverTimer);
            if (boardHelpTimer) clearTimeout(boardHelpTimer);
            clearGhosts();

            // --- LÃ“GICA DE JUEGO Y MEDIO TURNO ---
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus') {

                if (gameState === 'game-over') { e.preventDefault(); return; }

                if (gameState === 'siege-confirmation') {
                    if (army !== turnColor) { e.preventDefault(); return; }
                    // Solo permitimos mover si la pieza es parte del asedio (estÃ¡ en el anillo enemigo)
                    const enemyFort = fortressPos[(army === 'rojo') ? 'negro' : 'rojo'];
                    if (!isInExitZone(r, c, enemyFort)) {
                        showNotification("ğŸ”’ Solo puedes mover las unidades que asedian la fortaleza.");
                        e.preventDefault();
                        return;
                    }
                }

                if (army !== turnColor) { e.preventDefault(); return; }

                // RESTRICCIONES DEL MEDIO TURNO (BONUS CHUSMA)
                if (gameState === 'playing-chusma-bonus') {
                    // 1. Solo se puede mover otra CHUSMA
                    if (type !== 'chusma') {
                        e.preventDefault(); return;
                    }
                    // 2. Solo piezas del TABLERO (Reserva bloqueada)
                    if (source !== 'board') {
                        e.preventDefault(); return;
                    }
                    // 3. NO se puede mover la misma unidad dos veces
                    if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                        e.preventDefault(); return;
                    }
                }
            }

            // CALCULAR MAPAS DE INFLUENCIA (Solo si no estamos en fase 'init')
            if (gameState !== 'init') {
                const enemy = (army === 'rojo') ? 'negro' : 'rojo';
                currentThreatMap = getThreatMap(enemy); // Para que mi Rey no se suicide
                currentAttackMap = getThreatMap(army);  // Para coordinar ataques (Elefante)
            } else {
                currentThreatMap = null;
                currentAttackMap = null;
            }
            // 1. Guardamos metadatos (AÃ‘ADIDO: coordenadas de origen)
            draggingMeta = {
                type: type,
                army: army,
                source: source,
                originR: r, // <--- NUEVO
                originC: c  // <--- NUEVO
            };

            // 2. Datos estÃ¡ndar para el Drop
            const data = { source, army, type, originR: r, originC: c };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';

            // --- NUEVO: RESALTAR ANILLO SI VIENE DE RESERVA ---
            // (La lÃ³gica estÃ¡ DENTRO de la funciÃ³n, antes de la llave de cierre)
            if (source === 'reserve' && type !== 'montana') {
                highlightFortressRing(army);
            }
        }

        // 2. Permitir soltar (El navegador bloquea por defecto, hay que prevenirlo)
        // FunciÃ³n auxiliar para limpiar fantasmas previos
        function clearGhosts() {
            document.querySelectorAll('.ghost-valid, .ghost-invalid').forEach(el => {
                el.classList.remove('ghost-valid', 'ghost-invalid');
            });
        }

        // Nueva funciÃ³n DragOver con lÃ³gica de visualizaciÃ³n

        function handleDragOver(e, r, c) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!draggingMeta) return;

            // 1. VARIABLES GLOBALES
            let isValid = true;
            let specialMessage = "";
            let cells = [];

            clearGhosts();

            // =========================================================
            // A. FASE DE JUEGO (Playing, ConfirmaciÃ³n, Bonus)
            // =========================================================
            if (gameState === 'playing' || gameState === 'siege-confirmation' || gameState === 'playing-chusma-bonus') {
                const target = logicBoard[r][c];
                const type = draggingMeta.type;
                const army = draggingMeta.army;
                const source = draggingMeta.source;

                // Validaciones Generales
                if (terrain[r][c] === 'water') { isValid = false; specialMessage = " (AGUA ğŸŒŠ)"; }
                if (target && target.type === 'fortaleza') { isValid = false; specialMessage = " (FORTALEZA ğŸ°)"; }
                if (target && target.type === 'montana') { isValid = false; specialMessage = " (MONTAÃ‘A ğŸ”ï¸)"; }

                // LÃ³gica Refuerzo vs Movimiento
                if (source === 'reserve') {
                    const fOrigin = fortressPos[army];
                    if (!isInExitZone(r, c, fOrigin)) isValid = false;
                    if (target !== null) isValid = false;
                } else {
                    if (!isValidMove(type, draggingMeta.originR, draggingMeta.originC, r, c)) isValid = false;
                    if (isValid && target) {
                        if (target.army === army && type !== 'lanceros') isValid = false;
                    }
                }
                cells = [{ r: r, c: c }]; // 1 casilla
            }
            // =========================================================
            // B. FASE DE DESPLIEGUE (Init, Deploy-P1, Deploy-P2)
            // =========================================================
            else {
                const army = draggingMeta.army;
                const type = draggingMeta.type;
                const isFortress = (type === 'fortaleza');
                const fOrigin = fortressPos[army];
                const hasFortress = fOrigin !== null;
                const isMountain = (type === 'montana');

                // 1. DEFINIR CELDAS (Ghosting 2x2 para Fortaleza)
                cells = [];
                if (isFortress) {
                    if (r + 1 > 9 || c + 1 > 9) { // Se sale del mapa
                        isValid = false;
                        specialMessage = " (FUERA DE LÃMITES ğŸš«)";
                        cells = [{ r: r, c: c }];
                    } else {
                        // Ocupa 4 celdas
                        cells.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                    }
                } else {
                    cells.push({ r: r, c: c });
                }

                // 2. VALIDACIONES DE DESPLIEGUE
                // A. Fortaleza obligatoria primero
                if (!isFortress && !hasFortress) isValid = false;

                // B. Territorio correcto
                if (p1Territory) {
                    const rowTerritory = getTerritory(r);
                    const myZone = (army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                    if (rowTerritory !== myZone) isValid = false;
                }

                // C. Anillo de salida (si no es fortaleza/montaÃ±a)
                if (!isFortress && !isMountain && hasFortress) {
                    if (isValid && !isInExitZone(r, c, fOrigin)) isValid = false;
                }

                // D. Zona Prohibida Fortaleza (Bordes y centro)
                if (isFortress) {
                    const invalidRows = [0, 4, 5, 9];
                    const invalidCols = [0, 9];
                    if (invalidRows.includes(r) || invalidRows.includes(r + 1)) isValid = false;
                    if (invalidCols.includes(c) || invalidCols.includes(c + 1)) isValid = false;
                }

                // E. Agua y OcupaciÃ³n
                for (let cell of cells) {
                    if (terrain[cell.r][cell.c] === 'water' && !isFortress) {
                        isValid = false; specialMessage = " (AGUA ğŸŒŠ)";
                    }
                    if (logicBoard[cell.r][cell.c] !== null) {
                        isValid = false; specialMessage = " (OCUPADO â›”)";
                    }
                }
            }

            // --- NUEVO: VALIDACIÃ“N DE SEGURIDAD EN TIEMPO REAL (GHOSTING) ---
            // Si tÃ©cnicamente puedes moverte ahÃ­, comprobamos si es un suicidio.
            // FIX: Solo simulamos si NO venimos de la reserva y si es vÃ¡lido geomÃ©tricamente
            if (isValid && gameState.startsWith('playing') && draggingMeta.source === 'board') {
                try {
                    // BLINDAJE: Envolvemos esto en try-catch.
                    // Si el cÃ¡lculo de Jaque falla por cualquier bug interno, 
                    // capturamos el error para que NO congele la barra de estado ni el ghosting.
                    // Ante la duda (error), asumimos que es seguro (isValid sigue true) para dejar jugar.

                    if (!isSimulatedMoveSafe(type, draggingMeta.originR, draggingMeta.originC, r, c, army)) {
                        isValid = false;
                        specialMessage = " (JAQUE âš ï¸)";
                    }
                } catch (err) {
                    console.warn("âš ï¸ Salto de seguridad en DragOver:", err);
                    // No hacemos nada: isValid se mantiene true, asÃ­ que se verÃ¡ VERDE.
                }
            }

            // =========================================================
            // C. VISUALIZACIÃ“N FINAL (ComÃºn)
            // =========================================================
            const className = isValid ? 'ghost-valid' : 'ghost-invalid';
            cells.forEach(cell => {
                const tile = document.querySelector(`.tile[data-r="${cell.r}"][data-c="${cell.c}"]`);
                if (tile) tile.classList.add(className);
            });

            // VISUALIZACIÃ“N EN BARRA DE ESTADO (Coordenadas y Validez)
            // Esto sobrescribe cualquier mensaje de Jaque/Asedio MOMENTÃNEAMENTE mientras arrastras
            const currentTileId = `${r}-${c}`;

            // Quitamos la comprobaciÃ³n de lastHoveredTile estricta para forzar el repintado si cambia el estado
            lastHoveredTile = currentTileId;

            const coordName = getCoordinateName(r, c);
            const statusIcon = isValid ? "âœ…" : "â›”";
            // Si hay mensaje especial (ej: AGUA), lo usamos. Si no, genÃ©rico.
            const detailText = specialMessage ? specialMessage : (isValid ? "Movimiento VÃ¡lido" : "Movimiento InvÃ¡lido");

            const bar = document.getElementById('status-bar');
            bar.innerText = `${coordName} ${detailText} ${statusIcon}`;

            // Forzamos colores de "semÃ¡foro" para el drag
            bar.style.color = isValid ? '#2ecc71' : '#e74c3c'; // Verde o Rojo
            bar.classList.remove('status-critical'); // Quitamos parpadeo mientras arrastras para leer mejor
            bar.style.opacity = 1;
        }

        //             // 3. Al soltar en una casilla

        function handleDrop(e, r, c) {
            e.preventDefault();

            // --- CORRECCIÃ“N VISUAL: Limpieza TOTAL al soltar cualquier cosa ---
            lastHoveredTile = null;
            updateStatusBar();
            clearRingHighlights();
            clearGhosts();
            shotHighlights = []; // <--- ESTO ARREGLA EL RASTRO DEL TRABUQUETE PEGADO

            // Forzamos repintado para borrar rastros antiguos inmediatamente
            renderBoard();
            // ------------------------------------------------------------------

            const rawData = e.dataTransfer.getData('text/plain');
            if (!rawData) return;
            const data = JSON.parse(rawData);

            draggingMeta = null;

            // ============================================================
            //  FASE ESPECIAL: RESOLUCIÃ“N DE ASEDIO
            // ============================================================
            if (gameState === 'siege-resolution') {
                // ... (MANTÃ‰N TU CÃ“DIGO DE ASEDIO EXACTAMENTE IGUAL QUE ANTES AQUÃ) ...
                // Para ahorrar espacio, asumo que dejas el bloque 'if (gameState === 'siege-resolution')'
                // tal cual lo tenÃ­as en la versiÃ³n 4.6, ya que eso funcionaba bien.
                if (data.army !== besiegedArmy) return;
                // ... copia tu lÃ³gica de asedio aquÃ­ ...
                // (Si necesitas que te la pegue entera dÃ­melo, pero es la misma de antes)
                // ... FIN BLOQUE ASEDIO ...

                // PEQUEÃ‘O RECORDATORIO: Si copias el bloque, asegÃºrate de que al final del bloque
                // de asedio hagas return;

                // --- INICIO RESUMEN BLOQUE ASEDIO (CÃ³pialo de tu v4.6) ---
                if (data.source !== 'reserve') { showNotification("âš ï¸ Debes sacar una pieza de la RESERVA.", true); return; }
                const fOrigin = fortressPos[data.army];
                if (!isInExitZone(r, c, fOrigin)) { showNotification("ğŸš« Solo despliegue en Fortaleza.", true); return; }
                if (logicBoard[r][c] !== null || terrain[r][c] === 'water') { showNotification("ğŸš« Casilla invÃ¡lida.", true); return; }

                const myReserve = reserves[data.army];
                if (myReserve['rey'] > 0 && data.type !== 'rey') { showNotification("ğŸ‘‘ Â¡Salva al REY!", true); return; }
                if (data.type === 'rey' && currentThreatMap && currentThreatMap[r][c] > 0) { showNotification("â›” Â¡Zona mortal!", true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    logicBoard[r][c] = { army: data.army, type: data.type };
                }
                const attackerArmy = (besiegedArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;
                for (const [t, count] of Object.entries(reserves[data.army])) {
                    if (t === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) { dungeons[attackerArmy].push({ type: t, army: besiegedArmy }); capturedCount++; }
                        reserves[data.army][t] = 0;
                    }
                }
                showNotification(`ğŸ”¥ Asedio roto. ${capturedCount} capturados.`);
                gameState = 'playing'; besiegedArmy = null; turnColor = attackerArmy;
                renderBoard(); updateInventories(); updateDungeons(); checkTurnStatus();
                return;
                // --- FIN RESUMEN BLOQUE ASEDIO ---
            }

            // ============================================================
            //  FASE 1: MODO JUEGO (NORMAL Y BONUS)
            // ============================================================
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus' || gameState === 'siege-confirmation') {

                // --- A. REFUERZOS (DESDE RESERVA) ---
                if (data.source === 'reserve') {
                    const fOrigin = fortressPos[data.army];
                    if (!isInExitZone(r, c, fOrigin)) { showNotification("â›” Solo junto a tu Fortaleza."); return; }
                    if (terrain[r][c] === 'water') { showNotification("â›” No en el agua."); return; }
                    if (logicBoard[r][c] !== null) { showNotification("â›” Zona ocupada."); return; }

                    if (reserves[data.army][data.type] > 0) {
                        reserves[data.army][data.type]--;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        showNotification(`ğŸ†• Refuerzos: ${data.type.toUpperCase()}`);
                    } else { return; }
                }

                // --- B. MOVIMIENTO (TABLERO A TABLERO) ---
                else if (data.source === 'board') {
                    shotHighlights = []; // Aseguramos limpieza al iniciar movimiento

                    const target = logicBoard[r][c];

                    // Validaciones bÃ¡sicas
                    if (terrain[r][c] === 'water' && data.type !== 'trabuquete' && data.type !== 'escorpion') { showNotification("â›” Agua."); return; }
                    if (target === null && terrain[r][c] === 'water') { showNotification("â›” Agua."); return; }
                    if (target && target.type === 'montana') { showNotification("â›” MontaÃ±a."); return; }
                    if (target && target.type === 'fortaleza') { showNotification("â›” Fortaleza."); return; }

                    // --- CORRECCIÃ“N ELEFANTE: LÃ“GICA ROBUSTA ---
                    if (target && target.type === 'elefante' && target.army !== data.army && data.type !== 'dragon') {
                        // CÃLCULO: Total amenazas (Yo + Aliados)
                        const totalThreats = countTotalThreats(r, c, data.army);

                        if (totalThreats < 2) {
                            showNotification("ğŸ˜ Â¡IMPOSIBLE! El ataque no es suficiente. Necesitas al menos 2 unidades amenazando al Elefante.", true);
                            return;
                        }
                    }
                    // -------------------------------------------

                    // ValidaciÃ³n GeomÃ©trica
                    if (!isValidMove(data.type, data.originR, data.originC, r, c)) {
                        showNotification("â›” Movimiento ilegal"); return;
                    }

                    // --- NUEVO: VALIDACIÃ“N DE SEGURIDAD (ANTI-SUICIDIO / OBLIGACIÃ“N DE SALVAR REY) ---
                    // Antes de mover, simulamos si esto nos deja en Jaque.
                    if (!isSimulatedMoveSafe(data.type, data.originR, data.originC, r, c, data.army)) {
                        const msg = isCheck ? "âš ï¸ Â¡ESTÃS EN JAQUE! Debes salvar al Rey." : "â›” Movimiento invÃ¡lido: DejarÃ­a al Rey expuesto.";
                        showNotification(msg, true);
                        return; // Cancelamos el movimiento
                    }

                    let wasCapture = false;

                    if (target) {
                        if (target.army === data.army) {
                            // Aliado (Solo Lanceros)
                            if (data.type === 'lanceros') {
                                logicBoard[data.originR][data.originC] = target;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("ğŸ”„ Relevo de Lancero");
                            } else { showNotification("â›” Casilla aliada."); return; }
                        } else {
                            // Enemigo (Captura/Disparo)
                            wasCapture = true;

                            // DISPARO (Trabuquete/EscorpiÃ³n) - NO SE MUEVEN
                            if (data.type === 'trabuquete' || data.type === 'escorpion') {
                                shotHighlights.push({ r: data.originR, c: data.originC, type: 'source' });
                                shotHighlights.push({ r: r, c: c, type: 'target' });

                                if (data.type === 'escorpion') {
                                    // LÃ³gica perforaciÃ³n EscorpiÃ³n
                                    const sR = Math.sign(r - data.originR);
                                    const sC = Math.sign(c - data.originC);
                                    let cR = data.originR + sR, cC = data.originC + sC;
                                    while (cR !== r || cC !== c) {
                                        const obs = logicBoard[cR][cC];
                                        if (obs && obs.army !== data.army) {
                                            dungeons[data.army].push({ type: obs.type, army: obs.army });
                                            logicBoard[cR][cC] = null;
                                            shotHighlights.push({ r: cR, c: cC, type: 'target' });
                                        }
                                        cR += sR; cC += sC;
                                    }
                                }

                                // Captura Objetivo
                                if (target.type === 'rey') {
                                    gameState = 'game-over'; logicBoard[r][c] = null; renderBoard();
                                    document.getElementById('status-bar').innerText = `ğŸ‘‘ VICTORIA ${data.army.toUpperCase()}`;
                                    return;
                                }
                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[r][c] = null;
                                showNotification("ğŸ”¥ Â¡DISPARO!");
                            } else {
                                // CAPTURA CUERPO A CUERPO (Se mueven)
                                if (target.type === 'rey') {
                                    gameState = 'game-over'; logicBoard[data.originR][data.originC] = null;
                                    logicBoard[r][c] = { army: data.army, type: data.type }; renderBoard();
                                    document.getElementById('status-bar').innerText = `ğŸ‘‘ VICTORIA ${data.army.toUpperCase()}`;
                                    return;
                                }
                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[data.originR][data.originC] = null;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("âš”ï¸ Â¡CAPTURA!");
                            }
                        }
                    } else {
                        // Movimiento a vacÃ­o
                        logicBoard[data.originR][data.originC] = null;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        wasCapture = false;
                    }

                    // --- Asedio creado? ---
                    let siegeCreated = false;
                    const enemyFortCheck = fortressPos[(data.army === 'rojo') ? 'negro' : 'rojo'];
                    if (enemyFortCheck) {
                        let count = 0;
                        for (let rx = 0; rx < 10; rx++) {
                            for (let cx = 0; cx < 10; cx++) {
                                if (isInExitZone(rx, cx, enemyFortCheck)) {
                                    const u = logicBoard[rx][cx];
                                    if (u && u.army === data.army) count++;
                                }
                            }
                        }
                        if (count >= 2) siegeCreated = true;
                    }

                    // --- Bonus Chusma ---
                    if (gameState === 'playing' && data.type === 'chusma' && !wasCapture && gameState !== 'siege-confirmation' && !siegeCreated) {

                        // NUEVO: Verificamos si realmente hay OTRA chusma para mover
                        let totalChusmas = 0;
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                const p = logicBoard[tr][tc];
                                if (p && p.army === data.army && p.type === 'chusma') {
                                    totalChusmas++;
                                }
                            }
                        }

                        // Solo activamos el Bonus si tienes mÃ¡s de 1 chusma (la que moviste + otra)
                        if (totalChusmas > 1) {
                            gameState = 'playing-chusma-bonus';
                            chusmaMovedCoords = { r: r, c: c };
                            renderBoard(); updateInventories(); updateDungeons(); checkTurnStatus();
                            return;
                        }
                        // Si solo tienes 1, ignoramos el bonus y dejamos que el cÃ³digo siga hacia abajo (cambio de turno)
                    }
                }

                // --- FINAL DE TURNO / GESTIÃ“N ASEDIO (IGUAL QUE ANTES) ---
                if (gameState === 'siege-confirmation') {
                    const defender = (data.army === 'rojo') ? 'negro' : 'rojo';
                    turnColor = defender; gameState = 'playing';
                    checkTurnStatus(); renderBoard(); updateInventories(); updateDungeons();
                    if (!siegeStatus[defender]) showNotification("ğŸ³ï¸ Asedio cancelado.");
                    return;
                }

                const defenderArmy = data.army;
                const attackerArmy = (defenderArmy === 'rojo') ? 'negro' : 'rojo';
                const myFort = fortressPos[defenderArmy];
                if (myFort) {
                    let enemiesAtGate = 0;
                    for (let rx = 0; rx < 10; rx++) {
                        for (let cx = 0; cx < 10; cx++) {
                            if (isInExitZone(rx, cx, myFort)) {
                                const u = logicBoard[rx][cx];
                                if (u && u.army === attackerArmy) enemiesAtGate++;
                            }
                        }
                    }
                    // SI LA DEFENSA FALLA (Sigue habiendo 2+ enemigos)
                    // Esto comprueba correctamente si quedan 2, 3 o 100 enemigos.
                    // Si eliminaste uno pero quedan 2, entrarÃ¡ aquÃ­ correctamente.
                    if (enemiesAtGate >= 2) {
                        gameState = 'siege-confirmation';
                        turnColor = attackerArmy; // El turno vuelve al atacante

                        // --- CORRECCIÃ“N QUIRÃšRGICA: PRIORIDAD DE ALERTA ---
                        // Si venimos de una captura, hay una notificaciÃ³n bloqueando la barra.
                        // La desactivamos a la fuerza para que el aviso de ASEDIO se vea SÃ o SÃ.
                        isNotificationActive = false;
                        if (notificationTimer) clearTimeout(notificationTimer);
                        // --------------------------------------------------

                        renderBoard(); updateInventories(); updateDungeons();
                        updateStatusBar(); // Ahora sÃ­ mostrarÃ¡ "ASEDIO LISTO" en rojo
                        return;
                    }
                }

                turnColor = attackerArmy; gameState = 'playing'; chusmaMovedCoords = null;
                checkTurnStatus(); renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // ============================================================
            //  FASE 2: MODO DESPLIEGUE (SETUP) - (MANTENER TU CÃ“DIGO ACTUAL)
            // ============================================================
            // Copia aquÃ­ el bloque "const isFortress = ..." y todo el despliegue
            // que ya tenÃ­as funcionando en 4.6. No hay cambios ahÃ­.
            // ... (Pega tu cÃ³digo de despliegue aquÃ­) ...
            const isFortress = (data.type === 'fortaleza');
            const isMountain = (data.type === 'montana');
            const fOrigin = fortressPos[data.army];
            const hasFortress = fOrigin !== null;

            // Validaciones
            if (!isFortress && !hasFortress) { showNotification("ğŸš« Primero debes construir la FORTALEZA", true); return; }

            if (p1Territory) {
                const currentZone = getTerritory(r);
                const myZone = (data.army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                if (currentZone !== myZone) { showNotification("ğŸš« Zona Prohibida.", true); return; }
            }

            // BLOQUE MODIFICADO: Retorno a reserva si sale del anillo
            if (!isFortress && !isMountain && hasFortress) {
                if (!isInExitZone(r, c, fOrigin)) {

                    // --- NUEVO: SI VIENE DEL TABLERO, LA DEVOLVEMOS A LA RESERVA ---
                    if (data.source === 'board') {
                        logicBoard[data.originR][data.originC] = null;
                        reserves[data.army][data.type]++;

                        showNotification(`â†©ï¸ ${data.type.toUpperCase()} devuelta a la reserva.`);
                        renderBoard();
                        updateInventories();
                        return;
                    }
                    // ---------------------------------------------------------------

                    showNotification("ğŸ›¡ï¸ Despliega junto a la Fortaleza", true); return;
                }
            }

            let cellsToCheck = [];
            if (isFortress) {
                if (r + 1 > 9 || c + 1 > 9) { showNotification("Â¡No cabe aquÃ­!", true); return; }
                cellsToCheck.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                const invalidRows = [0, 4, 5, 9]; const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1) || invalidCols.includes(c) || invalidCols.includes(c + 1)) {
                    showNotification("ğŸ° PosiciÃ³n invÃ¡lida", true); return;
                }
            } else {
                cellsToCheck.push({ r: r, c: c });
            }

            for (let cell of cellsToCheck) {
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) { showNotification("ğŸŒŠ Â¡Al agua no!", true); return; }
                if (logicBoard[cell.r][cell.c] !== null) { showNotification("â›” Casilla ocupada", true); return; }
            }

            if (data.source === 'reserve') {
                if (gameState === 'init') {
                    if (!isFortress) { showNotification("âš ï¸ Primero la FORTALEZA.", true); return; }
                    p1Color = data.army;
                    p2Color = (p1Color === 'rojo') ? 'negro' : 'rojo';
                    p1Territory = getTerritory(r);
                    gameState = 'deploy-p1';
                }
                if (gameState === 'deploy-p1' && data.army !== p1Color) { showNotification("âš ï¸ Turno del JUGADOR 1", true); return; }
                if (gameState === 'deploy-p2' && data.army !== p2Color) { showNotification("âš ï¸ Turno del JUGADOR 2", true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });

                    if (isFortress) {
                        fortressPos[data.army] = { r: r, c: c };
                        if (gameState === 'deploy-p1') showNotification(`J1: ${p1Color.toUpperCase()} controla el ${p1Territory.toUpperCase()}.`);
                        else showNotification("ğŸ° Fortaleza establecida.");
                    } else {
                        showNotification(`Desplegado: ${data.type.toUpperCase()}`);
                    }
                }
            } else if (data.source === 'board') {
                logicBoard[data.originR][data.originC] = null;
                cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });
                if (isFortress) fortressPos[data.army] = { r: r, c: c };
                showNotification("Unidad reubicada");
            }

            renderBoard();
            updateInventories();
        }

        function updateDungeons() {
            ['rojo', 'negro'].forEach(jailerArmy => {
                const container = document.getElementById(`grave-${jailerArmy}`);
                if (!container) return;
                container.innerHTML = '';

                // Conjunto para recordar quÃ© tipos de piezas ya hemos pintado en esta vuelta
                const drawnTypes = new Set();

                dungeons[jailerArmy].forEach((captive, index) => {
                    // Si ya hemos dibujado una pieza de este tipo, la saltamos (agrupaciÃ³n visual)
                    if (drawnTypes.has(captive.type)) return;

                    // Si es nueva, la registramos y la dibujamos
                    drawnTypes.add(captive.type);

                    const img = document.createElement('img');
                    img.src = getImgUrl(captive.army, captive.type);
                    img.title = `Prisionero: ${captive.type.toUpperCase()}`;

                    // LÃ“GICA DE RESCATE
                    // Permitimos click si estamos jugando o si estamos en la fase de selecciÃ³n obligatoria
                    const isRescueState = (gameState === 'playing' || gameState === 'siege-prisoner-select');

                    if (isRescueState && captive.army === turnColor && jailerArmy !== turnColor) {
                        img.classList.add('rescue-target');
                        img.onclick = () => selectPrisonerToRescue(jailerArmy, index);
                        img.title = "CLICK PARA RESCATAR Y EJECUTAR ASEDIO";
                    }

                    container.appendChild(img);
                });
            });
        }

        function finishTurnP1() {
            // 1. NUEVA LÃ“GICA: GestiÃ³n de Fortaleza "solitaria" (CorrecciÃ³n MontaÃ±as)
            const fPos = fortressPos[p1Color];
            let isRingEmpty = true;

            if (fPos) {
                // Comprobamos si hay tropas en el anillo
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (isInExitZone(r, c, fPos) && logicBoard[r][c] !== null) {
                            isRingEmpty = false;
                            break;
                        }
                    }
                    if (!isRingEmpty) break;
                }
            }

            if (isRingEmpty) {
                // --- AQUÃ ESTÃ EL CAMBIO SOLICITADO ---
                const maxMountains = CONFIG.pieces['montana'].qty; // Generalmente 3
                const currentMountains = reserves[p1Color]['montana'];

                // ESCENARIO A: No ha puesto montaÃ±as (Reserva llena) -> REINICIO TOTAL
                // Le permitimos cambiar de bando/territorio porque no ha construido nada fijo.
                if (currentMountains === maxMountains) {
                    // --- CORRECCIÃ“N: LIMPIEZA PROFUNDA DE VARIABLES ---
                    logicBoard = Array(10).fill().map(() => Array(10).fill(null)); // Borrar tablero
                    fortressPos = { rojo: null, negro: null }; // Olvidar fortalezas
                    dungeons = { rojo: [], negro: [] }; // Vaciar mazmorras
                    shotHighlights = []; // Quitar marcas de disparo

                    // Resetear identidades
                    p1Color = null;
                    p2Color = null;
                    p1Territory = null;

                    // Volver al estado inicial real
                    gameState = 'init';

                    init(); // Ahora sÃ­, llenamos reservas y pintamos el tablero vacÃ­o
                    showNotification("ğŸ° Reinicio: Fortaleza retirada. Puedes cambiar de bando.");
                    return;
                }

                // ESCENARIO B: Ya hay montaÃ±as puestas -> REINICIO PARCIAL (Soft Reset)
                // Solo retiramos la fortaleza, pero mantenemos el bando y las montaÃ±as.
                else {
                    const r = fPos.r;
                    const c = fPos.c;
                    // Limpiamos las 4 celdas del castillo
                    logicBoard[r][c] = null; logicBoard[r][c + 1] = null;
                    logicBoard[r + 1][c] = null; logicBoard[r + 1][c + 1] = null;

                    // Devolvemos a reserva
                    fortressPos[p1Color] = null;
                    reserves[p1Color]['fortaleza'] = 1;

                    showNotification("â†©ï¸ Fortaleza retirada. (Tus montaÃ±as se mantienen).");
                    renderBoard();
                    updateInventories();
                    return;
                }
            }

            // 2. CondiciÃ³n existente: Verificar si quedan montaÃ±as por poner
            if (reserves[p1Color]['montana'] > 0) {
                showNotification("âš ï¸ Debes colocar todas las MONTAÃ‘AS en el mapa antes de terminar.", true);
                return;
            }

            // 3. Pasar turno
            gameState = 'deploy-p2';
            showNotification(`âœ… Despliegue J1 Finalizado. Turno del JUGADOR 2 (${p2Color.toUpperCase()}).`);
            renderBoard();
            updateInventories();
        }


        function finishTurnP2() {
            // 1. NUEVA CONDICIÃ“N: Si el anillo estÃ¡ vacÃ­o, devolvemos la fortaleza a la reserva
            const fPos = fortressPos[p2Color];
            let isRingEmpty = true;
            if (fPos) {
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (isInExitZone(r, c, fPos) && logicBoard[r][c] !== null) {
                            isRingEmpty = false;
                            break;
                        }
                    }
                    if (!isRingEmpty) break;
                }
            }

            if (isRingEmpty) {
                // Retirar Fortaleza del J2 del tablero
                const r = fPos.r;
                const c = fPos.c;
                // Limpiamos las 4 celdas
                logicBoard[r][c] = null; logicBoard[r][c + 1] = null;
                logicBoard[r + 1][c] = null; logicBoard[r + 1][c + 1] = null;

                // Resetear variables
                fortressPos[p2Color] = null;
                reserves[p2Color]['fortaleza'] = 1;

                showNotification("â†©ï¸ Fortaleza retirada. Puedes colocarla de nuevo.");
                renderBoard();
                updateInventories();
                return;
            }

            // 2. CondiciÃ³n existente: MontaÃ±as
            if (reserves[p2Color]['montana'] > 0) {
                showNotification("âš ï¸ Debes colocar todas las MONTAÃ‘AS en el mapa antes de empezar.", true);
                return;
            }

            // AcciÃ³n directa
            gameState = 'playing';
            turnColor = p1Color;

            // Repintar (se quita la niebla)
            renderBoard();
            updateInventories();

            // 1. PRIMERO: Verificamos el estado real (Jaque, Asedios, etc.)
            checkTurnStatus();

            // 2. SEGUNDO: Notificamos SOLO si no hay una emergencia
            if (!isCheck) {
                showNotification(`Â¡COMIENZA LA PARTIDA! Turno de ${turnColor.toUpperCase()}`);
            }
        }

        function attemptRescue(jailerArmy, captiveIndex, captive) {
            // 1. Identificar al enemigo y su fortaleza
            const myArmy = turnColor;
            const enemyFortPos = fortressPos[jailerArmy];

            if (!enemyFortPos) return;

            // 2. Buscar "El Equipo de Rescate"
            let rescueTeam = [];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === myArmy) {
                        if (isInExitZone(r, c, enemyFortPos)) {
                            rescueTeam.push({ r, c, type: piece.type });
                        }
                    }
                }
            }

            // 3. REGLA: Â¿Hay equipo de rescate?
            if (rescueTeam.length < 2) {
                showNotification("â›” Necesitas mÃ¡s tropas rodeando la Fortaleza Enemiga para rescatar.", true);
                return;
            }

            // 4. EJECUTAR EL RESCATE (Todo vuelve a la reserva)
            // A. Recuperar al prisionero
            dungeons[jailerArmy].splice(captiveIndex, 1);
            reserves[myArmy][captive.type]++;

            // B. Retirar al equipo de rescate 
            rescueTeam.forEach(soldier => {
                logicBoard[soldier.r][soldier.c] = null;
                reserves[myArmy][soldier.type]++;
            });

            // 5. VERIFICAR RESERVAS DEL ENEMIGO (SOLUCIÃ“N AL BLOQUEO)
            let enemyReserveCount = 0;
            for (const key in reserves[jailerArmy]) {
                enemyReserveCount += reserves[jailerArmy][key];
            }

            if (enemyReserveCount > 0) {
                // --- CASO A: EL ENEMIGO TIENE RESERVAS (ASEDIO NORMAL) ---
                /* const msg = `ğŸš Â¡RESCATE Ã‰PICO!`;
                 showNotification(msg); // Mensaje corto para que no solape */

                gameState = 'siege-resolution';
                besiegedArmy = jailerArmy;
                turnColor = besiegedArmy; // Turno para el defensor

                updateStatusBar(); // Poner la barra en rojo
            } else {
                // --- CASO B: EL ENEMIGO NO TIENE RESERVAS (SALTAR FASE) ---
                // Como no tiene nada en la reserva, no puede "salvar" nada, 
                // pero tampoco le "matamos" nada extra porque no tiene.
                // Simplemente recuperas tus tropas y sigue tu turno (o pasa al siguiente).

                showNotification(`ğŸš Â¡RESCATE Ã‰PICO! La fortaleza enemiga estaba vacÃ­a.`);

                // El turno se mantiene en el atacante (o pasa al siguiente, segÃºn prefieras).
                // Normalmente tras un asedio resuelto, le tocarÃ­a al atacante mover con sus nuevas tropas
                // o pasamos turno. En la lÃ³gica actual de 'handleDrop', tras romper asedio, turnColor = attacker.
                // AquÃ­ ya somos el attacker.

                // OpciÃ³n: Mantenemos el juego fluyendo
                gameState = 'playing';
                // turnColor sigue siendo myArmy

                checkTurnStatus(); // Actualizar amenazas tras sacar piezas del tablero
            }

            renderBoard();
            updateInventories();
            updateDungeons();
        }

        function getStatusText() {
            // A. PRIORIDAD ABSOLUTA: Fin de juego o Inicio
            if (gameState === 'game-over') return document.getElementById('status-bar').innerText;
            if (gameState === 'init') return "Elige tu destino: Arrastra una Fortaleza para empezar. MantÃ©n el ratÃ³n sobre cualquier unidad para Ayuda Visual";

            const currentArmy = getArmyName(turnColor);

            // B. FASES DE INTERACCIÃ“N FORZADA (El juego estÃ¡ en pausa esperando un click especÃ­fico)
            if (gameState === 'siege-prisoner-select') {
                return `ğŸ”“ DEFENSA FALLIDA: ${currentArmy}, Â¡SELECCIONA UN PRISIONERO PARA LIBERAR!`;
            }
            if (gameState === 'siege-confirmation') {
                return `ğŸ¯ ASEDIO LISTO: ${currentArmy}, PULSA LA FORTALEZA PARA EJECUTAR O MUEVE TROPAS.`;
            }
            if (gameState === 'siege-resolution') {
                return `ğŸ”¥ Â¡SACRIFICIO! EL EJÃ‰RCITO ${currentArmy} DEBE SALVAR UNA PIEZA (EL RESTO MORIRÃ).`;
            }

            // C. BONUS DE CHUSMA (Estado especial de medio turno)
            if (gameState === 'playing-chusma-bonus') {
                return `âš¡ BONIFICACIÃ“N CHUSMA: Mueve otra Chusma o haz click en la misma para terminar.`;
            }

            // D. ESTADOS DE ALERTA (Juego normal pero con peligro)
            // 1. JAQUE (Prioridad alta)
            if (isCheck) {
                return `âš ï¸ Â¡JAQUE AL REY ${currentArmy}! DEBES PROTEGERLO INMEDIATAMENTE. âš ï¸`;
            }

            // 2. ASEDIO INMINENTE (Aviso pasivo: "Te estÃ¡n rodeando")
            if (siegeStatus[turnColor] === true) {
                return `ğŸ›¡ï¸ Â¡ALERTA! LA FORTALEZA ${currentArmy} ESTÃ RODEADA. ROMPE EL CERCO O PERDERÃS TROPAS.`;
            }

            // E. ESTADO ESTÃNDAR (Juego normal o despliegue)
            if (gameState.includes('deploy')) {
                const player = (gameState === 'deploy-p1' ? p1Color : p2Color);
                return `Fase Despliegue: ${player ? player.toUpperCase() : ''}`;
            }

            return `Turno ${currentArmy}`;
        }

        // Pinta el anillo de salida de la fortaleza del ejÃ©rcito indicado
        function highlightFortressRing(army) {
            const fPos = fortressPos[army];
            if (!fPos) return;

            // Recorremos todo el tablero (ineficiente pero seguro y rÃ¡pido en 10x10)
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    // Si es zona de salida, estÃ¡ vacÃ­a y no es agua
                    if (isInExitZone(r, c, fPos)) {
                        if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                            if (tile) tile.classList.add('highlight-ring');
                        }
                    }
                }
            }
        }

        // Limpia el resaltado del anillo
        function clearRingHighlights() {
            document.querySelectorAll('.highlight-ring').forEach(el => {
                el.classList.remove('highlight-ring');
            });
        }

        // Valida SOLO la geometrÃ­a y el camino del movimiento
        function isValidMove(type, r1, c1, r2, c2) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // --- 0. REGLA ESPECIAL: CAPTURA DE ELEFANTES ---
            const myPiece = logicBoard[r1][c1];
            const target = logicBoard[r2][c2];

            if (myPiece && target && target.type === 'elefante' && target.army !== myPiece.army) {
                if (type === 'dragon') { /* Pasa */ }
                else {
                    const totalThreats = countTotalThreats(r2, c2, myPiece.army);
                    if (totalThreats < 2) return false;
                }
            }

            // --- 1. REY ---
            if (type === 'rey') {
                if (currentThreatMap && currentThreatMap[r2][c2] > 0) return false;
                return (dR <= 1 && dC <= 1) && (dR + dC > 0);
            }
            // --- 2. LANCEROS / CHUSMA ---
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            // --- 3. DRAGÃ“N ---
            if (type === 'dragon') {
                if (!((dR === dC) || (r1 === r2 || c1 === c2))) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const obs = logicBoard[cR][cC];
                    if (obs && obs.type !== 'montana') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 4. ARQUEROS (CORREGIDO: Agua bloquea el salto) ---
            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    if (logicBoard[r2][c2] === null) return false; // Solo salta para matar
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    // El agua bloquea el desplazamiento fÃ­sico de la unidad
                    return (logicBoard[midR][midC] === null && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // --- 5. ELEFANTE ---
            if (type === 'elefante') {
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    // Bloqueo total por unidades, montaÃ±as, fortalezas y agua
                    if (logicBoard[cR][cC] !== null || terrain[cR][cC] === 'water') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 6. CABALLERÃA LIGERA (Ruta Dual: 2+1 Ã³ 1+2) ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;

                const checkBlock = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };

                // RUTA A: Primero salto largo (2), luego corto (1)
                let pathA_Valid = false;
                const diags2 = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [kr, kc] of diags2) {
                    // Buscamos la "rodilla" a distancia 2 del origen que conecte con destino
                    if (Math.abs(r2 - (r1 + kr)) === 1 && Math.abs(c2 - (c1 + kc)) === 1) {
                        const kneeR = r1 + kr;
                        const kneeC = c1 + kc;
                        const midR = (r1 + kneeR) / 2;
                        const midC = (c1 + kneeC) / 2;

                        if (!checkBlock(midR, midC) && !checkBlock(kneeR, kneeC)) {
                            pathA_Valid = true;
                        }
                        break;
                    }
                }

                // RUTA B: Primero salto corto (1), luego largo (2)
                let pathB_Valid = false;
                const diags1 = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [kr, kc] of diags1) {
                    // Buscamos la "rodilla" a distancia 1 del origen que conecte con destino
                    if (Math.abs(r2 - (r1 + kr)) === 2 && Math.abs(c2 - (c1 + kc)) === 2) {
                        const kneeR = r1 + kr;
                        const kneeC = c1 + kc;
                        const midR = (kneeR + r2) / 2;
                        const midC = (kneeC + c2) / 2;

                        if (!checkBlock(kneeR, kneeC) && !checkBlock(midR, midC)) {
                            pathB_Valid = true;
                        }
                        break;
                    }
                }

                return (pathA_Valid || pathB_Valid);
            }

            // --- 7. CABALLERÃA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const myArmy = logicBoard[r1][c1] ? logicBoard[r1][c1].army : null;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true; // Agua bloquea
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== myArmy) return true; // Enemigo bloquea
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- 8. TRABUQUETE ---
            if (type === 'trabuquete') {
                // A. MOVIMIENTO (Destino vacÃ­o): Solo Diagonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR === 1 && dC === 1); // El agua se valida fuera (handleDrop)
                }
                // B. DISPARO: Solo Ortogonal
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Dispara sobre unidades y agua. Solo bloquean Muros.
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 9. ESCORPIÃ“N ---
            if (type === 'escorpion') {
                // A. MOVIMIENTO (Destino vacÃ­o): Solo Ortogonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR + dC === 1);
                }
                // B. DISPARO: Solo Diagonal
                if (dR !== dC) return false;

                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Bloqueos fÃ­sicos
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;

                    // Unidades
                    if (o) {
                        if (o.army !== logicBoard[r1][c1].army) {
                            enemiesInPath++;
                            lastEnemyPos = { r: cR, c: cC };
                        } else {
                            // BLOQUEO: No puede atravesar unidades amigas
                            return false;
                        }
                    }
                    // Agua: Se ignora (proyectil vuela sobre ella)

                    cR += sR; cC += sC;
                }

                // LÃ³gica de PerforaciÃ³n
                if (enemiesInPath === 0) return true; // Tiro limpio
                if (enemiesInPath === 1) {
                    // Distancia entre la vÃ­ctima intermedia y el objetivo final
                    const dist = Math.abs(r2 - lastEnemyPos.r);
                    // Permite hueco de 0, 1 o 2 casillas (ocupadas por agua o vacÃ­o)
                    if (dist >= 1 && dist <= 3) return true;
                }
                return false;
            }

            return false;
        }

        function finishChusmaBonusTurn() {
            /* isBesieged = false; // <--- AÃ‘ADE ESTA LÃNEA: Apaga la alarma anterior a la fuerza */
            // Cambiar turno y volver a la normalidad
            turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
            gameState = 'playing';
            chusmaMovedCoords = null;

            /* showNotification(`Turno ${getArmyName(turnColor)}`); */

            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

        // --- SISTEMA DE AMENAZAS (Influence Maps) ---

        // Genera una matriz 10x10 donde cada celda indica cuÃ¡ntas unidades del 'attackingArmy' amenazan esa posiciÃ³n
        function getThreatMap(attackingArmy) {
            // 1. Crear matriz vacÃ­a de ceros
            let map = Array(10).fill().map(() => Array(10).fill(0));

            // 2. Identificar al Rey VÃ­ctima para hacerlo transparente (Fix Dragon X-Ray)
            // Si ataca el rojo, la vÃ­ctima es el negro.
            const victimArmy = (attackingArmy === 'rojo') ? 'negro' : 'rojo';
            let kingPos = null;

            // Buscamos al Rey
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.type === 'rey' && p.army === victimArmy) {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            // 3. Recorrer tablero buscando atacantes
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === attackingArmy) {

                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                if (r === tr && c === tc) continue;

                                // Pasamos la posiciÃ³n del rey a ignorar (kingPos)
                                if (canUnitAttack(piece.type, r, c, tr, tc, piece.army, kingPos)) {
                                    map[tr][tc]++;
                                }
                            }
                        }
                    }
                }
            }
            return map;
        }

        // Verifica si una unidad en (r1,c1) podrÃ­a atacar/capturar en (r2,c2)
        function canUnitAttack(type, r1, c1, r2, c2, army, ignorePos = null) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            if (type === 'rey') return (dR <= 1 && dC <= 1);
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    const isMidEmpty = (logicBoard[midR][midC] === null || (ignorePos && midR === ignorePos.r && midC === ignorePos.c));
                    // Agua bloquea ataque de salto
                    return (isMidEmpty && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // --- CABALLERÃA LIGERA (Ruta Dual para Amenazas) ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;

                const checkBlock = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (ignorePos && r === ignorePos.r && c === ignorePos.c) return false;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };

                // RUTA A (2+1)
                let pathA = false;
                const diags2 = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [kr, kc] of diags2) {
                    if (Math.abs(r2 - (r1 + kr)) === 1 && Math.abs(c2 - (c1 + kc)) === 1) {
                        const kneeR = r1 + kr, kneeC = c1 + kc;
                        const midR = (r1 + kneeR) / 2, midC = (c1 + kneeC) / 2;
                        if (!checkBlock(midR, midC) && !checkBlock(kneeR, kneeC)) pathA = true;
                        break;
                    }
                }

                // RUTA B (1+2)
                let pathB = false;
                const diags1 = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [kr, kc] of diags1) {
                    if (Math.abs(r2 - (r1 + kr)) === 2 && Math.abs(c2 - (c1 + kc)) === 2) {
                        const kneeR = r1 + kr, kneeC = c1 + kc;
                        const midR = (kneeR + r2) / 2, midC = (kneeC + c2) / 2;
                        if (!checkBlock(kneeR, kneeC) && !checkBlock(midR, midC)) pathB = true;
                        break;
                    }
                }

                return (pathA || pathB);
            }

            // --- CABALLERÃA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    if (ignorePos && r === ignorePos.r && c === ignorePos.c) return false;
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== army) return true;
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- RAYCAST (DragÃ³n, Armas) ---
            const checkRay = (isOrtho, isDiag, canFly, isWeapon) => {
                const validOrtho = (r1 === r2 || c1 === c2);
                const validDiag = (dR === dC);
                if (isOrtho && isDiag) { if (!validOrtho && !validDiag) return false; }
                else if (isOrtho) { if (!validOrtho) return false; }
                else if (isDiag) { if (!validDiag) return false; }

                const sR = Math.sign(r2 - r1);
                const sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    if (ignorePos && cR === ignorePos.r && cC === ignorePos.c) {
                        cR += sR; cC += sC; continue;
                    }
                    const obs = logicBoard[cR][cC];

                    if (canFly) {
                        if (obs && obs.type !== 'montana') return false;
                    } else {
                        if (terrain[cR][cC] === 'water' && !isWeapon) return false;
                        if (obs) {
                            if (obs.type === 'montana' || obs.type === 'fortaleza') return false;
                            if (isWeapon && type === 'escorpion') {
                                if (obs.army !== army) { enemiesInPath++; lastEnemyPos = { r: cR, c: cC }; }
                                else return false; // Bloqueo amigo
                            } else if (isWeapon && type === 'trabuquete') {
                                // Ignora
                            } else {
                                return false;
                            }
                        }
                    }
                    cR += sR; cC += sC;
                }

                if (type === 'escorpion' && enemiesInPath > 0) {
                    if (enemiesInPath === 1) {
                        const dist = Math.abs(r2 - lastEnemyPos.r);
                        return (dist >= 1 && dist <= 3);
                    }
                    return false;
                }
                return true;
            };

            if (type === 'dragon') return checkRay(true, true, true, false);
            if (type === 'elefante') return checkRay(true, false, false, false);
            if (type === 'trabuquete') return checkRay(true, false, false, true);
            if (type === 'escorpion') return checkRay(false, true, false, true);

            return false;
        }

        // Verifica amenazas y estados globales
        function checkTurnStatus() {
            // 1. Calcular mapas de amenaza
            const enemy = (turnColor === 'rojo') ? 'negro' : 'rojo';
            const threatMap = getThreatMap(enemy);
            const attackMap = getThreatMap(turnColor);

            // A. DETECCIÃ“N DE ASEDIO
            siegeStatus.rojo = false;
            siegeStatus.negro = false;

            ['rojo', 'negro'].forEach(army => {
                const fort = fortressPos[army];
                if (fort) {
                    const attacker = (army === 'rojo') ? 'negro' : 'rojo';
                    let enemiesAtGate = 0;
                    for (let r = 0; r < 10; r++) {
                        for (let c = 0; c < 10; c++) {
                            if (isInExitZone(r, c, fort)) {
                                const p = logicBoard[r][c];
                                if (p && p.army === attacker) enemiesAtGate++;
                            }
                        }
                    }
                    if (enemiesAtGate >= 2) siegeStatus[army] = true;
                }
            });

            // B. BUSCAR AL REY
            let kingPos = null;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === turnColor && p.type === 'rey') {
                        kingPos = { r, c };
                        break;
                    }
                }
                if (kingPos) break;
            }

            if (!kingPos) { isCheck = false; updateStatusBar(); return; }

            // 2. DETECCIÃ“N DE JAQUE
            isCheck = (threatMap[kingPos.r][kingPos.c] > 0);

            // C. ACTUALIZAR INTERFAZ (Prioridad inmediata)
            updateStatusBar();

            // D. VERIFICAR SI HAY SALVACIÃ“N (MATE / AHOGADO)
            currentThreatMap = threatMap;
            currentAttackMap = attackMap;

            let hasMoves = false;

            try {
                // BUSCAMOS CUALQUIER MOVIMIENTO QUE SALVE AL REY
                // Recorremos todas nuestras piezas
                outerLoop:
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        const p = logicBoard[r][c];
                        if (p && p.army === turnColor) {

                            // Probamos todos los destinos posibles
                            for (let tr = 0; tr < 10; tr++) {
                                for (let tc = 0; tc < 10; tc++) {

                                    // 1. Â¿Es un movimiento geomÃ©tricamente vÃ¡lido?
                                    if (isValidMove(p.type, r, c, tr, tc)) {

                                        // Filtros bÃ¡sicos de terreno/ocupaciÃ³n
                                        if (terrain[tr][tc] === 'water' && p.type !== 'trabuquete' && p.type !== 'escorpion') continue;
                                        const target = logicBoard[tr][tc];
                                        if (target && target.army === turnColor && p.type !== 'lanceros') continue;
                                        if (target && (target.type === 'montana' || target.type === 'fortaleza')) continue;

                                        // 2. SIMULACIÃ“N DE SEGURIDAD (EL JUEZ FINAL)
                                        // Realizamos el movimiento en el tablero lÃ³gico temporalmente
                                        const originalSource = logicBoard[r][c];
                                        const originalTarget = logicBoard[tr][tc];

                                        logicBoard[r][c] = null;
                                        logicBoard[tr][tc] = originalSource;

                                        // RE-CALCULAMOS: Â¿Sigue el Rey en jaque en este futuro hipotÃ©tico?
                                        // Nota: Si movimos al Rey, su posiciÃ³n ha cambiado a (tr, tc)
                                        let simKingR = (p.type === 'rey') ? tr : kingPos.r;
                                        let simKingC = (p.type === 'rey') ? tc : kingPos.c;

                                        // Usamos getAttackers que lee el tablero modificado (con el bloqueo/captura aplicado)
                                        const threats = getAttackers(simKingR, simKingC, turnColor);
                                        const isSuicide = (threats.length > 0);

                                        // Deshacemos el movimiento (Revertir)
                                        logicBoard[r][c] = originalSource;
                                        logicBoard[tr][tc] = originalTarget;

                                        if (!isSuicide) {
                                            hasMoves = true;
                                            break outerLoop; // Â¡Encontramos al menos una salida! No es Mate.
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (err) {
                console.error("Error cÃ¡lculo Mate:", err);
                hasMoves = true; // Ante la duda, dejar jugar
            }

            // Si el Rey parece condenado en el tablero, verificamos "en secreto" 
            // si la reserva puede salvarle. Si es asÃ­, NO declaramos Mate.
            if (!hasMoves) {
                const myFort = fortressPos[turnColor];

                // 1. Â¿Tenemos alguna tropa en la reserva? (Excluimos MontaÃ±as/Fortalezas)
                let canDeploySomething = false;
                let samplePiece = null;

                if (myFort) {
                    for (const [type, count] of Object.entries(reserves[turnColor])) {
                        if (type !== 'montana' && type !== 'fortaleza' && count > 0) {
                            canDeploySomething = true;
                            samplePiece = type; // Usamos el primer tipo disponible para probar
                            break;
                        }
                    }
                }

                // 2. Si hay tropas, simulamos poner una en el anillo para bloquear
                if (canDeploySomething) {
                    // Limitamos la bÃºsqueda al Ã¡rea de la fortaleza para optimizar
                    const minR = Math.max(0, myFort.r - 1);
                    const maxR = Math.min(9, myFort.r + 2);
                    const minC = Math.max(0, myFort.c - 1);
                    const maxC = Math.min(9, myFort.c + 2);

                    reserveLoop:
                    for (let r = minR; r <= maxR; r++) {
                        for (let c = minC; c <= maxC; c++) {
                            // Solo probamos en casillas vÃ¡lidas de despliegue
                            if (isInExitZone(r, c, myFort) && logicBoard[r][c] === null && terrain[r][c] !== 'water') {

                                // A. Simular despliegue (Bloqueo fÃ­sico)
                                logicBoard[r][c] = { army: turnColor, type: samplePiece };

                                // B. Â¿Sigue el Rey amenazado?
                                // (Al poner un cuerpo sÃ³lido, getAttackers detectarÃ¡ si se cortÃ³ la visiÃ³n)
                                const threats = getAttackers(kingPos.r, kingPos.c, turnColor);

                                // C. Revertir simulaciÃ³n
                                logicBoard[r][c] = null;

                                if (threats.length === 0) {
                                    hasMoves = true; // Â¡Existe salvaciÃ³n! No decimos cuÃ¡l, pero el juego sigue.
                                    break reserveLoop;
                                }
                            }
                        }
                    }
                }
            }

            // E. RESOLUCIÃ“N DE PARTIDA
            if (!hasMoves) {
                if (isCheck) {
                    finishGame(enemy, "POR JAQUE MATE");
                } else {
                    finishGame(null, "TABLAS POR REY AHOGADO");
                }
            }
        }

        // Helper para terminar partida (si no la tenÃ­as ya de mis intentos anteriores)
        function finishGame(winnerArmy, reason = "") {
            gameState = 'game-over';
            const winnerText = winnerArmy ? `VICTORIA DEL EJÃ‰RCITO ${winnerArmy.toUpperCase()}` : "EMPATE";
            const bar = document.getElementById('status-bar');
            bar.innerText = `ğŸ FIN DE PARTIDA: ${reason}. ${winnerText}`;
            bar.style.color = winnerArmy ? '#2ecc71' : '#fff';
            bar.style.fontWeight = 'bold';
        }

        // Actualiza la barra de estado gestionando prioridades y colores
        function showNotification(msg, isError = false) {
            // SI HAY EMERGENCIA (Jaque/Asedio), NO mostramos notificaciones triviales.
            // Forzamos updateStatusBar por si acaso, y salimos.
            if (isCheck || siegeStatus[turnColor] === true || gameState === 'siege-resolution' || gameState === 'siege-confirmation') {
                updateStatusBar();
                return;
            }

            const bar = document.getElementById('status-bar');

            // 1. ACTIVAR BLOQUEO DE ESTADO
            isNotificationActive = true;

            bar.innerText = msg;
            bar.classList.remove('status-critical');
            bar.style.color = isError ? '#e74c3c' : '#f1c40f';

            bar.style.opacity = 0;
            setTimeout(() => bar.style.opacity = 1, 50);

            if (notificationTimer) clearTimeout(notificationTimer);

            notificationTimer = setTimeout(() => {
                isNotificationActive = false; // Liberar bloqueo
                updateStatusBar();            // Restaurar estado real del juego
                bar.style.opacity = 1;
                notificationTimer = null;
            }, 3000);
        }

        function updateStatusBar() {
            const bar = document.getElementById('status-bar');

            // 1. Calculamos PRIMERO si la situaciÃ³n actual es CRÃTICA
            const isCritical = (
                gameState === 'siege-resolution' ||
                gameState === 'siege-confirmation' ||
                gameState === 'siege-prisoner-select' ||
                siegeStatus[turnColor] === true ||
                isCheck
            );

            // 2. FILTRO DE PRIORIDAD:
            // Si hay una notificaciÃ³n temporal activa (ej: "Â¡Captura!")...
            // ...SOLO la respetamos si NO estamos en una situaciÃ³n crÃ­tica.
            // Si es crÃ­tica (Jaque/Asedio), ignoramos el bloqueo y sobrescribimos el mensaje inmediatamente.
            if (isNotificationActive && !isCritical) return;

            // 3. Obtenemos el texto segÃºn la jerarquÃ­a
            const text = getStatusText();
            bar.innerText = text;

            // 4. Aplicamos estilos
            if (isCritical) {
                bar.classList.add('status-critical'); // Clase CSS con animaciÃ³n roja
                bar.style.color = '#ff2e2e'; // Aseguramos rojo

                // Si acabamos de sobrescribir una notificaciÃ³n temporal, nos aseguramos de que se vea
                bar.style.opacity = 1;
            } else {
                bar.classList.remove('status-critical');
                // Si es bonus de chusma, color especial (Cyan), si no, Dorado estÃ¡ndar
                if (gameState === 'playing-chusma-bonus') {
                    bar.style.color = '#3498db';
                } else {
                    bar.style.color = 'var(--c-gold)';
                }
            }

            bar.style.opacity = 1;
        }

        // Traduce el color del ejÃ©rcito a su territorio (Norte/Sur)
        function getArmyName(armyColor) {
            // 1. SEGURIDAD: Si es null (inicio), devolvemos cadena vacÃ­a para evitar crash
            if (!armyColor) return "";

            // 2. Si aÃºn no hay territorios definidos, devolvemos el color genÃ©rico
            if (!p1Territory) return "DE " + armyColor.toUpperCase();

            const isP1 = (armyColor === p1Color);
            const isNorth = isP1 ? (p1Territory === 'north') : (p1Territory === 'south');

            return isNorth ? "DEL NORTE" : "DEL SUR";
        }

        // Ejecuta el asedio cuando no hay prisioneros que rescatar
        function triggerEmptySiege(attacker, victim) {
            // 1. Identificar y devolver tropas de asedio a casa
            const fortPos = fortressPos[victim];
            let rescueTeam = [];

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === attacker && isInExitZone(r, c, fortPos)) {
                        // Devolvemos a reserva y quitamos del tablero
                        logicBoard[r][c] = null;
                        reserves[attacker][p.type]++;
                    }
                }
            }

            // 2. Notificar
            /* showNotification("âš”ï¸ Asedio sin prisioneros: Tropas replegadas. Â¡EL ENEMIGO DEBE SACRIFICAR!"); */

            // 3. Activar Fase de Sacrificio (Usando tu mecÃ¡nica existente en handleDrop)
            gameState = 'siege-resolution';
            besiegedArmy = victim;
            turnColor = victim; // Turno para el que sufre el sacrificio

            // 4. Actualizar todo
            updateStatusBar();
            renderBoard();
            updateInventories();
            updateDungeons();
        }

        // =========================================================
        //  FUNCIONES DE GESTIÃ“N DE ASEDIO Y CONSECUENCIAS
        // =========================================================

        // 1. Caso A: El jugador hace click en un prisionero (Ya tenÃ­as el onclick en updateDungeons)
        function selectPrisonerToRescue(jailerArmy, index) {
            const attackerArmy = turnColor;
            const defenderArmy = jailerArmy;
            const prisoner = dungeons[jailerArmy][index];

            // 1. Recuperar prisionero
            dungeons[jailerArmy].splice(index, 1);
            reserves[attackerArmy][prisoner.type]++;

            // 2. Retirar tropas de asedio
            executeSiegeReturn(defenderArmy, attackerArmy);

            // 3. INFORMAR AL JUGADOR (Restauramos notificaciÃ³n explicativa)
            showNotification(`ğŸ”“ ${prisoner.type.toUpperCase()} rescatado. Prisionero y tropas regresan a tu RESERVA.`);

            // 4. TRANSICIÃ“N CON PAUSA (2 segundos para leer antes de la alarma roja)
            setTimeout(() => {
                startSacrificePhase(defenderArmy, true);
            }, 2000);
        }

        // 2. Caso B: No habÃ­a prisioneros (Asedio "accidental" o sin botÃ­n)
        function resolveSiegeNoPrisoners(attacker, victim) {
            // 1. Devolver tropas de asedio a casa
            executeSiegeReturn(victim, attacker);

            // 2. INFORMAR
            showNotification("ğŸ”„ Asedio finalizado. Tus tropas regresan a la RESERVA.");

            // 3. PAUSA DE LECTURA (2 segundos)
            setTimeout(() => {
                startSacrificePhase(victim, false);
            }, 2000);
        }

        // Auxiliar: Devuelve las tropas de asedio a casa (VERSIÃ“N BLINDADA)
        function executeSiegeReturn(victimArmy, attackerArmy) {
            const fortPos = fortressPos[victimArmy];
            if (!fortPos) return; // Seguridad

            // Recorremos todo el tablero para asegurar limpieza total
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];

                    // Si encontramos una unidad del ATACANTE en la zona de salida de la VÃCTIMA
                    if (p && p.army === attackerArmy && isInExitZone(r, c, fortPos)) {
                        logicBoard[r][c] = null; // Eliminar del tablero
                        reserves[attackerArmy][p.type]++; // Devolver a reserva
                    }
                }
            }
            // Forzamos repintado inmediato para que no haya dudas visuales
            renderBoard();
            updateInventories();
        }

        // 3. FASE FINAL: Verificar si hay sacrificio o si la fortaleza estÃ¡ vacÃ­a
        function startSacrificePhase(victimArmy, wasExchange) {
            turnColor = victimArmy;
            siegeStatus[victimArmy] = false;

            // 1. Comprobar reservas
            let hasReserves = false;
            let hasKing = (reserves[victimArmy]['rey'] > 0);

            for (const type in reserves[victimArmy]) {
                if (reserves[victimArmy][type] > 0) hasReserves = true;
            }

            // CASO ESPECIAL: "CAPTURA TOTAL" (Ãšltimo supuesto)
            // No hubo intercambio Y no estÃ¡ el Rey -> El defensor no tiene derecho a salvar nada.
            if (hasReserves && !wasExchange && !hasKing) {
                // Captura automÃ¡tica de todo
                const attacker = (victimArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[victimArmy])) {
                    if (type === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) {
                            dungeons[attacker].push({ type: type, army: victimArmy });
                            capturedCount++;
                        }
                        reserves[victimArmy][type] = 0;
                    }
                }

                showNotification(`ğŸš« Sin intercambio: ${capturedCount} unidades capturadas en la reserva.`);

                // Volver al juego
                gameState = 'playing';
                besiegedArmy = null;
                // El turno se queda en el defensor para que mueva en el tablero (o pasa, segÃºn prefieras. 
                // Tu lÃ³gica decÃ­a "mantiene el turno en modo normal", asÃ­ que no cambiamos turnColor).
                checkTurnStatus();

                renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // CASO ESTÃNDAR: Puede salvar (o debe salvar al Rey)
            if (hasReserves) {

                /* let msg = wasExchange
                    ? `ğŸš¨ FORTALEZA CAÃDA: ${victimArmy.toUpperCase()}, salva una unidad.`
                    : `ğŸ‘‘ Â¡PELIGRO CRÃTICO! ${victimArmy.toUpperCase()}, DEBES SALVAR AL REY (El resto serÃ¡ capturado).`;
 
                showNotification(msg); */

                gameState = 'siege-resolution';
                besiegedArmy = victimArmy;
                updateStatusBar();
            } else {
                // CASO: NO TIENE RESERVAS (Ni para salvar ni para perder)
                showNotification("ğŸ“­ Fortaleza vacÃ­a. Fin del asedio.");
                gameState = 'playing';
                besiegedArmy = null;
                checkTurnStatus();
            }

            renderBoard(); updateInventories(); updateDungeons();
        }

        // FunciÃ³n nueva: Ejecuta el asedio una vez confirmado por el jugador
        function executeConfirmedSiege(attackerArmy, defenderArmy) {
            // CORRECCIÃ“N + SEGURIDAD: Buscamos tropas del ATACANTE en la mazmorra del DEFENSOR.
            const prisoners = dungeons[defenderArmy].filter(p => p.army === attackerArmy);

            if (prisoners.length > 0) {
                // CASO A: HAY RESCATE REAL -> EL ATACANTE ELIGE
                turnColor = attackerArmy;
                gameState = 'siege-prisoner-select';

                /* showNotification(`âš”ï¸ ASEDIO Ã‰PICO: ${attackerArmy.toUpperCase()}, elige a quiÃ©n rescatar.`); */

                renderBoard(); updateInventories(); updateDungeons();
                updateStatusBar();
            } else {
                // CASO B: NO HAY PRISIONEROS -> RESOLUCIÃ“N DIRECTA
                resolveSiegeNoPrisoners(attackerArmy, defenderArmy);
            }
        }

        // Cuenta cuÃ¡ntas unidades del 'attackingArmy' amenazan la casilla (r, c)
        // Se usa para validar la captura del Elefante en tiempo real
        function countThreatsOnTarget(r, c, attackingArmy) {
            let threats = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    const piece = logicBoard[tr][tc];
                    // Si hay una pieza aliada y NO es la que estÃ¡ en la casilla destino (obvio)
                    if (piece && piece.army === attackingArmy) {
                        // Verificamos si esa pieza puede atacar la casilla objetivo
                        if (canUnitAttack(piece.type, tr, tc, r, c, attackingArmy)) {
                            threats++;
                        }
                    }
                }
            }
            return threats;
        }

        // Cuenta cuÃ¡ntos ALIADOS (excluyendo al propio atacante) amenazan la casilla objetivo
        function countAlliesThreatening(targetR, targetC, army, excludeR, excludeC) {
            let allies = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    // Saltamos nuestra propia casilla de origen (porque nos estamos moviendo/disparando)
                    if (tr === excludeR && tc === excludeC) continue;

                    const piece = logicBoard[tr][tc];
                    if (piece && piece.army === army) {
                        // Verificamos si este aliado puede atacar la casilla objetivo
                        if (canUnitAttack(piece.type, tr, tc, targetR, targetC, army)) {
                            allies++;
                        }
                    }
                }
            }
            return allies;
        }


        // Cuenta TODAS las unidades (yo incluido) que amenazan la casilla objetivo
        function countTotalThreats(targetR, targetC, army) {
            let threats = 0;
            for (let tr = 0; tr < 10; tr++) {
                for (let tc = 0; tc < 10; tc++) {
                    const piece = logicBoard[tr][tc];
                    if (piece && piece.army === army) {
                        // Verificamos si esta pieza puede atacar la casilla objetivo
                        // No hace falta excluir nada: si yo ataco, cuento como 1.
                        if (canUnitAttack(piece.type, tr, tc, targetR, targetC, army)) {
                            threats++;
                        }
                    }
                }
            }
            return threats;
        }

        // Devuelve una lista con las coordenadas y tipo de los enemigos que atacan (r, c)
        function getAttackers(targetR, targetC, victimArmy) {
            const attackers = [];
            const enemyArmy = (victimArmy === 'rojo') ? 'negro' : 'rojo';

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === enemyArmy) {
                        // Check rÃ¡pido: Â¿Esta pieza enemiga amenaza mi casilla?
                        if (canUnitAttack(p.type, r, c, targetR, targetC, enemyArmy)) {
                            attackers.push({ r: r, c: c, type: p.type });
                        }
                    }
                }
            }
            return attackers;
        }

        // Simula un movimiento para ver si deja al Rey en Jaque (Suicidio)
        function isSimulatedMoveSafe(pieceType, r1, c1, r2, c2, army) {
            // 1. Identificar dÃ³nde estÃ¡ el Rey
            let kingR, kingC;

            if (pieceType === 'rey') {
                kingR = r2; kingC = c2;
            } else {
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        const p = logicBoard[r][c];
                        if (p && p.type === 'rey' && p.army === army) {
                            kingR = r; kingC = c; break;
                        }
                    }
                }
            }

            // Si no hay rey, no hay jaque (seguro)
            if (kingR === undefined) return true;

            // VARIABLES PARA REVERTIR
            // Usamos lÃ³gica defensiva por si r2/c2 vinieran mal
            const originalTarget = (logicBoard[r2] && logicBoard[r2][c2]) ? logicBoard[r2][c2] : null;
            let originalSource = null;
            let sourceCleared = false;

            try {
                // 2. APLICAR MOVIMIENTO SIMULADO
                if (r1 !== null && r1 !== undefined && c1 !== null && c1 !== undefined) {
                    originalSource = logicBoard[r1][c1];

                    // Si la casilla origen estÃ¡ vacÃ­a (bug raro), abortamos
                    if (!originalSource) return true;

                    logicBoard[r1][c1] = null;
                    sourceCleared = true;
                    logicBoard[r2][c2] = originalSource;
                } else {
                    // Caso Reserva (aunque handleDragOver ya lo filtra, lo dejamos por robustez)
                    logicBoard[r2][c2] = { type: pieceType, army: army };
                }

                // 3. VERIFICAR AMENAZAS
                const attackers = getAttackers(kingR, kingC, army);
                return (attackers.length === 0);

            } catch (e) {
                console.error("Error simulaciÃ³n:", e);
                return true; // Ante error, permitimos el movimiento
            } finally {
                // 4. REVERTIR SIEMPRE
                if (sourceCleared && r1 !== null && c1 !== null) {
                    logicBoard[r1][c1] = originalSource;
                }
                logicBoard[r2][c2] = originalTarget;
            }
        }

        // =========================================================
        //  MODO DEBUG: DESPLIEGUE ALEATORIO AUTOMÃTICO (CORREGIDO)
        // =========================================================
        function activateDebugMode() {
            if (!confirm("âš ï¸ Â¿ACTIVAR MODO DEBUG?\nSe reiniciarÃ¡ la partida con despliegue aleatorio legal.")) return;

            console.log("ğŸ› ï¸ Ejecutando Despliegue Aleatorio...");

            init();
            logicBoard = Array(10).fill().map(() => Array(10).fill(null));
            fortressPos = { rojo: null, negro: null };
            dungeons = { rojo: [], negro: [] };
            shotHighlights = [];

            p1Color = 'rojo'; p1Territory = 'north';
            p2Color = 'negro';

            // 1. COLOCAR FORTALEZAS (Reglas estrictas de bordes)
            // Norte (Rojo): Filas permitidas para la esquina superior-izq: 1 Ã³ 2 (para no tocar 0 ni 4)
            // Sur (Negro): Filas permitidas: 6 Ã³ 7 (para no tocar 5 ni 9)
            // Columnas permitidas: 1 a 7 (para no tocar 0 ni 9 con el ancho 2)

            const validRowsNorth = [1, 2];
            const validRowsSouth = [6, 7];

            const placeFortress = (army, validRows) => {
                const r = validRows[Math.floor(Math.random() * validRows.length)];
                const c = Math.floor(Math.random() * 7) + 1; // 1 a 7

                logicBoard[r][c] = { army, type: 'fortaleza' };
                logicBoard[r][c + 1] = { army, type: 'fortaleza' };
                logicBoard[r + 1][c] = { army, type: 'fortaleza' };
                logicBoard[r + 1][c + 1] = { army, type: 'fortaleza' };
                fortressPos[army] = { r, c };
                reserves[army]['fortaleza'] = 0;
            };

            placeFortress('rojo', validRowsNorth);
            placeFortress('negro', validRowsSouth);

            // 2. COLOCAR TROPAS (Solo en Anillo de Salida)
            const placeTroops = (army) => {
                const fort = fortressPos[army];
                // Identificar todas las casillas vÃ¡lidas del anillo
                let validSpots = [];
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (isInExitZone(r, c, fort) && logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            validSpots.push({ r, c });
                        }
                    }
                }

                // Barajar posiciones
                validSpots.sort(() => Math.random() - 0.5);

                // Colocar unidades hasta llenar huecos o vaciar reserva
                for (const [type, count] of Object.entries(reserves[army])) {
                    if (type === 'montana') continue; // Las montaÃ±as van aparte
                    let qty = count;
                    while (qty > 0 && validSpots.length > 0) {
                        const spot = validSpots.pop();
                        logicBoard[spot.r][spot.c] = { army, type };
                        reserves[army][type]--;
                        qty--;
                    }
                }
            };

            placeTroops('rojo');
            placeTroops('negro');

            // 3. COLOCAR MONTAÃ‘AS (En cualquier lugar libre de su territorio)
            const placeMountains = (army, minR, maxR) => {
                let qty = reserves[army]['montana'];
                let attempts = 0;
                while (qty > 0 && attempts < 100) {
                    const r = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
                    const c = Math.floor(Math.random() * 10);
                    if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                        logicBoard[r][c] = { army, type: 'montana' };
                        reserves[army]['montana']--;
                        qty--;
                    }
                    attempts++;
                }
            };

            placeMountains('rojo', 0, 4);
            placeMountains('negro', 5, 9);

            // Iniciar
            gameState = 'playing';
            turnColor = 'rojo';

            showNotification("ğŸ› ï¸ MODO DEBUG: Despliegue Legal Completado");
            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

    </script>
</body>

</html>
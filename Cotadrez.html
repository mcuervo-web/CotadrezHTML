<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Cotadrez</title>
    <link rel="icon" type="image/svg+xml"
        href="https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main/Negro/Castillo.svg">
    <style>
        :root {
            --c-red: #e74c3c;
            --c-black: #7f8c8d;
            /* Un gris m√°s claro para el borde negro para que se vea sobre el fondo oscuro */
            --c-board-l: #f0d9b5;
            --c-board-d: #b58863;
            --c-water: #3498db;
            --c-bg: #1a252f;
            --c-gold: #f1c40f;
        }

        body {
            background-color: var(--c-bg);
            color: white;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- CABECERA --- */
        header {
            text-align: center;
            margin-bottom: 5px;
        }

        .game-title {
            font-size: 3em;
            margin: 0;
            letter-spacing: 5px;
            color: white;
            text-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            font-weight: 800;
        }

        .status-bar {
            font-size: 1.2em;
            color: var(--c-gold);
            margin-top: 10px;
            margin-bottom: 0;
            font-weight: 500;
            min-height: 1.5em;
            /* Para que no salte si est√° vac√≠o */
        }

        /* --- ESTADO CR√çTICO (JAQUE / ASEDIO) --- */
        .status-critical {
            color: #ff2e2e !important;
            /* Rojo brillante */
            font-weight: 800 !important;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            /* Resplandor rojo */
            animation: pulse-text 0.8s infinite alternate;
        }

        /* --- FORTALEZA ASEDIADA (PARPADEO) --- */
        .siege-pulse {
            filter: drop-shadow(0 0 10px var(--c-red)) brightness(1.2);
            animation: pulse-fortress 1s infinite alternate;
            cursor: pointer !important;
            /* Mano para indicar que es clickable */
        }

        @keyframes pulse-fortress {
            from {
                filter: drop-shadow(0 0 5px var(--c-red));
                transform: scale(1);
            }

            to {
                filter: drop-shadow(0 0 15px var(--c-red));
                transform: scale(1.1);
            }
        }

        @keyframes pulse-text {
            from {
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
                transform: scale(1);
            }

            to {
                text-shadow: 0 0 20px rgba(255, 0, 0, 1);
                transform: scale(1.02);
            }
        }

        /* --- LAYOUT PRINCIPAL --- */
        .main-container {
            display: flex;
            gap: 20px;
            align-items: center;
            height: auto;
            margin-top: 5px;
        }

        /* --- PANELES LATERALES (Inventario + Mazmorra) --- */
        .panel {
            width: 240px;
            height: 600px;
            background: rgba(0, 0, 0, 0.2);
            border: 3px solid #444;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Para que la mazmorra no se salga de los bordes redondeados */
        }

        /* Secci√≥n Superior: Reserva (Inventario) */
        .inventory-section {
            flex: 1;
            /* Ocupa el espacio restante */
            padding: 5px;
            overflow-y: auto;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .inv-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }


        /* Resaltado del Anillo de Fortaleza */
        .highlight-ring {
            box-shadow: inset 0 0 0 3px #2ecc71 !important;
            /* Borde verde interior */
            /* background-color: rgba(46, 204, 113, 0.15) !important; */
            /* Fondo sutil */
            animation: pulse-ring 2s infinite;
        }

        @keyframes pulse-ring {
            0% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }

            50% {
                box-shadow: inset 0 0 0 1px #2ecc71;
            }

            100% {
                box-shadow: inset 0 0 0 3px #2ecc71;
            }
        }

        /* Feedback de disparo (Arma y V√≠ctimas) - VERSI√ìN INTENSA */
        .shot-highlight {
            /* Borde interior muy marcado y fondo te√±ido */
            box-shadow: inset 0 0 40px rgb(29, 4, 1) !important;
            /* background-color: rgba(231, 76, 60, 0) !important; */
            animation: pulse-shot 1.5s infinite;
            /* Pulso m√°s r√°pido (latido) */
            z-index: 5 !important;
            /* Asegura que se pinte sobre casillas de agua u otras */
        }

        @keyframes pulse-shot {
            0% {
                box-shadow: inset 0 0 40px rgba(27, 4, 2, 0.6);
                /* background-color: rgba(231, 76, 60, 0); */
            }

            50% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* Brillo m√°ximo */
                /* background-color: rgba(231, 76, 60, 0.1); */
            }

            100% {
                box-shadow: inset 0 0 60px rgb(29, 4, 1);
                /* box-shadow: inset 0 0 40px rgba(231, 76, 60, 0.6); */
                /* background-color: rgba(231, 76, 60, 0); */
            }
        }

        /* Feedback de disparo - ORIGEN (Dorado) */
        .shot-source {
            box-shadow: inset 0 0 40px rgba(241, 196, 15, 0.8) !important;
            /* Gold intenso */
            animation: pulse-shot-gold 1.5s infinite;
            z-index: 5 !important;
        }

        @keyframes pulse-shot-gold {
            0% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }

            50% {
                box-shadow: inset 0 0 50px rgba(241, 196, 15, 1);
            }

            100% {
                box-shadow: inset 0 0 20px rgba(241, 196, 15, 0.4);
            }
        }

        /* Secci√≥n Inferior: Mazmorra */
        .dungeon-section {
            height: 180px;
            /* Tama√±o fijo para la mazmorra */
            background-color: rgba(0, 0, 0, 0.4);
            box-shadow: inset 0 10px 20px rgba(0, 0, 0, 0.5);
            /* Efecto de profundidad */
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dungeon-label {
            font-size: 0.8em;
            text-align: center;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dungeon-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            align-content: flex-start;
            overflow-y: auto;
        }

        /* Estilo para las piezas dentro de la mazmorra */
        .dungeon-list img {
            width: 40px;
            height: 40px;
            margin: 2px;
            filter: grayscale(10%) opacity(0.7);
            /* Efecto "prisionero" */
            transition: all 0.3s ease;
        }

        .dungeon-list img:hover {
            filter: grayscale(0%) opacity(1);
            transform: scale(1.2);
            cursor: help;
        }

        /* Fichas rescatables: Borde brillante o cursor de mano */
        .rescue-target {
            cursor: pointer !important;
            /* box-shadow: 0 0 5px 2px var(--c-gold); */
            /* Brillo dorado de esperanza */
            filter: grayscale(0%) opacity(1) !important;
            /* Se ven vivas */
        }

        /* Items del Inventario (Sin recuadro, icono grande) */
        .inv-item {
            width: 70px;
            height: 70px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            /* Indicamos que se puede agarrar */
        }

        .inv-item img {
            width: 100%;
            height: 100%;
            /* La imagen ocupa todo el hueco */
            filter: drop-shadow(0 4px 5px rgba(0, 0, 0, 0.5));
            /* Sombra para que destaque sobre el fondo */
            transition: transform 0.1s;
        }

        .inv-item:active img {
            transform: scale(0.9);
            /* Peque√±o efecto al hacer clic */
        }

        /* El contador de unidades (Badge) */
        .inv-badge {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--c-gold);
            /* Color dorado para destacar */
            color: #1a252f;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 800;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        /* --- TABLERO --- */
        #board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            border: 15px solid #34495e;
            border-radius: 4px;
            background-color: #2c3e50;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        /* --- CASILLAS --- */
        .tile {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
            /* <--- Nivel base de apilamiento */
            overflow: visible;
            /* <--- Permite que las piezas sobresalgan sin cortarse */
        }

        .light {
            background-color: var(--c-board-l);
        }

        .dark {
            background-color: var(--c-board-d);
        }

        .water {
            background-color: var(--c-water) !important;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            /* Agua con m√°s profundidad */
        }

        /* PIEZAS CUANDO EST√ÅN EN EL TABLERO */
        .piece {
            width: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            height: 95%;
            /* Se ajusta al 90% de los 60px de la casilla */
            z-index: 100;
            /* <--- IMPORTANTE: Muy alto para estar siempre encima de las casillas */
            position: relative;
            /* Necesario para que el z-index funcione bien */
            cursor: grab;
            filter: drop-shadow(0 4px 4px rgba(0, 0, 0, 0.6));
            /* Sombra m√°s pronunciada para dar altura */
            pointer-events: auto;
            /* Asegura que reciba los eventos del rat√≥n */
        }

        .piece:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

        /* GHOSTING (Feedback Visual) */
        .ghost-valid {
            background-color: rgba(46, 204, 113, 0.6) !important;
            /* Verde */
            box-shadow: inset 0 0 0 2px #27ae60;
        }

        .ghost-invalid {
            background-color: rgba(231, 76, 60, 0.6) !important;
            /* Rojo */
            box-shadow: inset 0 0 0 2px #c0392b;
        }
    </style>
</head>

<body>

    <header>
        <h1 class="game-title">COTADREZ</h1>
        <div id="status-bar" class="status-bar">Elige tu ej√©rcito y sit√∫a en el tablero tu fortaleza</div>
    </header>

    <div class="main-container">
        <div class="panel" id="panel-rojo" style="border-color: var(--c-red);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-rojo"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-rojo"></div>
            </div>
        </div>

        <div id="board"></div>

        <div class="panel" id="panel-negro" style="border-color: var(--c-black);">
            <div class="inventory-section">
                <div class="inv-list" id="inv-negro"></div>
            </div>
            <div class="dungeon-section">
                <div class="dungeon-label">Mazmorra</div>
                <div class="dungeon-list" id="grave-negro"></div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIGURACI√ìN Y ESTADO ---
        const CONFIG = {
            repo: "https://cdn.jsdelivr.net/gh/mcuervo-web/Cotadrez@main",
            // Definici√≥n de cantidades y nombres de archivo
            pieces: {
                'fortaleza': { qty: 1, file: 'Castillo.svg' },
                'montana': { qty: 3, file: 'Montana.svg' },
                'rey': { qty: 1, file: 'Rey.svg' },
                'chusma': { qty: 3, file: 'Chusma.svg' },
                'lanceros': { qty: 3, file: 'Lanza.svg' },
                'arqueros': { qty: 3, file: 'Arco.svg' },
                'c_ligera': { qty: 3, file: 'CaballeriaL.svg' },
                'c_pesada': { qty: 2, file: 'CaballeriaP.svg' },
                'elefante': { qty: 2, file: 'Elefante.svg' },
                'escorpion': { qty: 1, file: 'Escorpion.svg' },
                'trabuquete': { qty: 1, file: 'Catapulta.svg' },
                'dragon': { qty: 1, file: 'Dragon.svg' }
            }
        };

        let reserves = { rojo: {}, negro: {} };
        // Matriz para las PIEZAS (Tropas) - Nombre nuevo para evitar errores
        let logicBoard = Array(10).fill().map(() => Array(10).fill(null));

        // Matriz para el TERRENO (Agua) - Esta ya la ten√≠as, d√©jala igual
        let terrain = Array(10).fill().map(() => Array(10).fill(null));

        let draggingMeta = null; // Guardar√° qu√© estamos moviendo

        let fortressPos = { rojo: null, negro: null };

        let chusmaMovedCoords = null; // Guardar√° {r, c} de la chusma que acaba de mover

        let shotHighlights = []; // Guardar√° las coordenadas {r,c} del √∫ltimo disparo para mantenerlas visibles

        let besiegedArmy = null; // Guardar√° 'rojo' o 'negro' durante la resoluci√≥n del asedio

        let isBesieged = false; // Nueva bandera para el estado de Asedio

        let currentThreatMap = null; // Mapa Defensivo (D√≥nde me atacan)

        let currentAttackMap = null; // NUEVO: Mapa Ofensivo (D√≥nde ataco yo)

        let isCheck = false; // Nueva bandera para el estado de Jaque

        // Almacena los prisioneros capturados POR cada jugador
        let dungeons = { rojo: [], negro: [] };

        // Estado del juego: 'init', 'deploy-p1', 'deploy-p2', 'playing'
        let gameState = 'init';
        let p1Color = null;
        let p2Color = null;
        let p1Territory = null; // 'north' (filas 0-4) o 'south' (filas 5-9)
        let turnColor = null; // 'rojo' o 'negro'

        function showNotification(msg, isError = false) {
            const bar = document.getElementById('status-bar');
            bar.innerText = msg;

            // Si es error, rojo est√°ndar. Si es info, dorado. 
            // PERO si estamos en CR√çTICO, mantenemos la clase parpadeante si no es un error moment√°neo.
            bar.classList.remove('status-critical'); // Quitamos parpadeo temporalmente para leer el mensaje
            bar.style.color = isError ? '#e74c3c' : '#f1c40f';

            bar.style.opacity = 0;
            setTimeout(() => bar.style.opacity = 1, 100);

            // Al terminar la notificaci√≥n, volvemos al estado real del juego
            setTimeout(() => {
                updateStatusBar(); // <--- ESTA ES LA CLAVE: Restaurar estado cr√≠tico si existe
                bar.style.opacity = 1; // Asegurar visibilidad
            }, 3000);
        }


        // --- 2. INICIALIZACI√ìN ---
        function init() {
            console.log("Inicializando sistema...");

            // 1. Llenar las reservas con las cantidades iniciales
            for (const [type, data] of Object.entries(CONFIG.pieces)) {
                reserves.rojo[type] = data.qty;
                reserves.negro[type] = data.qty;
            }

            // 2. Inicializar gr√°ficos
            initWater();
            renderBoard();
            updateInventories();
            updateDungeons();
            document.getElementById('status-bar').innerText = getStatusText();
        }
        function initWater() {
            const waterCoords = [[3, 1], [1, 3]]; // b4, d2
            waterCoords.forEach(([r, c]) => {
                terrain[r][c] = 'water'; terrain[r][9 - c] = 'water';
                terrain[9 - r][c] = 'water'; terrain[9 - r][9 - c] = 'water';
            });
        }

        // --- 3. RENDERIZADO B√ÅSICO ---

        function renderBoard() {
            const b = document.getElementById('board');
            b.innerHTML = '';

            // --- COLOR DEL BORDE SEG√öN TURNO ---
            let borderColor = '#34495e'; // Color neutro por defecto (Azul gris√°ceo oscuro)

            // Definimos el color oscuro manual para que destaque sobre el neutro
            const darkBorder = '#111111'; // <--- CORRECCI√ìN: Gris casi negro

            if (gameState === 'deploy-p1') {
                borderColor = (p1Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            else if (gameState === 'deploy-p2') {
                borderColor = (p2Color === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            // A√ëADIMOS: Confirmaci√≥n, Selecci√≥n de Prisionero y Bonus de Chusma
            else if (gameState === 'playing' ||
                gameState === 'siege-resolution' ||
                gameState === 'siege-confirmation' ||
                gameState === 'siege-prisoner-select' ||
                gameState === 'playing-chusma-bonus') {

                borderColor = (turnColor === 'rojo') ? 'var(--c-red)' : darkBorder;
            }
            b.style.borderColor = borderColor;
            // ------------------------------------------

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.r = r;
                    tile.dataset.c = c;

                    // --- NUEVO: PINTAR RASTRO DE DISPARO (Diferenciando Origen/Destino) ---
                    const shot = shotHighlights.find(h => h.r === r && h.c === c);
                    if (shot) {
                        if (shot.type === 'source') tile.classList.add('shot-source'); // Dorado
                        else tile.classList.add('shot-highlight'); // Oscuro
                    }

                    tile.ondragover = (e) => handleDragOver(e, r, c);
                    tile.ondrop = (e) => handleDrop(e, r, c);

                    if (terrain[r][c] === 'water') {
                        tile.classList.add('water');
                    }

                    // Pintar pieza
                    const piece = logicBoard[r][c];
                    let isVisible = true;

                    // Niebla de Guerra
                    if (piece && gameState === 'deploy-p2' && piece.army === p1Color) {
                        isVisible = false;
                    }

                    if (piece && isVisible) {
                        const img = document.createElement('img');
                        img.src = getImgUrl(piece.army, piece.type);
                        img.className = 'piece';

                        // --- NUEVO: PARPADEO Y CLICK DE FORTALEZA ASEDIADA ---
                        if (piece.type === 'fortaleza') {
                            const enemyArmy = (piece.army === 'rojo') ? 'negro' : 'rojo';

                            // Si soy la fortaleza enemiga y estoy en fase de confirmaci√≥n -> CLICKABLE
                            if (gameState === 'siege-confirmation' && piece.army !== turnColor) {
                                img.classList.add('siege-pulse');
                                img.onclick = () => executeConfirmedSiege(turnColor, piece.army);
                                img.title = "CLICK PARA EJECUTAR EL ASEDIO";
                            }
                            // Si simplemente hay amenaza (fase defensa), solo parpadeo visual
                            else if (isBesieged && piece.army === turnColor) {
                                img.classList.add('siege-pulse');
                            }
                        }


                        // --- GESTI√ìN DE ARRASTRE Y CLICKS ---
                        let canDrag = true;

                        // Bloqueos est√°ndar
                        if (piece.type === 'fortaleza') canDrag = false;
                        if (gameState.startsWith('playing') && piece.type === 'montana') canDrag = false; // startWith para pillar ambos estados
                        if (gameState.includes('deploy')) {
                            const myColor = (gameState === 'deploy-p1') ? p1Color : p2Color;
                            if (piece.army !== myColor) canDrag = false;
                        }

                        // L√ìGICA ESPECIAL: MEDIO TURNO DE CHUSMA
                        if (gameState === 'playing-chusma-bonus') {
                            // Si es la chusma que acabamos de mover -> NO DRAG, S√ç CLICK
                            if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                                canDrag = false;
                                img.style.cursor = "pointer"; // Dedo para hacer click
                                img.title = "Click para CEDER EL TURNO";
                                img.onclick = () => finishChusmaBonusTurn();
                                // Efecto visual para destacar que est√° esperando
                                img.style.filter = "drop-shadow(0 0 5px var(--c-gold)) brightness(1.2)";
                            }
                            // El resto de piezas no-chusma se bloquean en handleDragStart, 
                            // pero visualmente podemos quitarles el drag aqu√≠ si quieres pulirlo m√°s.
                        }

                        // Asignar draggable
                        img.draggable = canDrag;
                        if (canDrag) {
                            img.ondragstart = (e) => handleDragStart(e, 'board', piece.army, piece.type, r, c);
                            img.style.cursor = "grab";
                        } else if (!img.onclick) {
                            // Si no es arrastrable ni tiene onclick especial (como la chusma o fortaleza)
                            img.style.cursor = "default";
                        }

                        // --- GESTI√ìN DE CLICS DE FORTALEZAS (Mantenemos tu c√≥digo anterior aqu√≠) ---
                        if (piece.type === 'fortaleza') {
                            // ... (Tu c√≥digo de finishTurnP1 / P2 / Asedio sigue igual) ...
                            if (gameState === 'deploy-p1' && piece.army === p1Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP1();
                            } else if (gameState === 'deploy-p2' && piece.army === p2Color) {
                                img.style.cursor = "pointer"; img.onclick = () => finishTurnP2();
                            } else if (gameState.startsWith('playing') && piece.army !== turnColor) {
                                // ... (L√≥gica de asedio si la tienes implementada) ...
                            }
                        }

                        tile.appendChild(img);
                    }

                    b.appendChild(tile);
                }
            }
        }

        // Devuelve 'north' (filas 0-4) o 'south' (filas 5-9)
        function getTerritory(r) {
            return r < 5 ? 'north' : 'south';
        }



        // Verifica si una casilla est√° en el "Anillo de Salida" (per√≠metro adyacente)

        function isInExitZone(r, c, fOrigin) {
            if (!fOrigin) return false;

            // La fortaleza ocupa (fr, fc) hasta (fr+1, fc+1)
            // El anillo va desde (fr-1, fc-1) hasta (fr+2, fc+2)
            const minR = fOrigin.r - 1;
            const maxR = fOrigin.r + 2;
            const minC = fOrigin.c - 1;
            const maxC = fOrigin.c + 2;

            // 1. Debe estar dentro del rect√°ngulo exterior
            if (r >= minR && r <= maxR && c >= minC && c <= maxC) {
                // 2. Pero NO debe ser la propia fortaleza (el hueco central)
                if (r >= fOrigin.r && r <= fOrigin.r + 1 && c >= fOrigin.c && c <= fOrigin.c + 1) {
                    return false; // Es la propia estructura
                }
                return true; // Es el anillo
            }
            return false;
        }

        // Arrancar
        init();

        // Construye la URL de la imagen seg√∫n el bando y el tipo
        function getImgUrl(army, type) {
            const folder = army === 'rojo' ? 'Rojo' : 'Negro';
            const filename = CONFIG.pieces[type].file;
            return `${CONFIG.repo}/${folder}/${filename}`;
        }

        // Dibuja las piezas en los paneles laterales (Con efecto de desactivado)
        function updateInventories() {
            ['rojo', 'negro'].forEach(army => {
                const list = document.getElementById(`inv-${army}`);
                list.innerHTML = '';

                // --- 1. Determinar si este ej√©rcito est√° ACTIVO ---
                let isActive = true; // En 'init' ambos est√°n activos

                if (gameState === 'deploy-p1') {
                    isActive = (army === p1Color);
                } else if (gameState === 'deploy-p2') {
                    isActive = (army === p2Color);
                } else if (gameState === 'game-over') {
                    isActive = false; // Nadie mueve al final
                } else if (gameState !== 'init') {
                    // Para cualquier fase de juego (playing, siege, etc.)
                    isActive = (army === turnColor);
                }
                // --------------------------------------------------

                for (const [type, data] of Object.entries(CONFIG.pieces)) {
                    const count = reserves[army][type];

                    if (count > 0) {
                        const item = document.createElement('div');
                        item.className = 'inv-item';

                        const img = document.createElement('img');
                        img.src = getImgUrl(army, type);

                        // --- 2. Aplicar propiedades seg√∫n estado ---
                        if (isActive) {
                            img.draggable = true;
                            img.style.cursor = "grab";
                            img.style.filter = "none"; // Normal
                            img.style.opacity = "1";

                            img.ondragstart = (e) => handleDragStart(e, 'reserve', army, type);
                            img.ondragend = () => clearRingHighlights();
                        } else {
                            img.draggable = false;
                            img.style.cursor = "not-allowed"; // Icono de prohibido
                            // Efecto visual: Escala de grises y semitransparente
                            img.style.filter = "grayscale(100%)";
                            img.style.opacity = "0.3";
                        }
                        // -------------------------------------------

                        item.appendChild(img);

                        if (count > 1) {
                            const badge = document.createElement('div');
                            badge.className = 'inv-badge';
                            badge.innerText = count;

                            // Tambi√©n apagamos el badge visualmente si est√° inactivo
                            if (!isActive) badge.style.filter = "grayscale(100%)";

                            item.appendChild(badge);
                        }
                        list.appendChild(item);
                    }
                }
            });
        }

        // --- 4. L√ìGICA DE ARRASTRAR Y SOLTAR ---

        function handleDragStart(e, source, army, type, r = null, c = null) {

            // --- L√ìGICA DE JUEGO Y MEDIO TURNO ---
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus') {

                if (gameState === 'game-over') { e.preventDefault(); return; }

                if (gameState === 'siege-confirmation') {
                    if (army !== turnColor) { e.preventDefault(); return; }
                    // Solo permitimos mover si la pieza es parte del asedio (est√° en el anillo enemigo)
                    const enemyFort = fortressPos[(army === 'rojo') ? 'negro' : 'rojo'];
                    if (!isInExitZone(r, c, enemyFort)) {
                        showNotification("üîí Solo puedes mover las unidades que asedian la fortaleza.");
                        e.preventDefault();
                        return;
                    }
                }

                if (army !== turnColor) { e.preventDefault(); return; }

                // RESTRICCIONES DEL MEDIO TURNO (BONUS CHUSMA)
                if (gameState === 'playing-chusma-bonus') {
                    // 1. Solo se puede mover otra CHUSMA
                    if (type !== 'chusma') {
                        e.preventDefault(); return;
                    }
                    // 2. Solo piezas del TABLERO (Reserva bloqueada)
                    if (source !== 'board') {
                        e.preventDefault(); return;
                    }
                    // 3. NO se puede mover la misma unidad dos veces
                    if (chusmaMovedCoords && r === chusmaMovedCoords.r && c === chusmaMovedCoords.c) {
                        e.preventDefault(); return;
                    }
                }
            }

            // CALCULAR MAPAS DE INFLUENCIA
            const enemy = (army === 'rojo') ? 'negro' : 'rojo';

            currentThreatMap = getThreatMap(enemy); // Para que mi Rey no se suicide
            currentAttackMap = getThreatMap(army);  // Para coordinar ataques (Elefante)

            // 1. Guardamos metadatos (A√ëADIDO: coordenadas de origen)
            draggingMeta = {
                type: type,
                army: army,
                source: source,
                originR: r, // <--- NUEVO
                originC: c  // <--- NUEVO
            };

            // 2. Datos est√°ndar para el Drop
            const data = { source, army, type, originR: r, originC: c };
            e.dataTransfer.setData('text/plain', JSON.stringify(data));
            e.dataTransfer.effectAllowed = 'move';

            // --- NUEVO: RESALTAR ANILLO SI VIENE DE RESERVA ---
            // (La l√≥gica est√° DENTRO de la funci√≥n, antes de la llave de cierre)
            if (source === 'reserve' && type !== 'montana') {
                highlightFortressRing(army);
            }
        }

        // 2. Permitir soltar (El navegador bloquea por defecto, hay que prevenirlo)
        // Funci√≥n auxiliar para limpiar fantasmas previos
        function clearGhosts() {
            document.querySelectorAll('.ghost-valid, .ghost-invalid').forEach(el => {
                el.classList.remove('ghost-valid', 'ghost-invalid');
            });
        }

        // Nueva funci√≥n DragOver con l√≥gica de visualizaci√≥n

        function handleDragOver(e, r, c) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (!draggingMeta) return;
            clearGhosts();

            // --- NUEVO: L√ìGICA ESPEC√çFICA PARA FASE DE JUEGO (Y CONFIRMACI√ìN) ---
            if (gameState === 'playing' || gameState === 'siege-confirmation') {
                let isValid = true;
                const target = logicBoard[r][c];
                const type = draggingMeta.type;
                const army = draggingMeta.army;
                const source = draggingMeta.source; // <--- Usamos el dato nuevo

                // 1. RESTRICCIONES DE TERRENO GENERALES
                if (terrain[r][c] === 'water') isValid = false;
                if (target && target.type === 'fortaleza') isValid = false;
                if (target && target.type === 'montana') isValid = false;

                // 2. LOGICA DIFERENCIADA: ¬øREFUERZO O MOVIMIENTO?
                if (source === 'reserve') {
                    // --- REFUERZO ---
                    // A. Debe ser en el anillo de mi fortaleza
                    const fOrigin = fortressPos[army];
                    if (!isInExitZone(r, c, fOrigin)) isValid = false;

                    // B. La casilla debe estar VAC√çA (no puedes reforzar encima de nadie)
                    if (target !== null) isValid = false;

                } else {
                    // --- MOVIMIENTO NORMAL (TABLERO -> TABLERO) ---

                    // 1. Validar Geometr√≠a (Usa la nueva funci√≥n)
                    // Usamos las coordenadas guardadas en draggingMeta
                    if (!isValidMove(type, draggingMeta.originR, draggingMeta.originC, r, c)) {
                        isValid = false;
                    }

                    // 2. Validar Ocupaci√≥n (Solo si la geometr√≠a es v√°lida)
                    if (isValid && target) {
                        if (target.army === army) {
                            if (type !== 'lanceros') isValid = false;
                        }
                        // Enemigo = Captura (V√°lido)
                    }
                }
                // Pintar
                const className = isValid ? 'ghost-valid' : 'ghost-invalid';
                const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                if (tile) tile.classList.add(className);

                return;
            }

            // FASE DE DESPLIEGUE DE TROPAS
            // 1. DEFINICI√ìN DE VARIABLES
            let isValid = true;
            const army = draggingMeta.army;
            const type = draggingMeta.type;
            const isFortress = (type === 'fortaleza');
            const isMountain = (type === 'montana');

            // Buscar posici√≥n de fortaleza
            const fOrigin = fortressPos[army];
            const hasFortress = fOrigin !== null;

            // 2. DEFINIR LAS CELDAS AFECTADAS (Variable 'cells')
            let cells = [];
            if (isFortress) {
                // Verificar l√≠mites del mapa para 2x2
                if (r + 1 > 9 || c + 1 > 9) {
                    // Si se sale, marcamos la casilla actual como error visual y paramos
                    const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                    if (tile) tile.classList.add('ghost-invalid');
                    return;
                }
                cells.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
            } else {
                // Unidad normal: 1x1
                cells.push({ r: r, c: c });
            }

            // --- VALIDACI√ìN DE REGLAS ---

            // A. REGLA: FORTALEZA PRIMERO
            // Si no hay fortaleza puesta y no estoy arrastrando una... ERROR
            if (!isFortress && !hasFortress) {
                isValid = false;
            }

            // B. REGLA: TERRITORIOS (ANTI-SONAR)
            if (p1Territory) {
                const rowTerritory = getTerritory(r);
                // Si soy J1 -> Mi zona. Si soy J2 -> La contraria.
                const myZone = (army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');

                if (rowTerritory !== myZone) {
                    isValid = false;
                }
            }

            // C. REGLA: ANILLO DE SALIDA (Solo si ya hay fortaleza y no es la propia fortaleza)
            if (!isFortress && !isMountain && hasFortress) {
                // Si isValid ya es false (por territorio), no importa, pero si es true verificamos el anillo
                if (isValid && !isInExitZone(r, c, fOrigin)) {
                    isValid = false;
                }
            }

            // D. REGLA: ZONA PROHIBIDA DE FORTALEZA (Bordes y Centro)
            if (isFortress) {
                const invalidRows = [0, 4, 5, 9];
                const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1)) isValid = false;
                if (invalidCols.includes(c) || invalidCols.includes(c + 1)) isValid = false;
            }

            // E. REGLA: AGUA Y OCUPACI√ìN
            for (let cell of cells) {
                // Agua (salvo fortaleza)
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) isValid = false;
                // Ocupado
                if (logicBoard[cell.r][cell.c] !== null) isValid = false;
            }

            // 3. PINTAR EL RESULTADO
            const className = isValid ? 'ghost-valid' : 'ghost-invalid';
            cells.forEach(cell => {
                const tile = document.querySelector(`.tile[data-r="${cell.r}"][data-c="${cell.c}"]`);
                if (tile) tile.classList.add(className);
            });
        }
        // 3. Al soltar en una casilla

        function handleDrop(e, r, c) {
            e.preventDefault();
            clearRingHighlights();
            clearGhosts();

            const rawData = e.dataTransfer.getData('text/plain');
            if (!rawData) return;
            const data = JSON.parse(rawData);
            draggingMeta = null;

            // ============================================================
            //  FASE ESPECIAL: RESOLUCI√ìN DE ASEDIO (SACRIFICIO)
            // ============================================================
            if (gameState === 'siege-resolution') {
                if (data.army !== besiegedArmy) return;
                if (data.source !== 'reserve') {
                    showNotification("‚ö†Ô∏è Debes sacar una pieza de la RESERVA para romper el asedio.", true); return;
                }

                const fOrigin = fortressPos[data.army];
                if (!isInExitZone(r, c, fOrigin)) {
                    showNotification("üö´ Solo puedes desplegar junto a tu Fortaleza.", true); return;
                }
                if (logicBoard[r][c] !== null || terrain[r][c] === 'water') {
                    showNotification("üö´ Casilla inv√°lida u ocupada.", true); return;
                }

                // Regla de supervivencia del Rey
                const myReserve = reserves[data.army];
                const kingInReserve = myReserve['rey'] > 0;
                if (kingInReserve && data.type !== 'rey') {
                    showNotification("üëë ¬°El Rey est√° en peligro! Debes salvar al REY obligatoriamente.", true);
                    return;
                }

                // --- NUEVO: VALIDAR QUE EL REY NO SALGA A UNA CASILLA AMENAZADA ---
                if (data.type === 'rey') {
                    // currentThreatMap ya se calcul√≥ en handleDragStart
                    if (currentThreatMap && currentThreatMap[r][c] > 0) {
                        showNotification("‚õî ¬°Zona mortal! El Rey no puede salir a una casilla amenazada.", true);
                        return;
                    }
                }

                // A. Salvar la pieza elegida
                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    logicBoard[r][c] = { army: data.army, type: data.type };
                }

                // B. Captura masiva del resto
                const attackerArmy = (besiegedArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[data.army])) {
                    if (type === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) {
                            dungeons[attackerArmy].push({ type: type, army: besiegedArmy });
                            capturedCount++;
                        }
                        reserves[data.army][type] = 0;
                    }
                }

                showNotification(`üî• Asedio roto. ${capturedCount} unidades capturadas.`);
                gameState = 'playing';
                besiegedArmy = null;
                turnColor = attackerArmy;

                renderBoard();
                updateInventories();
                updateDungeons();

                checkTurnStatus();

                return;
            }

            // ============================================================
            //  FASE 1: MODO JUEGO (NORMAL Y BONUS)
            // ============================================================
            if (gameState === 'playing' || gameState === 'playing-chusma-bonus' || gameState === 'siege-confirmation') {
                // --- A. REFUERZOS ---
                if (data.source === 'reserve') {
                    const fOrigin = fortressPos[data.army];
                    if (!isInExitZone(r, c, fOrigin)) {
                        showNotification("‚õî Los refuerzos solo pueden entrar junto a tu Fortaleza."); return;
                    }
                    if (terrain[r][c] === 'water') { showNotification("‚õî No puedes desplegar en el agua."); return; }
                    if (logicBoard[r][c] !== null) { showNotification("‚õî La zona de despliegue est√° ocupada."); return; }

                    if (reserves[data.army][data.type] > 0) {
                        reserves[data.army][data.type]--;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        showNotification(`üÜï Refuerzos: ${data.type.toUpperCase()} entra en batalla.`);
                    } else {
                        return;
                    }
                }

                // --- B. MOVIMIENTO Y COMBATE (TABLERO A TABLERO) ---
                else if (data.source === 'board') {
                    // Limpiamos rastros anteriores al iniciar una nueva acci√≥n
                    shotHighlights = [];

                    const target = logicBoard[r][c];

                    // 1. Validaciones de terreno globales
                    if (terrain[r][c] === 'water' && data.type !== 'trabuquete' && data.type !== 'escorpion') {
                        // Nota: Armas pueden disparar SOBRE agua, pero validamos destino despu√©s
                        showNotification("‚õî No puedes moverte al agua."); return;
                    }
                    // Validamos agua para movimiento (destino vac√≠o) de armas
                    if (target === null && terrain[r][c] === 'water') { showNotification("‚õî No puedes moverte al agua."); return; }

                    if (target && target.type === 'montana') { showNotification("‚õî No puedes atravesar monta√±as."); return; }
                    if (target && target.type === 'fortaleza') { showNotification("‚õî No puedes ocupar una fortaleza."); return; }

                    // --- NUEVO: AVISO ESPEC√çFICO DE ELEFANTE ---
                    // Si intentamos capturar un elefante sin ser drag√≥n y sin apoyo...
                    if (target && target.type === 'elefante' && target.army !== data.army && data.type !== 'dragon') {
                        // Usamos el mapa calculado al inicio del arrastre
                        if (!currentAttackMap || currentAttackMap[r][c] < 2) {
                            showNotification("üêò ¬°IMPOSIBLE! Necesitas apoyo (2+ unidades) o un Drag√≥n para cazar al Elefante.");
                            return; // Cortamos aqu√≠ para que no salga el error gen√©rico
                        }
                    }

                    // 2. Validaci√≥n Geom√©trica
                    if (!isValidMove(data.type, data.originR, data.originC, r, c)) {
                        showNotification("‚õî Movimiento o Disparo ilegal"); return;
                    }

                    let wasCapture = false;

                    if (target) {
                        // --- INTERACCI√ìN CON OTRAS PIEZAS ---
                        if (target.army === data.army) {
                            // Aliado -> Solo Lanceros
                            if (data.type === 'lanceros') {
                                logicBoard[data.originR][data.originC] = target;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("üîÑ ¬°Maniobra de Lancero!");
                            } else {
                                showNotification("‚õî Casilla ocupada por aliado."); return;
                            }
                        } else {
                            // --- ENEMIGO (CAPTURA / DISPARO) ---
                            wasCapture = true;

                            // A. L√ìGICA DE DISPARO (Trabuquete y Escorpi√≥n)
                            // Si son estas armas y atacan, NO SE MUEVEN.
                            if (data.type === 'trabuquete' || data.type === 'escorpion') {

                                // 1. Registrar coordenadas con TIPO
                                shotHighlights.push({ r: data.originR, c: data.originC, type: 'source' }); // Arma (Dorado)
                                shotHighlights.push({ r: r, c: c, type: 'target' }); // V√≠ctima (Oscuro)

                                // 2. Caso Especial ESCORPI√ìN (Doble Kill)
                                if (data.type === 'escorpion') {
                                    // Recorremos el camino para ver si perforamos a alguien
                                    const sR = Math.sign(r - data.originR);
                                    const sC = Math.sign(c - data.originC);
                                    let cR = data.originR + sR, cC = data.originC + sC;

                                    while (cR !== r || cC !== c) {
                                        const obs = logicBoard[cR][cC];
                                        if (obs && obs.army !== data.army) {
                                            // ¬°Enemigo intermedio perforado!
                                            dungeons[data.army].push({ type: obs.type, army: obs.army });
                                            logicBoard[cR][cC] = null; // Eliminar del tablero
                                            shotHighlights.push({ r: cR, c: cC, type: 'target' }); // V√≠ctima intermedia (Oscuro)
                                        }
                                        cR += sR; cC += sC;
                                    }
                                }

                                // 3. Capturar Objetivo Principal
                                if (target.type === 'rey') {
                                    gameState = 'game-over';
                                    // Visualmente eliminamos al rey pero dejamos el arma en su sitio
                                    logicBoard[r][c] = null;
                                    renderBoard();

                                    const winner = data.army === 'rojo' ? 'ROJO' : 'NEGRO';
                                    const bar = document.getElementById('status-bar');
                                    bar.innerText = `üëë ¬°JAQUE MATE! EL TRABUQUETE/ESCORPI√ìN HA ELIMINADO AL REY. VICTORIA ${winner}`;
                                    bar.style.color = '#2ecc71';
                                    return;
                                }

                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[r][c] = null; // La casilla destino queda vac√≠a (muerto)
                                // NO movemos el arma (logicBoard[origin] no se toca)

                                showNotification("üî• ¬°DISPARO DE ASEDIO! Objetivo eliminado.");

                            } else {
                                // --- CAPTURA CUERPO A CUERPO (Est√°ndar) ---
                                // Jaque Mate normal
                                if (target.type === 'rey') {
                                    gameState = 'game-over';
                                    logicBoard[data.originR][data.originC] = null;
                                    logicBoard[r][c] = { army: data.army, type: data.type };
                                    renderBoard();
                                    const winner = data.army === 'rojo' ? 'ROJO' : 'NEGRO';
                                    const bar = document.getElementById('status-bar');
                                    bar.innerText = `üëë ¬°JAQUE MATE! VICTORIA DEL EJ√âRCITO ${winner}`;
                                    bar.style.color = '#2ecc71';
                                    return;
                                }

                                dungeons[data.army].push({ type: target.type, army: target.army });
                                logicBoard[data.originR][data.originC] = null;
                                logicBoard[r][c] = { army: data.army, type: data.type };
                                showNotification("‚öîÔ∏è ¬°CAPTURA! Prisionero a la mazmorra.");
                            }
                        }
                    } else {
                        // --- MOVIMIENTO A CASILLA VAC√çA ---
                        logicBoard[data.originR][data.originC] = null;
                        logicBoard[r][c] = { army: data.army, type: data.type };
                        wasCapture = false;
                    }

                    // --- C. BONUS CHUSMA ---
                    // A√±adimos "&& gameState !== 'siege-confirmation'" para evitar que salte al recolocar el asedio
                    if (gameState === 'playing' && data.type === 'chusma' && !wasCapture && gameState !== 'siege-confirmation') {
                        gameState = 'playing-chusma-bonus';
                        chusmaMovedCoords = { r: r, c: c };
                        showNotification("‚ö° ¬°Marcha ligera! Mueve otra Chusma o haz click en esta para terminar.");
                        renderBoard(); updateInventories(); updateDungeons();
                        checkTurnStatus();
                        return;
                    }
                }

                // --- C. FINAL DEL TURNO Y VERIFICACI√ìN DE ASEDIO ---

                // Si estamos en FASE DE CONFIRMACI√ìN (Atacante movi√≥ pieza) -> Volver a Defensa
                if (gameState === 'siege-confirmation') {
                    // Si moviste, cancelas la ejecuci√≥n inmediata y pasas el turno al defensor
                    const defender = (data.army === 'rojo') ? 'negro' : 'rojo';
                    turnColor = defender;
                    gameState = 'playing';

                    // 1. PRIMERO: Calculamos el nuevo estado (¬øSe rompi√≥ el asedio o solo se movi√≥?)
                    checkTurnStatus();

                    // 2. SEGUNDO: Pintamos (Ahora renderBoard sabr√° si isBesieged es false y quitar√° el parpadeo)
                    renderBoard(); updateInventories(); updateDungeons();

                    // 3. TERCERO: Notificamos (Al ir al final, este mensaje tiene prioridad sobre la alerta roja)
                    if (isBesieged) {
                        showNotification("üîÑ Asedio reposicionado. Turno de defensa.");
                    } else {
                        showNotification("üè≥Ô∏è Asedio cancelado. El defensor respira.");
                    }

                    return;
                }

                // Si estamos en JUEGO NORMAL (Defensor intent√≥ salvarse)
                const defenderArmy = data.army;
                const attackerArmy = (defenderArmy === 'rojo') ? 'negro' : 'rojo';
                const myFort = fortressPos[defenderArmy];

                if (myFort) {
                    let enemiesAtGate = 0;
                    for (let rx = 0; rx < 10; rx++) {
                        for (let cx = 0; cx < 10; cx++) {
                            if (isInExitZone(rx, cx, myFort)) {
                                const u = logicBoard[rx][cx];
                                if (u && u.army === attackerArmy) enemiesAtGate++;
                            }
                        }
                    }

                    // SI LA DEFENSA FALLA (Sigue habiendo 2+ enemigos)
                    if (enemiesAtGate >= 2) {
                        // NUEVO: NO EJECUTAMOS TODAV√çA. PASAMOS A FASE DE CONFIRMACI√ìN.
                        gameState = 'siege-confirmation';
                        turnColor = attackerArmy; // El turno vuelve al atacante

                        isBesieged = false;

                        showNotification(`‚öîÔ∏è ASEDIO LISTO: Pulsa la Fortaleza enemiga para ejecutar o mueve una pieza para cancelar.`);
                        renderBoard(); updateInventories(); updateDungeons();
                        return;
                    }
                }

                // 3. SI NO HAY ASEDIO (O SE ROMPI√ì) -> CAMBIO DE TURNO NORMAL
                turnColor = attackerArmy;
                gameState = 'playing';
                chusmaMovedCoords = null;
                showNotification(`Turno ${getArmyName(turnColor)}`);

                // CAMBIO DE ORDEN: Primero calculamos el estado (para saber si hay que parpadear)
                checkTurnStatus();

                // Y luego pintamos (as√≠ el render ya sabe si isBesieged es true)
                renderBoard();
                updateInventories();
                updateDungeons();

                return;
            }

            // ============================================================
            //  FASE 2: MODO DESPLIEGUE (SETUP)
            // ============================================================
            // ... (Tu c√≥digo de despliegue original sigue aqu√≠, no hace falta tocarlo si ya funciona)
            // Simplemente copia y pega tu bloque original de despliegue aqu√≠ debajo si lo borraste.
            // Para ahorrar espacio, asumo que mantienes el bloque 'else if (gameState.includes("deploy"))' o similar
            // Si en tu c√≥digo estaba todo junto en handleDrop, aseg√∫rate de mantener la parte de abajo.

            // Como tu handleDrop original ten√≠a la parte de despliegue al final sin 'else', 
            // aseg√∫rate de que este bloque de abajo est√© presente:

            const isFortress = (data.type === 'fortaleza');
            const isMountain = (data.type === 'montana');
            const fOrigin = fortressPos[data.army];
            const hasFortress = fOrigin !== null;

            // ... (Resto de tu l√≥gica de despliegue tal cual la ten√≠as en Cotadrez3.2.html l√≠neas 733 en adelante) ...

            // IMPORTANTE: Dado que he cortado aqu√≠ para no hacer el mensaje eterno, 
            // ASEG√öRATE de copiar la parte de DESPLIEGUE que ten√≠as en tu archivo original 
            // justo despu√©s del bloque 'if (gameState === 'playing' ... ) { ... }' que acabamos de cerrar.
            // O usa la versi√≥n completa que te paso a continuaci√≥n para evitar l√≠os.

            // -- BLOQUE DE DESPLIEGUE RESUMIDO PARA QUE COPIES Y PEGUES TODO SI QUIERES --
            // Validaciones
            if (!isFortress && !hasFortress) { showNotification("üö´ Primero debes construir la FORTALEZA", true); return; }

            if (p1Territory) {
                const currentZone = getTerritory(r);
                const myZone = (data.army === p1Color) ? p1Territory : (p1Territory === 'north' ? 'south' : 'north');
                if (currentZone !== myZone) { showNotification("üö´ Zona Prohibida.", true); return; }
            }

            if (!isFortress && !isMountain && hasFortress) {
                if (!isInExitZone(r, c, fOrigin)) { showNotification("üõ°Ô∏è Despliega junto a la Fortaleza", true); return; }
            }

            let cellsToCheck = [];
            if (isFortress) {
                if (r + 1 > 9 || c + 1 > 9) { showNotification("¬°No cabe aqu√≠!", true); return; }
                cellsToCheck.push({ r: r, c: c }, { r: r, c: c + 1 }, { r: r + 1, c: c }, { r: r + 1, c: c + 1 });
                const invalidRows = [0, 4, 5, 9]; const invalidCols = [0, 9];
                if (invalidRows.includes(r) || invalidRows.includes(r + 1) || invalidCols.includes(c) || invalidCols.includes(c + 1)) {
                    showNotification("üè∞ Posici√≥n inv√°lida", true); return;
                }
            } else {
                cellsToCheck.push({ r: r, c: c });
            }

            for (let cell of cellsToCheck) {
                if (terrain[cell.r][cell.c] === 'water' && !isFortress) { showNotification("üåä ¬°Al agua no!", true); return; }
                if (logicBoard[cell.r][cell.c] !== null) { showNotification("‚õî Casilla ocupada", true); return; }
            }

            if (data.source === 'reserve') {
                if (gameState === 'init') {
                    if (!isFortress) { showNotification("‚ö†Ô∏è Primero la FORTALEZA.", true); return; }
                    p1Color = data.army;
                    p2Color = (p1Color === 'rojo') ? 'negro' : 'rojo';
                    p1Territory = getTerritory(r);
                    gameState = 'deploy-p1';
                }
                if (gameState === 'deploy-p1' && data.army !== p1Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 1", true); return; }
                if (gameState === 'deploy-p2' && data.army !== p2Color) { showNotification("‚ö†Ô∏è Turno del JUGADOR 2", true); return; }

                if (reserves[data.army][data.type] > 0) {
                    reserves[data.army][data.type]--;
                    cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });

                    if (isFortress) {
                        fortressPos[data.army] = { r: r, c: c };
                        if (gameState === 'deploy-p1') showNotification(`J1: ${p1Color.toUpperCase()} controla el ${p1Territory.toUpperCase()}.`);
                        else showNotification("üè∞ Fortaleza establecida.");
                    } else {
                        showNotification(`Desplegado: ${data.type.toUpperCase()}`);
                    }
                }
            } else if (data.source === 'board') {
                logicBoard[data.originR][data.originC] = null;
                cellsToCheck.forEach(cell => logicBoard[cell.r][cell.c] = { army: data.army, type: data.type });
                if (isFortress) fortressPos[data.army] = { r: r, c: c };
                showNotification("Unidad reubicada");
            }

            renderBoard();
            updateInventories();
        }


        function updateDungeons() {
            ['rojo', 'negro'].forEach(jailerArmy => {
                const container = document.getElementById(`grave-${jailerArmy}`);
                if (!container) return;
                container.innerHTML = '';

                // Conjunto para recordar qu√© tipos de piezas ya hemos pintado en esta vuelta
                const drawnTypes = new Set();

                dungeons[jailerArmy].forEach((captive, index) => {
                    // Si ya hemos dibujado una pieza de este tipo, la saltamos (agrupaci√≥n visual)
                    if (drawnTypes.has(captive.type)) return;

                    // Si es nueva, la registramos y la dibujamos
                    drawnTypes.add(captive.type);

                    const img = document.createElement('img');
                    img.src = getImgUrl(captive.army, captive.type);
                    img.title = `Prisionero: ${captive.type.toUpperCase()}`;

                    // L√ìGICA DE RESCATE
                    // Permitimos click si estamos jugando o si estamos en la fase de selecci√≥n obligatoria
                    const isRescueState = (gameState === 'playing' || gameState === 'siege-prisoner-select');

                    if (isRescueState && captive.army === turnColor && jailerArmy !== turnColor) {
                        img.classList.add('rescue-target');
                        img.onclick = () => selectPrisonerToRescue(jailerArmy, index);
                        img.title = "CLICK PARA RESCATAR Y EJECUTAR ASEDIO";
                    }

                    container.appendChild(img);
                });
            });
        }

        function finishTurnP1() {

            if (reserves[p1Color]['montana'] > 0) {
                showNotification("‚ö†Ô∏è Debes colocar todas las MONTA√ëAS en el mapa antes de terminar.", true);
                return;
            }

            // Acci√≥n directa, sin preguntas
            gameState = 'deploy-p2';

            // Feedback visual en la barra de notificaciones
            showNotification(`‚úÖ Despliegue J1 Finalizado. Turno del JUGADOR 2 (${p2Color.toUpperCase()}).`);

            // Repintar (se aplicar√° la niebla autom√°ticamente)
            renderBoard();
            updateInventories();
        }


        function finishTurnP2() {

            if (reserves[p2Color]['montana'] > 0) {
                showNotification("‚ö†Ô∏è Debes colocar todas las MONTA√ëAS en el mapa antes de empezar.", true);
                return;
            }

            // Acci√≥n directa
            gameState = 'playing';
            turnColor = p1Color;

            // Feedback visual
            showNotification(`¬°COMIENZA LA PARTIDA! Turno de ${turnColor.toUpperCase()}`);

            // Repintar (se quita la niebla)
            renderBoard();
            updateInventories();

            // --- NUEVO: Verificar si empezamos ya en Jaque ---
            checkTurnStatus();
        }

        function attemptRescue(jailerArmy, captiveIndex, captive) {
            // 1. Identificar al enemigo y su fortaleza
            const myArmy = turnColor;
            const enemyFortPos = fortressPos[jailerArmy];

            if (!enemyFortPos) return;

            // 2. Buscar "El Equipo de Rescate"
            let rescueTeam = [];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === myArmy) {
                        if (isInExitZone(r, c, enemyFortPos)) {
                            rescueTeam.push({ r, c, type: piece.type });
                        }
                    }
                }
            }

            // 3. REGLA: ¬øHay equipo de rescate?
            if (rescueTeam.length < 2) {
                showNotification("‚õî Necesitas m√°s tropas rodeando la Fortaleza Enemiga para rescatar.", true);
                return;
            }

            // 4. EJECUTAR EL RESCATE (Todo vuelve a la reserva)
            // A. Recuperar al prisionero
            dungeons[jailerArmy].splice(captiveIndex, 1);
            reserves[myArmy][captive.type]++;

            // B. Retirar al equipo de rescate 
            rescueTeam.forEach(soldier => {
                logicBoard[soldier.r][soldier.c] = null;
                reserves[myArmy][soldier.type]++;
            });

            // 5. VERIFICAR RESERVAS DEL ENEMIGO (SOLUCI√ìN AL BLOQUEO)
            let enemyReserveCount = 0;
            for (const key in reserves[jailerArmy]) {
                enemyReserveCount += reserves[jailerArmy][key];
            }

            if (enemyReserveCount > 0) {
                // --- CASO A: EL ENEMIGO TIENE RESERVAS (ASEDIO NORMAL) ---
                const msg = `üöÅ ¬°RESCATE √âPICO!`;
                showNotification(msg); // Mensaje corto para que no solape

                gameState = 'siege-resolution';
                besiegedArmy = jailerArmy;
                turnColor = besiegedArmy; // Turno para el defensor

                updateStatusBar(); // Poner la barra en rojo
            } else {
                // --- CASO B: EL ENEMIGO NO TIENE RESERVAS (SALTAR FASE) ---
                // Como no tiene nada en la reserva, no puede "salvar" nada, 
                // pero tampoco le "matamos" nada extra porque no tiene.
                // Simplemente recuperas tus tropas y sigue tu turno (o pasa al siguiente).

                showNotification(`üöÅ ¬°RESCATE √âPICO! La fortaleza enemiga estaba vac√≠a.`);

                // El turno se mantiene en el atacante (o pasa al siguiente, seg√∫n prefieras).
                // Normalmente tras un asedio resuelto, le tocar√≠a al atacante mover con sus nuevas tropas
                // o pasamos turno. En la l√≥gica actual de 'handleDrop', tras romper asedio, turnColor = attacker.
                // Aqu√≠ ya somos el attacker.

                // Opci√≥n: Mantenemos el juego fluyendo
                gameState = 'playing';
                // turnColor sigue siendo myArmy

                checkTurnStatus(); // Actualizar amenazas tras sacar piezas del tablero
            }

            renderBoard();
            updateInventories();
            updateDungeons();
        }

        function getStatusText() {
            if (gameState === 'game-over') return document.getElementById('status-bar').innerText;

            const currentArmy = getArmyName(turnColor);

            // 0. NUEVO: SELECCI√ìN DE PRISIONERO
            if (gameState === 'siege-prisoner-select') {
                return `üîì DEFENSA FALLIDA: ${currentArmy}, ¬°LIBERA A UN PRISIONERO!`;
            }

            if (gameState === 'siege-confirmation') {
                return `üéØ ASEDIO LISTO: ${currentArmy}, PULSA LA FORTALEZA PARA EJECUTAR O MUEVE PARA REPOSICIONAR.`;
            }

            // 1. ASEDIO ACTIVO (Resoluci√≥n)
            if (gameState === 'siege-resolution') {
                return `üî• ¬°ASEDIO TOTAL! EL EJ√âRCITO ${currentArmy} DEBE SALVAR UNA PIEZA (EL RESTO MORIR√Å).`;
            }

            // 2. JAQUE
            if (isCheck) {
                return `‚ö†Ô∏è ¬°JAQUE AL REY ${currentArmy}! DEBES PROTEGERLO. ‚ö†Ô∏è`;
            }

            // 3. ASEDIO INMINENTE (Fortaleza rodeada) <--- ESTO FALTABA
            if (isBesieged) {
                return `üõ°Ô∏è ¬°ALERTA DE ASEDIO! LA FORTALEZA ${currentArmy} EST√Å RODEADA. ROMPE EL CERCO O PERDER√ÅS TROPAS.`;
            }

            // 4. BONUS CHUSMA
            if (gameState === 'playing-chusma-bonus') {
                return `‚ö° BONIFICACI√ìN CHUSMA: Mueve otra unidad de Chusma o finaliza el turno.`;
            }

            // 5. EST√ÅNDAR
            if (gameState === 'init') return "Elige tu destino: Arrastra una Fortaleza para empezar.";
            if (gameState.includes('deploy')) return `Fase Despliegue: ${(gameState === 'deploy-p1' ? p1Color : p2Color).toUpperCase()}`;

            return `Turno ${currentArmy}`;
        }

        // Pinta el anillo de salida de la fortaleza del ej√©rcito indicado
        function highlightFortressRing(army) {
            const fPos = fortressPos[army];
            if (!fPos) return;

            // Recorremos todo el tablero (ineficiente pero seguro y r√°pido en 10x10)
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    // Si es zona de salida, est√° vac√≠a y no es agua
                    if (isInExitZone(r, c, fPos)) {
                        if (logicBoard[r][c] === null && terrain[r][c] !== 'water') {
                            const tile = document.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`);
                            if (tile) tile.classList.add('highlight-ring');
                        }
                    }
                }
            }
        }

        // Limpia el resaltado del anillo
        function clearRingHighlights() {
            document.querySelectorAll('.highlight-ring').forEach(el => {
                el.classList.remove('highlight-ring');
            });
        }

        // Valida SOLO la geometr√≠a del movimiento (Tablero -> Tablero)

        // Valida SOLO la geometr√≠a y el camino del movimiento
        function isValidMove(type, r1, c1, r2, c2) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // --- 0. REGLA ESPECIAL: CAPTURA DE ELEFANTES ---
            const myPiece = logicBoard[r1][c1];
            const target = logicBoard[r2][c2];

            if (myPiece && target && target.type === 'elefante' && target.army !== myPiece.army) {
                // A. El Drag√≥n es el depredador natural (Captura directa)
                if (type === 'dragon') {
                    // Pasa sin restricciones, permitimos que valide la geometr√≠a abajo
                }
                // B. El resto necesita "Caza en Grupo" (Al menos 2 unidades amenazando)
                else {
                    // Si no hay mapa o no hay suficientes atacantes...
                    if (!currentAttackMap || currentAttackMap[r2][c2] < 2) {
                        // ¬°AVISO AL JUGADOR!
                        /* showNotification("üêò ¬°IMPOSIBLE! Necesitas apoyo (2+ unidades) o un Drag√≥n para cazar al Elefante."); */
                        return false;
                    }
                }
            }

            // --- 1. REY (1 casilla alrededor) ---
            if (type === 'rey') {
                // NUEVO: No puede moverse a una casilla amenazada (Suicidio)
                // currentThreatMap se calcula en handleDragStart
                if (currentThreatMap && currentThreatMap[r2][c2] > 0) {
                    return false;
                }
                return (dR <= 1 && dC <= 1) && (dR + dC > 0);
            }
            // --- 2. LANCEROS / CHUSMA ---
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            // --- 3. DRAG√ìN ---
            if (type === 'dragon') {
                if (!((dR === dC) || (r1 === r2 || c1 === c2))) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const obs = logicBoard[cR][cC];
                    if (obs && obs.type !== 'montana') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 4. ARQUEROS ---
            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    if (logicBoard[r2][c2] === null) return false; // Solo salta para matar
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    return (logicBoard[midR][midC] === null && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // --- 5. ELEFANTE ---
            if (type === 'elefante') {
                if (r1 !== r2 && c1 !== c2) return false;
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    if (logicBoard[cR][cC] !== null || terrain[cR][cC] === 'water') return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 6. CABALLER√çA LIGERA ---
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };
                // Ruta A (Corto+Giro)
                const shorts = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [sr, sc] of shorts) {
                    const cr = r1 + sr, cc = c1 + sc;
                    if (Math.abs(r2 - cr) === 2 && Math.abs(c2 - cc) === 2) {
                        if (!isBlocked(cr, cc) && !isBlocked((cr + r2) / 2, (cc + c2) / 2)) return true;
                    }
                }
                // Ruta B (Largo+Giro)
                const longs = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [lr, lc] of longs) {
                    const cr = r1 + lr, cc = c1 + lc;
                    if (Math.abs(r2 - cr) === 1 && Math.abs(c2 - cc) === 1) {
                        if (!isBlocked((r1 + cr) / 2, (c1 + cc) / 2) && !isBlocked(cr, cc)) return true;
                    }
                }
                return false;
            }

            // --- 7. CABALLER√çA PESADA ---
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                const myArmy = logicBoard[r1][c1] ? logicBoard[r1][c1].army : null;
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== myArmy) return true;
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // --- 8. TRABUQUETE ---
            if (type === 'trabuquete') {
                // A. MOVIMIENTO (Destino vac√≠o): Solo Diagonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR === 1 && dC === 1);
                }
                // B. DISPARO (Destino ocupado): Solo Ortogonal
                if (r1 !== r2 && c1 !== c2) return false;

                // Raycast: Ignora unidades, bloquea monta√±a/fortaleza
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;
                    cR += sR; cC += sC;
                }
                return true;
            }

            // --- 9. ESCORPI√ìN ---
            if (type === 'escorpion') {
                // A. MOVIMIENTO (Destino vac√≠o): Solo Ortogonal 1 casilla
                if (logicBoard[r2][c2] === null) {
                    return (dR + dC === 1);
                }
                // B. DISPARO (Destino ocupado): Solo Diagonal
                if (dR !== dC) return false;

                // Raycast complejo (Perforaci√≥n)
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;
                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    const o = logicBoard[cR][cC];
                    // Bloqueos absolutos
                    if (o && (o.type === 'montana' || o.type === 'fortaleza')) return false;

                    // Conteo de enemigos en la trayectoria
                    if (o && o.army !== logicBoard[r1][c1].army) {
                        enemiesInPath++;
                        lastEnemyPos = { r: cR, c: cC };
                    }
                    // No podemos atravesar aliados
                    if (o && o.army === logicBoard[r1][c1].army) return false;

                    cR += sR; cC += sC;
                }

                // L√≥gica de Perforaci√≥n
                if (enemiesInPath === 0) return true; // Disparo directo limpio
                if (enemiesInPath === 1) {
                    // Hay uno en medio, ver si cumple condici√≥n de "distancia 1 o 2"
                    // Distancia se mide en huecos vac√≠os entre unidades.
                    // Si est√°n pegados (gap 0), distanciaManhattan es 2.
                    // Si gap es 1, dist es 3. Si gap es 2, dist es 4.
                    const dist = Math.abs(r2 - lastEnemyPos.r); // Diferencia de filas entre objetivo e intermedio
                    // dist = 1 (pegados), dist = 2 (1 hueco), dist = 3 (2 huecos)
                    if (dist >= 1 && dist <= 3) return true; // Aceptamos 0, 1 y 2 huecos de separaci√≥n
                }

                return false; // M√°s de 1 enemigo o distancia incorrecta
            }

            return true;
        }

        function finishChusmaBonusTurn() {
            isBesieged = false; // <--- A√ëADE ESTA L√çNEA: Apaga la alarma anterior a la fuerza
            // Cambiar turno y volver a la normalidad
            turnColor = (turnColor === 'rojo') ? 'negro' : 'rojo';
            gameState = 'playing';
            chusmaMovedCoords = null;

            showNotification(`Turno ${getArmyName(turnColor)}`);
            renderBoard();
            updateInventories();
            checkTurnStatus();
        }

        // --- SISTEMA DE AMENAZAS (Influence Maps) ---

        // Genera una matriz 10x10 donde cada celda indica cu√°ntas unidades del 'attackingArmy' amenazan esa posici√≥n
        function getThreatMap(attackingArmy) {
            // 1. Crear matriz vac√≠a de ceros
            let map = Array(10).fill().map(() => Array(10).fill(0));

            // 2. Recorrer tablero buscando atacantes
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const piece = logicBoard[r][c];
                    if (piece && piece.army === attackingArmy) {

                        // 3. Para cada pieza, verificar qu√© casillas amenaza
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                // No se amenaza a s√≠ mismo
                                if (r === tr && c === tc) continue;

                                // Usamos la funci√≥n auxiliar de ataque (no de movimiento)
                                if (canUnitAttack(piece.type, r, c, tr, tc, piece.army)) {
                                    map[tr][tc]++;
                                }
                            }
                        }
                    }
                }
            }
            return map;
        }

        // Verifica si una unidad en (r1,c1) podr√≠a atacar/capturar en (r2,c2)
        // Ignoramos qu√© hay en el destino (asumimos que es el objetivo)
        function canUnitAttack(type, r1, c1, r2, c2, army) {
            const dR = Math.abs(r2 - r1);
            const dC = Math.abs(c2 - c1);

            // 1. REY, LANCEROS, CHUSMA (Rango 1)
            // Nota: Asumimos que atacan igual que mueven
            if (type === 'rey') return (dR <= 1 && dC <= 1);
            if (type === 'lanceros' || type === 'chusma') return (dR + dC === 1);

            // 2. ARQUEROS (Distancia 1 o 2 con salto limpio)
            if (type === 'arqueros') {
                if (dR !== dC) return false;
                if (dR === 1) return true;
                if (dR === 2) {
                    const midR = (r1 + r2) / 2, midC = (c1 + c2) / 2;
                    // Solo atacamos si el hueco intermedio est√° vac√≠o/agua (sin obst√°culos s√≥lidos)
                    // Nota: logicBoard[mid] debe ser null para que la flecha pase
                    return (logicBoard[midR][midC] === null && terrain[midR][midC] !== 'water');
                }
                return false;
            }

            // 3. CABALLER√çA LIGERA (Saltos en L diagonal)
            if (type === 'c_ligera') {
                if (!((dR === 3 && dC === 1) || (dR === 1 && dC === 3))) return false;
                // Reutilizamos l√≥gica de bloqueo de isValidMove (simplificada)
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    return (o && (o.type === 'montana' || o.type === 'fortaleza'));
                };
                // Check Ruta A
                const shorts = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                for (let [sr, sc] of shorts) {
                    const cr = r1 + sr, cc = c1 + sc;
                    if (Math.abs(r2 - cr) === 2 && Math.abs(c2 - cc) === 2) {
                        if (!isBlocked(cr, cc) && !isBlocked((cr + r2) / 2, (cc + c2) / 2)) return true;
                    }
                }
                // Check Ruta B
                const longs = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
                for (let [lr, lc] of longs) {
                    const cr = r1 + lr, cc = c1 + lc;
                    if (Math.abs(r2 - cr) === 1 && Math.abs(c2 - cc) === 1) {
                        if (!isBlocked((r1 + cr) / 2, (c1 + cc) / 2) && !isBlocked(cr, cc)) return true;
                    }
                }
                return false;
            }

            // 4. CABALLER√çA PESADA (Saltos en L ortogonal)
            if (type === 'c_pesada') {
                if (!((dR === 2 && dC === 1) || (dR === 1 && dC === 2))) return false;
                // Bloqueo: Monta√±a, Fortaleza o ENEMIGO (el amigo deja pasar, el enemigo frena)
                // Pero para "amenazar" el destino, solo nos importa llegar.
                const isBlocked = (r, c) => {
                    if (r < 0 || r > 9 || c < 0 || c > 9) return true;
                    if (terrain[r][c] === 'water') return true;
                    const o = logicBoard[r][c];
                    if (o) {
                        if (o.type === 'montana' || o.type === 'fortaleza') return true;
                        if (o.army !== army) return true; // Enemigo bloquea el paso intermedio
                    }
                    return false;
                };
                const sR = Math.sign(r2 - r1), sC = Math.sign(c2 - c1);
                if (dR === 2) return !(isBlocked(r1 + sR, c1) || isBlocked(r2, c1)) || !(isBlocked(r1, c2) || isBlocked(r1 + sR, c2));
                else return !(isBlocked(r1, c1 + sC) || isBlocked(r1, c2)) || !(isBlocked(r2, c1) || isBlocked(r2, c1 + sC));
            }

            // 5. UNIDADES DE RAYCAST (Drag√≥n, Elefante, Armas)
            const checkRay = (isOrtho, isDiag, canFly, isWeapon) => {
                // 1. VALIDACI√ìN GEOM√âTRICA (Corregida)
                const validOrtho = (r1 === r2 || c1 === c2);
                const validDiag = (dR === dC);

                if (isOrtho && isDiag) {
                    // Caso Drag√≥n (Reina): Vale cualquiera de los dos
                    if (!validOrtho && !validDiag) return false;
                } else if (isOrtho) {
                    // Caso Elefante / Trabuquete: Solo ortogonal
                    if (!validOrtho) return false;
                } else if (isDiag) {
                    // Caso Escorpi√≥n: Solo diagonal
                    if (!validDiag) return false;
                }

                // 2. C√ÅLCULO DE TRAYECTORIA
                const sR = Math.sign(r2 - r1);
                const sC = Math.sign(c2 - c1);
                let cR = r1 + sR, cC = c1 + sC;

                let enemiesInPath = 0;
                let lastEnemyPos = null;

                while (cR !== r2 || cC !== c2) {
                    // ... (El resto del bucle while se queda IGUAL que lo ten√≠as) ...
                    const obs = logicBoard[cR][cC];

                    if (canFly) {
                        if (obs && obs.type !== 'montana') return false;
                    } else {
                        if (terrain[cR][cC] === 'water' && !isWeapon) return false;
                        if (obs) {
                            if (obs.type === 'montana' || obs.type === 'fortaleza') return false;

                            if (isWeapon && type === 'escorpion') {
                                if (obs.army !== army) { enemiesInPath++; lastEnemyPos = { r: cR, c: cC }; }
                                else return false;
                            } else if (isWeapon && type === 'trabuquete') {
                                // Ignora unidades
                            } else {
                                return false;
                            }
                        }
                    }
                    cR += sR; cC += sC;
                }

                // ... (L√≥gica final de Escorpi√≥n igual) ...
                if (type === 'escorpion' && enemiesInPath > 0) {
                    if (enemiesInPath === 1) {
                        const dist = Math.abs(r2 - lastEnemyPos.r);
                        return (dist >= 1 && dist <= 3);
                    }
                    return false;
                }
                return true;
            };

            if (type === 'dragon') return checkRay(true, true, true, false); // Vuela, Ortho+Diag
            if (type === 'elefante') return checkRay(true, false, false, false); // Tierra, Ortho

            // -- ARMAS: Solo generan amenaza en su modo de DISPARO --
            if (type === 'trabuquete') return checkRay(true, false, false, true); // Dispara Ortho
            if (type === 'escorpion') return checkRay(false, true, false, true); // Dispara Diag

            return false;
        }

        // Verifica si el jugador del turno actual (turnColor) ha perdido o empatado
        function checkTurnStatus() {
            // 1. Calcular mapas
            const enemy = (turnColor === 'rojo') ? 'negro' : 'rojo';
            const threatMap = getThreatMap(enemy);
            const attackMap = getThreatMap(turnColor);

            // A. DETECCI√ìN DE ASEDIO (ESTE BLOQUE FALTABA EN TU ARCHIVO)
            isBesieged = false;
            const myFort = fortressPos[turnColor];

            if (myFort) {
                let enemiesAtGate = 0;
                // Revisamos todo el tablero buscando enemigos en MI anillo
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        // Si la casilla es parte de mi anillo de salida
                        if (isInExitZone(r, c, myFort)) {
                            const p = logicBoard[r][c];
                            // Y hay una unidad enemiga
                            if (p && p.army === enemy) {
                                enemiesAtGate++;
                            }
                        }
                    }
                }
                // Si hay 2 o m√°s, activamos la bandera de asedio
                if (enemiesAtGate >= 2) isBesieged = true;
            }


            // B. BUSCAR AL REY
            let kingPos = null;
            let hasPieces = false;
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === turnColor) {
                        hasPieces = true;
                        if (p.type === 'rey') kingPos = { r, c };
                    }
                }
            }

            if (!kingPos) {
                isCheck = false; // <--- LIMPIEZA OBLIGATORIA DEL ESTADO ANTERIOR
                updateStatusBar();
                return;
            }

            // 2. DETECCI√ìN DE JAQUE
            isCheck = (threatMap[kingPos.r][kingPos.c] > 0);

            // C. ACTUALIZAR INTERFAZ (PRIORIDAD ALERTA)
            if (isCheck || isBesieged) {
                updateStatusBar();
            }

            // D. VERIFICAR MOVIMIENTOS LEGALES (MATE / AHOGADO)
            currentThreatMap = threatMap;
            currentAttackMap = attackMap;

            let hasMoves = false;

            outerLoop:
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === turnColor) {
                        for (let tr = 0; tr < 10; tr++) {
                            for (let tc = 0; tc < 10; tc++) {
                                if (isValidMove(p.type, r, c, tr, tc)) {
                                    if (terrain[tr][tc] === 'water' && p.type !== 'trabuquete' && p.type !== 'escorpion') continue;
                                    const target = logicBoard[tr][tc];
                                    if (target && target.army === turnColor && p.type !== 'lanceros') continue;
                                    if (target && (target.type === 'montana' || target.type === 'fortaleza')) continue;

                                    hasMoves = true;
                                    break outerLoop;
                                }
                            }
                        }
                    }
                }
            }

            // E. RESOLUCI√ìN DE PARTIDA
            if (!hasMoves) {
                if (isCheck) {
                    finishGame(enemy, "POR JAQUE MATE");
                } else {
                    finishGame(null, "TABLAS POR REY AHOGADO");
                }
            }
        }

        // Helper para terminar partida (si no la ten√≠as ya de mis intentos anteriores)
        function finishGame(winnerArmy, reason = "") {
            gameState = 'game-over';
            const winnerText = winnerArmy ? `VICTORIA DEL EJ√âRCITO ${winnerArmy.toUpperCase()}` : "EMPATE";
            const bar = document.getElementById('status-bar');
            bar.innerText = `üèÅ FIN DE PARTIDA: ${reason}. ${winnerText}`;
            bar.style.color = winnerArmy ? '#2ecc71' : '#fff';
            bar.style.fontWeight = 'bold';
        }

        // Actualiza la barra de estado gestionando prioridades y colores
        function updateStatusBar() {
            const bar = document.getElementById('status-bar');
            const text = getStatusText();
            bar.innerText = text;

            // A√ëADIMOS isBesieged A LA CONDICI√ìN DE P√ÅNICO
            if (gameState === 'siege-resolution' || isCheck || isBesieged) {
                bar.classList.add('status-critical');
            } else {
                bar.classList.remove('status-critical');
                if (!bar.style.color || bar.style.color === 'rgb(231, 76, 60)') {
                    bar.style.color = 'var(--c-gold)';
                }
            }
        }

        // Traduce el color del ej√©rcito a su territorio (Norte/Sur)
        function getArmyName(armyColor) {
            // Si a√∫n no hemos definido territorios (inicio), devolvemos el color
            if (!p1Territory) return "DE " + armyColor.toUpperCase();

            const isP1 = (armyColor === p1Color);
            // Si soy P1 y P1 es Norte -> Norte. Si no -> Sur.
            const isNorth = isP1 ? (p1Territory === 'north') : (p1Territory === 'south');

            return isNorth ? "DEL NORTE" : "DEL SUR";
        }


        // Ejecuta el asedio cuando no hay prisioneros que rescatar
        function triggerEmptySiege(attacker, victim) {
            // 1. Identificar y devolver tropas de asedio a casa
            const fortPos = fortressPos[victim];
            let rescueTeam = [];

            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];
                    if (p && p.army === attacker && isInExitZone(r, c, fortPos)) {
                        // Devolvemos a reserva y quitamos del tablero
                        logicBoard[r][c] = null;
                        reserves[attacker][p.type]++;
                    }
                }
            }

            // 2. Notificar
            showNotification("‚öîÔ∏è Asedio sin prisioneros: Tropas replegadas. ¬°EL ENEMIGO DEBE SACRIFICAR!");

            // 3. Activar Fase de Sacrificio (Usando tu mec√°nica existente en handleDrop)
            gameState = 'siege-resolution';
            besiegedArmy = victim;
            turnColor = victim; // Turno para el que sufre el sacrificio

            // 4. Actualizar todo
            updateStatusBar();
            renderBoard();
            updateInventories();
            updateDungeons();
        }

        // =========================================================
        //  FUNCIONES DE GESTI√ìN DE ASEDIO Y CONSECUENCIAS
        // =========================================================

        // 1. Caso A: El jugador hace click en un prisionero (Ya ten√≠as el onclick en updateDungeons)
        function selectPrisonerToRescue(jailerArmy, index) {
            // jailerArmy es el Defensor (donde estaban presos). 
            // turnColor es el Atacante (quien est√° eligiendo).
            const attackerArmy = turnColor;
            const defenderArmy = jailerArmy;
            const prisoner = dungeons[jailerArmy][index];

            // 1. Recuperar prisionero (Vuelve a la reserva del atacante)
            dungeons[jailerArmy].splice(index, 1);
            reserves[attackerArmy][prisoner.type]++;

            showNotification(`üîì ¬°${prisoner.type.toUpperCase()} LIBERADO!`);

            // 2. Retirar tropas de asedio (Vuelven a casa)
            executeSiegeReturn(defenderArmy, attackerArmy);

            // 3. TURNO DEL DEFENSOR: Intentar salvar algo (Hubo intercambio = TRUE)
            startSacrificePhase(defenderArmy, true);
        }
        // 2. Caso B: No hab√≠a prisioneros (Asedio "accidental" o sin bot√≠n)
        function resolveSiegeNoPrisoners(attacker, victim) {
            // A. Devolver tropas del atacante a casa
            executeSiegeReturn(victim, attacker);

            // B. Verificar consecuencias para el defensor (Hubo intercambio = FALSE)
            startSacrificePhase(victim, false);
        }

        // Auxiliar: Devuelve las tropas de asedio a casa (VERSI√ìN BLINDADA)
        function executeSiegeReturn(victimArmy, attackerArmy) {
            const fortPos = fortressPos[victimArmy];
            if (!fortPos) return; // Seguridad

            // Recorremos todo el tablero para asegurar limpieza total
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const p = logicBoard[r][c];

                    // Si encontramos una unidad del ATACANTE en la zona de salida de la V√çCTIMA
                    if (p && p.army === attackerArmy && isInExitZone(r, c, fortPos)) {
                        logicBoard[r][c] = null; // Eliminar del tablero
                        reserves[attackerArmy][p.type]++; // Devolver a reserva
                    }
                }
            }
            // Forzamos repintado inmediato para que no haya dudas visuales
            renderBoard();
            updateInventories();
        }

        // 3. FASE FINAL: Verificar si hay sacrificio o si la fortaleza est√° vac√≠a
        function startSacrificePhase(victimArmy, wasExchange) {
            turnColor = victimArmy; // Aseguramos que el turno es del defensor
            isBesieged = false; // <--- A√ëADE ESTA L√çNEA: Apaga la alarma anterior a la fuerza

            // 1. Comprobar reservas
            let hasReserves = false;
            let hasKing = (reserves[victimArmy]['rey'] > 0);

            for (const type in reserves[victimArmy]) {
                if (reserves[victimArmy][type] > 0) hasReserves = true;
            }

            // CASO ESPECIAL: "CAPTURA TOTAL" (√öltimo supuesto)
            // No hubo intercambio Y no est√° el Rey -> El defensor no tiene derecho a salvar nada.
            if (hasReserves && !wasExchange && !hasKing) {
                // Captura autom√°tica de todo
                const attacker = (victimArmy === 'rojo') ? 'negro' : 'rojo';
                let capturedCount = 0;

                for (const [type, count] of Object.entries(reserves[victimArmy])) {
                    if (type === 'montana') continue;
                    if (count > 0) {
                        for (let i = 0; i < count; i++) {
                            dungeons[attacker].push({ type: type, army: victimArmy });
                            capturedCount++;
                        }
                        reserves[victimArmy][type] = 0;
                    }
                }

                showNotification(`üö´ Sin intercambio: ${capturedCount} unidades capturadas en la reserva.`);

                // Volver al juego
                gameState = 'playing';
                besiegedArmy = null;
                // El turno se queda en el defensor para que mueva en el tablero (o pasa, seg√∫n prefieras. 
                // Tu l√≥gica dec√≠a "mantiene el turno en modo normal", as√≠ que no cambiamos turnColor).
                checkTurnStatus();

                renderBoard(); updateInventories(); updateDungeons();
                return;
            }

            // CASO EST√ÅNDAR: Puede salvar (o debe salvar al Rey)
            if (hasReserves) {
                let msg = wasExchange
                    ? `üö® FORTALEZA CA√çDA: ${victimArmy.toUpperCase()}, salva una unidad.`
                    : `üëë ¬°PELIGRO CR√çTICO! ${victimArmy.toUpperCase()}, DEBES SALVAR AL REY (El resto ser√° capturado).`;

                showNotification(msg);
                gameState = 'siege-resolution';
                besiegedArmy = victimArmy;
                updateStatusBar();
            } else {
                // CASO: NO TIENE RESERVAS (Ni para salvar ni para perder)
                showNotification("üì≠ Fortaleza vac√≠a. Fin del asedio.");
                gameState = 'playing';
                besiegedArmy = null;
                checkTurnStatus();
            }

            renderBoard(); updateInventories(); updateDungeons();
        }

        // Funci√≥n nueva: Ejecuta el asedio una vez confirmado por el jugador
        function executeConfirmedSiege(attackerArmy, defenderArmy) {
            // CORRECCI√ìN + SEGURIDAD: Buscamos tropas del ATACANTE en la mazmorra del DEFENSOR.
            const prisoners = dungeons[defenderArmy].filter(p => p.army === attackerArmy);

            if (prisoners.length > 0) {
                // CASO A: HAY RESCATE REAL -> EL ATACANTE ELIGE
                turnColor = attackerArmy;
                gameState = 'siege-prisoner-select';
                showNotification(`‚öîÔ∏è ASEDIO √âPICO: ${attackerArmy.toUpperCase()}, elige a qui√©n rescatar.`);
                renderBoard(); updateInventories(); updateDungeons();
            } else {
                // CASO B: NO HAY PRISIONEROS -> RESOLUCI√ìN DIRECTA
                resolveSiegeNoPrisoners(attackerArmy, defenderArmy);
            }
        }

    </script>
</body>

</html>